diff --git a/doc/man/mc.1.in b/doc/man/mc.1.in
index 74b53a4..044e33b 100644
--- a/doc/man/mc.1.in
+++ b/doc/man/mc.1.in
@@ -2973,6 +2973,10 @@ Sections:
 .\"LINK2"
 Options of editor in ini\-file
 .\"Internal File Editor / options"
+.IP
+.\"LINK2"
+Unescape, reencode and insert string
+.\"NODE "Internal File Editor / estring"/
 .PP
 The editor is very easy to use and requires no tutoring. To see what
 keys do what, just consult the appropriate pull\-down menu. Other keys
@@ -3115,6 +3119,216 @@ symbols (as \fB\\?\fR, \fB\\*\fR, \fB\\&\fR )
 in filenames to disallow use them as metasymbols in regular expressions
 when substitution is performed in the input line.
 
+.\"NODE "Internal File Editor / estring"
+.SH "Internal File Editor: Unescape, reencode and insert string"
+The options in this dialog are divided into several groups: 
+"Select input encoding", "Escaping method", and "Other options".
+.PP
+.B Select input encoding
+.PP
+.I Encoding...
+Show up a list of encodings. User can select one to reencode inserted
+string from
+.B selected encoding
+to
+.B editor encoding
+(user can set this by M\-e or Alt\-e for editor).
+If you select a 8 bit encoding for input (e.g. ISO-8859-1 or CP437)
+you can insert only those unicode characters which exists in the
+input encoding. even the editor codepage is
+.B UTF-8
+.
+.PP
+.B Escaping method
+.PP
+Here user can choose one of escape styles.
+.PP
+.I C-style
+This select the C string literal style escape method. Escape character:
+.IR "\\ " (backslash)
+.TP
+Known escape sequences:
+.br
+.B \\\\\\\\
+insert a \\ (backslash)
+.br
+.B \\\\a
+insert a bell (decimal 7, BEL) character
+.br
+.B \\\\b
+insert a backspace (decimal 8, BS) character
+.br
+.B \\\\t
+insert a horizontal tab (decimal 9, HT) character
+.br
+.B \\\\n
+insert a line feed (decimal 10, LF) character
+.br
+.B \\\\v
+insert a vertical tab (decimal 11, VT) character
+.br
+.B \\\\f
+insert a form feed (decimal 12, FF) character
+.br
+.B \\\\r
+insert a carriage return (decimal 13, CR) character
+.br
+.B \\\\e
+insert an escape (decimal 27, ESC) character
+.br
+.B \\\\xhh
+insert a character represented by number `hh' (hexadecimal),
+where `h' between 0-9 and a-f (or A-F).
+.br
+.B \\\\ooo
+insert a character represented by number `ooo' (octal),
+where `o' between 0-7. If `ooo' greater than 377o
+a warning message pop up for the user.
+.PP
+For example, the
+.B The\\\\tquick\\\\x09brown\\\\040fox\\\\njumps\\\\ over
+insert the string:
+.PP
+The	quick	brown fox
+.br
+jumps\\\\ over
+.PP
+.I HTML-style
+This select the HTML style escape method. Escape character:
+.IR "& " (at)
+.TP
+Escape sequence:
+.br
+.B &entity;
+insert a character represented by HTML entity name `entity'.
+.br
+.B &#ddddd;
+insert a unicode character represented by number `ddddd' (decimal),
+where `d' between 0-9.
+.br
+.B &#xhhhh;
+insert a unicode character represented by number `hhhh' (hexadecimal),
+where `h' between 0-9 and a-f (or A-F).
+.PP
+For example, the
+.B The&#09;quick&#9;brown&#x0020;fox&#x0a;jumps&#x5C; over
+insert the same string as above.
+.PP
+.I URL-style
+This select the URL style escape method. Escape character:
+.IR "% " (percent)
+.PP
+Escape sequence:
+.br
+.B %hh
+insert a character represented by number `hh' (hexadecimal),
+where `h' between 0-9 and a-f (or A-F). You can use %25 for a literal %.
+.PP
+For example, the
+.B The%09quick%09brown%20fox%0ajumps%5C%20over
+insert the same string as above.
+.PP
+.I Hex-string
+This select the hex-string style. There is no escape character, but every
+two character represent a hexadecimal number (`hh')
+where `h' between 0-9 and a-f (or A-F)
+.PP
+For example, the
+.B 54686509717569636B0962726F776E20666F780A6A756D7073206F766572
+insert the same string as above.
+.PP
+.I Numpad-style
+This select the DOS/Windows ALT+numpad style escape method. Escape character:
+.IR "^ " (caret)
+.PP
+Escape sequences:
+.br
+.B ^ddd
+insert a character represented by number `ddd' (decimal),
+where `d' between 0-9. You can use ^94 for a literal ^.
+You sould use the correct codepage to the perfect characters.
+(CP437 for the original DOS OEM characters)
+.PP
+For example, the
+.B The^9quick^09brown^32fox^10jumps^92 over
+insert the same string as above.
+.PP
+.B Other options
+.PP
+.I Accept unicode
+When checked,
+.B C escape method
+,
+.B URL escape method
+and
+.B Numpad escape method
+accept
+.B \\\\uhhhh
+,
+.B %uhhhh
+and
+.B ^+hhhh
+escape sequences, insert a unicode character represented
+by number `hhhh' (hexadecimal), where `h' between 0-9 and
+a-f (or A-F).
+.PP
+.I Insert invalid chars
+When checked,
+.B Hex-string escape method
+accept and insert non hexadecimal characters (out of 0-9, a-f, and A-F)
+as is. For example: Th65 insert the
+.B The
+string.
+.PP
+.I Show warnings
+When checked,
+.B out of range
+octal numbers (greather than 377o) in
+.BR "C-style escape method" ,
+.B out of range
+decimal numbers (greather than 255d) in
+.B Numpad-style escape method
+and
+.B character code conversion errors
+pop up a warning message for the users.
+.br
+Please note, if you use unicode (UTF-16) escape sequences than
+an aditional character code conversion occur from UTF-16 to
+the
+.B "selected"
+(input) codepage.
+.br
+For example, if the selected codepage is
+.B CP437
+, the editor codepage is 
+.B ISO-8859-1
+and the string is
+.B \\\\u00EAtre \\\\x82crits
+than first
+.B \\\\u00EA
+converted to
+.B \\\\x88
+than the whole string converted from
+.B CP437
+to
+.B ISO-8859-1
+.
+.PP
+.B Insert text from a file
+.PP
+Press 
+.I "[From file]"
+to read and insert escaped text from a file.
+
+.
+.PP
+.B Process marked text
+.PP
+Press 
+.I [Marked]
+to unescape and reencode marked text. If there is no marked text, editor ask
+to work on current line or the whole file.
+
 .\"NODE "Virtual File System"
 .SH "Virtual File System"
 The Midnight Commander is provided with a code layer to access the file
diff --git a/lib/keybind.c b/lib/keybind.c
index eedea6b..2a1261b 100644
--- a/lib/keybind.c
+++ b/lib/keybind.c
@@ -312,6 +312,7 @@ static name_keymap_t command_names[] = {
     {"BlockShiftLeft", CK_BlockShiftLeft},
     {"BlockShiftRight", CK_BlockShiftRight},
     {"InsertLiteral", CK_InsertLiteral},
+    {"InsertEstring", CK_InsertEstring},
     {"ShowTabTws", CK_ShowTabTws},
     {"SyntaxOnOff", CK_SyntaxOnOff},
     {"SyntaxChoose", CK_SyntaxChoose},
diff --git a/lib/keybind.h b/lib/keybind.h
index 5bfb81b..0c2736d 100644
--- a/lib/keybind.h
+++ b/lib/keybind.h
@@ -301,6 +301,7 @@ enum
     CK_SyntaxOnOff,
     CK_SyntaxChoose,
     CK_InsertLiteral,
+    CK_InsertEstring,
     CK_ExternalCommand,
     CK_Date,
     CK_Mail,
diff --git a/misc/mc.default.keymap b/misc/mc.default.keymap
index f627fad..ab617b0 100644
--- a/misc/mc.default.keymap
+++ b/misc/mc.default.keymap
@@ -321,6 +321,7 @@ BookmarkPrev = alt-i
 # History =
 Shell = ctrl-o
 InsertLiteral = ctrl-q
+InsertEstring = ctrl-w
 # MacroStartRecord =
 # MacroStopRecord =
 MacroStartStopRecord = ctrl-r
diff --git a/misc/mc.emacs.keymap b/misc/mc.emacs.keymap
index 1f89773..708a9a9 100644
--- a/misc/mc.emacs.keymap
+++ b/misc/mc.emacs.keymap
@@ -320,6 +320,7 @@ Menu = f9
 # History =
 Shell = ctrl-o
 InsertLiteral = ctrl-q
+InsertEstring = ctrl-w
 # MacroStartRecord =
 # MacroStopRecord =
 MacroStartStopRecord = ctrl-r
diff --git a/src/editor/Makefile.am b/src/editor/Makefile.am
index 0ca0fc5..3aceec0 100644
--- a/src/editor/Makefile.am
+++ b/src/editor/Makefile.am
@@ -15,6 +15,7 @@ libedit_la_SOURCES = \
 	editcmd.c \
 	editcmd_dialogs.c editcmd_dialogs.h \
 	editdraw.c \
+	editestring.c \
 	editmenu.c \
 	editoptions.c \
 	editwidget.c editwidget.h \
diff --git a/src/editor/edit-impl.h b/src/editor/edit-impl.h
index e840d30..eca7af8 100644
--- a/src/editor/edit-impl.h
+++ b/src/editor/edit-impl.h
@@ -69,6 +69,8 @@
 
 #define LB_NAMES (LB_MAC + 1)
 
+#define ESC_NAMES (ESC_NUMP + 1)
+
 #define get_sys_error(s) (s)
 
 #define edit_error_dialog(h,s) query_dialog (h, s, D_ERROR, 1, _("&Dismiss"))
@@ -94,6 +96,16 @@ typedef enum
     EDIT_DO_BACKUP
 } edit_save_mode_t;
 
+/* escape styles */
+typedef enum
+{
+    ESC_C = 0,
+    ESC_HTML,
+    ESC_URL,
+    ESC_HEX,
+    ESC_NUMP
+} EscapeStyles;
+
 /*** structures declarations (and typedefs of structures)*****************************************/
 
 /* search/replace options */
@@ -254,6 +266,7 @@ gboolean edit_paste_from_X_buf_cmd (WEdit * edit);
 
 void edit_select_codepage_cmd (WEdit * edit);
 void edit_insert_literal_cmd (WEdit * edit);
+void edit_insert_estring_cmd (WEdit * edit);
 gboolean edit_execute_macro (WEdit * edit, int hotkey);
 void edit_begin_end_macro_cmd (WEdit * edit);
 void edit_begin_end_repeat_cmd (WEdit * edit);
diff --git a/src/editor/edit.c b/src/editor/edit.c
index 4e9fb2d..d49529c 100644
--- a/src/editor/edit.c
+++ b/src/editor/edit.c
@@ -204,24 +204,6 @@ edit_find_filter (const vfs_path_t * filename_vpath)
 
 /* --------------------------------------------------------------------------------------------- */
 
-static char *
-edit_get_filter (const vfs_path_t * filename_vpath)
-{
-    int i;
-    char *p, *quoted_name;
-
-    i = edit_find_filter (filename_vpath);
-    if (i < 0)
-        return NULL;
-
-    quoted_name = name_quote (vfs_path_as_str (filename_vpath), 0);
-    p = g_strdup_printf (all_filters[i].read, quoted_name);
-    g_free (quoted_name);
-    return p;
-}
-
-/* --------------------------------------------------------------------------------------------- */
-
 static off_t
 edit_insert_stream (WEdit * edit, FILE * f)
 {
@@ -3839,6 +3821,9 @@ edit_execute_cmd (WEdit * edit, unsigned long command, int char_for_insertion)
     case CK_InsertLiteral:
         edit_insert_literal_cmd (edit);
         break;
+    case CK_InsertEstring:
+        edit_insert_estring_cmd (edit);
+        break;
     case CK_MacroStartStopRecord:
         edit_begin_end_macro_cmd (edit);
         break;
@@ -3962,3 +3947,22 @@ edit_move_down (WEdit * edit, long i, gboolean do_scroll)
 }
 
 /* --------------------------------------------------------------------------------------------- */
+
+char *
+edit_get_filter (const vfs_path_t * filename_vpath)
+{
+    int i;
+    char *p, *quoted_name;
+
+    i = edit_find_filter (filename_vpath);
+    if (i < 0)
+        return NULL;
+
+    quoted_name = name_quote (vfs_path_as_str (filename_vpath), 0);
+    p = g_strdup_printf (all_filters[i].read, quoted_name);
+    g_free (quoted_name);
+    return p;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
diff --git a/src/editor/edit.h b/src/editor/edit.h
index 2382d73..81b38b3 100644
--- a/src/editor/edit.h
+++ b/src/editor/edit.h
@@ -70,6 +70,7 @@ gboolean edit_files (const GList * files);
 char *edit_get_file_name (const WEdit * edit);
 long edit_get_curs_col (const WEdit * edit);
 const char *edit_get_syntax_type (const WEdit * edit);
+char *edit_get_filter (const vfs_path_t * filename_vpath);
 
 /*** inline functions ****************************************************************************/
 #endif /* MC__EDIT_H */
diff --git a/src/editor/editestring.c b/src/editor/editestring.c
new file mode 100644
index 0000000..96dfeee
--- /dev/null
+++ b/src/editor/editestring.c
@@ -0,0 +1,1070 @@
+/*
+   Editor unescape reencode and insert string
+
+   Copyright (C) 2013
+   The Free Software Foundation, Inc.
+
+   Written by:
+   Gergely Szasz <szaszg@hu.inter.net> 2013
+
+   This file is part of the Midnight Commander.
+
+   The Midnight Commander is free software: you can redistribute it
+   and/or modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation, either version 3 of the License,
+   or (at your option) any later version.
+
+   The Midnight Commander is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** \file
+ *  \brief Source: editor unescape reencode and insert string
+ *  \author Gergely Szasz
+ *  \date 2013
+ */
+
+
+#include <config.h>
+
+#ifdef HAVE_ASSERT_H
+#include <assert.h>
+#endif
+#include <ctype.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <fcntl.h>
+
+#include "lib/global.h"
+#include "lib/tty/tty.h"
+#include "lib/tty/key.h"        /* XCTRL */
+#include "lib/mcconfig.h"
+#include "lib/skin.h"
+#include "lib/strutil.h"        /* utf string functions */
+#include "lib/lock.h"
+#include "lib/util.h"           /* tilde_expand() */
+#include "lib/vfs/vfs.h"
+#include "lib/widget.h"
+#include "lib/event.h"          /* mc_event_raise() */
+#ifdef HAVE_CHARSET
+#include "lib/charsets.h"
+#endif
+
+#include "src/history.h"
+#include "src/setup.h"          /* option_tab_spacing */
+#ifdef HAVE_CHARSET
+#include "src/selcodepage.h"
+#endif
+#include "src/keybind-defaults.h"
+#include "src/util.h"           /* check_for_default() */
+#include "src/filemanager/layout.h"     /* mc_refresh()  */
+
+#include "edit-impl.h"
+#include "editwidget.h"
+#include "editcmd_dialogs.h"
+#ifdef HAVE_ASPELL
+#include "spell.h"
+#include "spell_dialogs.h"
+#endif
+#include "etags.h"
+#include "etags.h"
+
+/*** global variables ****************************************************************************/
+
+
+/*** file scope macro definitions ****************************************************************/
+
+#define UNUSED_ARG(x) {(void)(x);}
+
+#define RECODE_LABEL 6
+
+#define TEMP_BUF_LEN 1024
+
+#define B_FILE (B_USER + 1)
+#define B_MARK (B_USER + 2)
+
+/*** file scope type declarations ****************************************************************/
+
+typedef struct
+{
+    const char *name;
+    gint32 u;
+} html_enc_t;
+
+/*** file scope variables ************************************************************************/
+
+/* include html entities table for edit_insert_estring () */
+#include "html_enc_table.h"
+
+/* --------------------------------------------------------------------------------------------- */
+/*** file scope functions ************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
+
+static void
+edit_utf16recode (GIConv cnv, guint32 u, GString **out, int *show_warn, int curr_index)
+{
+    char str[4];
+#ifdef HAVE_CHARSET
+    gchar *ostr;
+    gsize olen;
+    GError *err = NULL;
+
+    str[0] = u & 0xff;
+    str[1] = (u >> 8) & 0xff;
+    str[2] = (u >> 16) & 0xff;
+    str[3] = (u >> 24) & 0xff;
+    ostr = g_convert_with_iconv (str, 4, cnv, NULL, &olen, &err);
+    if (*show_warn && (err != NULL || ostr == NULL))
+    {
+        char *tmp;
+        tmp = g_strdup_printf (_("Error when reencoding string at %u:\n%s"), curr_index,
+                               err == NULL ? "No result from conversion!" : err->message);
+        if (query_dialog (_("Warning"), tmp, D_ERROR, 2, _("&Dismiss"), _("Dismiss &All")) == 1)
+            *show_warn = 0;
+        g_free (tmp);
+    }
+    if (ostr != NULL)
+    {
+        *out = g_string_append (*out, ostr);
+        g_free (ostr);
+    }
+#else
+    UNUSED_ARG (cnv);
+    UNUSED_ARG (show_warn);
+    /* convert UTF-16 to UTF-8 */
+    if (u <= 0x7f)
+    {
+        str[0] = u;
+        str[1] = '\0';
+    }
+    else if (u > 0x07FF)
+    {
+        str[0] = 0xe0 | ((u >> 12) & 0x0f);
+        str[1] = 0x80 | ((u >>  6) & 0x3f);
+        str[2] = 0x80 | (u & 0x3f);
+        str[3] = '\0';
+    } else {
+        str[0] = 0xc0 | ((u >>  6) & 0x1f);
+        str[1] = 0x80 | ((u >>  0) & 0x3f);
+        str[2] = '\0';
+    }
+    *out = g_string_append (*out, str);
+#endif /* HAVE_CHARSET */
+}
+
+/* --------------------------------------------------------------------------------------------- */
+/*** public functions ****************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
+
+void
+edit_insert_estring_cmd (WEdit * edit)
+{
+    char *string;
+    static int esc_style = ESC_C;
+    static int show_warn = 1;
+    static int accept_u = 1;
+    static int accept_i = 1;
+    const char *esc_names[ESC_NAMES] = {
+        N_("&C-style"),
+        N_("&HTML-style"),
+        N_("&URL-style"),
+        N_("He&x-string"),
+        N_("&Numpad-style")
+    };
+    int ret;
+    int mark = 0;
+#ifdef HAVE_CHARSET
+    GString *str_recode = NULL;
+    const char *str_recode_tpl = N_("Recode: %s%s%s");
+    static int cp_id = -1;
+    int cp_to, recode;
+#endif /* HAVE_CHARSET */
+
+    quick_widget_t quick_widgets[] = {
+        /* *INDENT-OFF* */
+        QUICK_LABELED_INPUT (N_("Enter string:"), input_label_above, INPUT_LAST_TEXT,
+                             "insert-escaped-string", &string, NULL, FALSE, FALSE,
+                             INPUT_COMPLETE_NONE),
+//        QUICK_BUTTON (N_("Insert from &File..."), B_FILE, NULL, NULL),
+        QUICK_SEPARATOR (TRUE),
+        QUICK_START_COLUMNS,
+#ifdef HAVE_CHARSET
+            QUICK_BUTTON (N_("&Encoding..."), B_USER, NULL, NULL),
+#else
+            QUICK_SEPARATOR (FALSE),
+#endif /* HAVE_CHARSET */
+            QUICK_RADIO (ESC_NAMES, esc_names, (int *) &esc_style, NULL),
+        QUICK_NEXT_COLUMN,
+            QUICK_LABEL(NULL, NULL),
+            QUICK_SEPARATOR (FALSE),
+            QUICK_CHECKBOX (N_("&Accept unicode"), &accept_u, NULL),
+            QUICK_CHECKBOX (N_("&Insert invalid chars"), &accept_i, NULL),
+            QUICK_CHECKBOX (N_("&Show warnings"), &show_warn, NULL),
+        QUICK_STOP_COLUMNS,
+        QUICK_START_BUTTONS (TRUE, TRUE),                                           \
+            QUICK_BUTTON (N_("&OK"), B_ENTER, NULL, NULL),                          \
+            QUICK_BUTTON (N_("&From File"), B_FILE, NULL, NULL),
+            QUICK_BUTTON (N_("&Marked"), B_MARK, NULL, NULL),
+            QUICK_BUTTON (N_("&Cancel"), B_CANCEL, NULL, NULL),
+        QUICK_END
+        /* *INDENT-ON* */
+    };
+
+    quick_dialog_t qdlg = {
+        -1, -1, 64,
+        N_("Unescape, reencode and insert string"), "[Internal File Editor / estring]",
+        quick_widgets, NULL, NULL
+    };
+
+#ifdef HAVE_CHARSET
+    cp_to = mc_global.source_codepage >=
+                         0 ? mc_global.source_codepage : mc_global.display_codepage;
+    cp_id = cp_id == -1 ? cp_to : cp_id;
+    recode = (cp_id != cp_to);
+    str_recode = g_string_new ("");
+    g_string_printf (str_recode, str_recode_tpl,
+                     recode ? get_codepage_id (cp_id) : "",
+                     recode ? " to " : "-",
+                     recode ? get_codepage_id (cp_to) : "");
+    quick_widgets[RECODE_LABEL].u.label.text = str_recode->str;
+#endif
+    while ((ret = quick_dialog (&qdlg)) != B_CANCEL)
+    {
+        FILE *finp = NULL;
+        int fdinp = -1, fdout = -1;
+        int insert_from_file = 0;
+        vfs_path_t *temp_vpath;
+        char *file_buff = NULL;
+        gsize len = 0;
+        GIConv cnvu = INVALID_CONV;
+#ifdef HAVE_CHARSET
+        int lcp_id = -1;
+#endif
+        /* feed from marked */
+        /* feed from a file */
+        if (ret == B_FILE || ret == B_MARK)
+        {
+
+            if (insert_from_file == 0) /* Initialize file input */
+            {
+                char *p;
+                char *tmp;
+                char *exp = NULL;
+                vfs_path_t *file_vpath;
+
+                g_free (string);
+
+                if (ret != B_MARK)
+                {
+                    tmp = mc_config_get_full_path (EDIT_CLIP_FILE);
+                    exp = input_expand_dialog (_("Insert from file"), _("Enter file name:"),
+                                           MC_HISTORY_EDIT_INSERT_FILE, tmp, INPUT_COMPLETE_FILENAMES);
+                    g_free (tmp);
+                    if (exp == NULL || *exp == '\0')
+                        break;
+                }
+
+                fdout = mc_mkstemps (&temp_vpath, "estring", NULL);
+                if (fdout <= 0)
+                {
+                    edit_error_dialog (_("Error"), _("Cannot create temporary file!"));
+                    g_free (exp);
+                    break;
+                }
+                if (ret == B_MARK)
+                {
+                    int fdclip;
+                    off_t start_mark, end_mark;
+
+                    if (!eval_marks (edit, &start_mark, &end_mark))
+                    {
+                        int rv;
+
+                        rv = edit_query_dialog3 (_("Warning"),
+                                                 _("There is no marked block.\nProcess whole file or current line?"),
+                                                 _("&Whole file"), _("Current &Line"), _("&Cancel"));
+                        switch (rv)
+                        {
+                        case 0:
+                            edit_set_markers (edit, 0, edit->buffer.size, 0, 0);
+                            eval_marks (edit, &start_mark, &end_mark);
+                            mark = 2;     /* later we have to reset highlite ?*/
+                            break;
+                        case 1:
+                            edit->mark1 = edit_buffer_get_current_bol (&edit->buffer);
+                            edit->mark2 = edit_buffer_get_current_eol (&edit->buffer);
+                            eval_marks (edit, &start_mark, &end_mark);
+                            break;
+                        default:
+                            mark = -1;
+                            break;
+                        }
+                        if (mark == -1)
+                            break;
+                    }
+                    fdclip = mc_mkstemps (&file_vpath, "estring", NULL);
+                    if (fdclip < 0)
+                    {
+                        edit_error_dialog (_("Save block"), get_sys_error (_("Cannot create temporary file")));
+                        break;
+                    }
+                    close (fdclip);
+//                    exp = vfs_path_to_str (file_vpath);
+                    exp = vfs_path_to_str_flags (file_vpath, 0, VPF_STRIP_PASSWORD);
+                    if (!edit_save_block (edit, exp, start_mark, end_mark))
+                    {
+                        edit_error_dialog (_("Save block"), get_sys_error (_("Cannot save file")));
+                        break;
+                    }
+                    mark = 1;
+                }
+                else
+                {
+                    file_vpath = vfs_path_from_str (exp);
+                }
+                p = edit_get_filter (file_vpath);
+                if (p != NULL)
+                {
+                    if (mark)
+                        mc_unlink (file_vpath);
+                    vfs_path_free (file_vpath);
+                    finp = (FILE *) popen (p, "r");
+                    if (finp == NULL)
+                    {
+                        close (fdout);
+                        edit_error_dialog (_("Open filter"), get_sys_error (_("Cannot open file filter")));
+                        g_free (exp);
+                        break;
+                    }
+                }
+                else
+                {
+                    fdinp = mc_open (file_vpath, O_RDONLY | O_BINARY);
+                    if (mark)
+                        mc_unlink (file_vpath);
+                    vfs_path_free (file_vpath);
+                    if (fdinp == -1)
+                    {
+                        char *errmsg;
+
+                        close (fdout);
+                        errmsg = g_strdup_printf (_("Cannot open file for reading: %s"), exp);
+                        edit_error_dialog (_("Error"), errmsg);
+                        g_free (errmsg);
+                        g_free (exp);
+                        break;
+                    }
+                }
+                g_free (exp);
+                file_buff = g_malloc (TEMP_BUF_LEN);
+                string = file_buff;
+                ret = B_ENTER; /* convert string */
+                insert_from_file = 1;
+            }
+continue_file:
+            /* read next string */
+            if (insert_from_file == 1)
+            {
+                size_t blocklen;
+                if (finp != NULL)
+                {
+                    blocklen = fread (file_buff, 1, TEMP_BUF_LEN, finp);
+                    if (blocklen == 0 && feof (finp))
+                    {
+                        insert_from_file = 2;
+                        if (pclose (finp))
+                        {
+                            edit_error_dialog (_("Error"), get_sys_error (_("File filter error")));
+                            break;
+                        }
+                    }
+                }
+                else
+                {
+                    blocklen = mc_read (fdinp, file_buff, TEMP_BUF_LEN);
+                    if (blocklen <= 0)
+                    {
+                        insert_from_file = 2;
+                        mc_close (fdinp);
+                    }
+                }
+                if (insert_from_file == 2)
+                {
+                    close (fdout);
+                    g_free (file_buff);
+#ifdef HAVE_CHARSET
+                    recode = 0;
+#endif
+                    len = 0; /* avoid recoding and string processing */
+                    if (mark && edit_block_delete_cmd (edit))
+                    {
+                        edit_error_dialog (_("Error"), _("Cannot delete marked block"));
+                        mc_unlink (temp_vpath);
+                        vfs_path_free (temp_vpath);
+                        break;
+                    }
+                    if (!edit_insert_file (edit, temp_vpath))
+                    {
+                        edit_error_dialog (_("Error"), get_sys_error (mark ? 
+                                           _("Cannot replace marked block") : _("Cannot insert file")));
+                        mc_unlink (temp_vpath);
+                        vfs_path_free (temp_vpath);
+                        break;
+                    }
+                    mc_unlink (temp_vpath);
+                    vfs_path_free (temp_vpath);
+                }
+                else if (blocklen > 0)
+                {
+                    len = blocklen;
+                }
+            }
+        }
+
+        if (ret == B_USER)
+        {
+#ifdef HAVE_CHARSET
+            int r;
+            r = select_charset (-1, -1, cp_id, FALSE);
+            if (r != SELECT_CHARSET_CANCEL)
+            {
+                cp_id = r == -1 ? cp_to : r;
+                recode = (cp_id != cp_to);
+                g_string_printf (str_recode, str_recode_tpl,
+                     recode ? get_codepage_id (cp_id) : "",
+                     recode ? " to " : "-",
+                     recode ? get_codepage_id (cp_to) : "");
+                quick_widgets[RECODE_LABEL].u.label.text = str_recode->str;
+            }
+#endif /* HAVE_CHARSET */
+        }
+        else if (ret == B_ENTER)
+        {
+            GString *out = g_string_new("");
+            gsize curr_index;
+            int accept_u_and_conv = accept_u;
+
+#ifdef HAVE_CHARSET
+            /* converter for unicode escapes and HTML */
+            if (accept_u || esc_style == ESC_NUMP || esc_style == ESC_HTML)
+            {
+                if (lcp_id != cp_id)
+                {
+                    if (cnvu != INVALID_CONV)
+                        g_iconv_close (cnvu);
+                    cnvu = g_iconv_open (get_codepage_id (cp_id), "UTF-16");
+                    lcp_id = cp_id;
+                }
+
+                if (accept_u_and_conv && cnvu == INVALID_CONV)
+                {
+                    char *tmp;
+                    tmp = g_strdup_printf (_("Cannot initialise conversion from:\n"
+                                                 "UTF-16 to %s\nUTF-16 cannot accepted."),
+                                               get_codepage_id (cp_to));
+                    edit_error_dialog (_("Warning"), tmp);
+                    g_free (tmp);
+                    accept_u_and_conv = 0;
+                }
+            }
+#endif
+            if (insert_from_file == 0)
+                len = strlen (string);
+
+            for (curr_index = 0; curr_index < len; curr_index++)
+            {
+                switch (esc_style)
+                {
+                case ESC_C:
+                    if (string[curr_index] != '\\')
+                    {
+                        out = g_string_append_c (out, string[curr_index]);
+                        continue;
+                    }
+                    curr_index++;
+                    if (curr_index == len)
+                        continue;
+                    switch (string[curr_index])
+                    {
+                    case '\\':
+                        out = g_string_append_c (out, '\\');
+                        continue;
+                    case 'a':
+                        out = g_string_append_c (out, '\a');
+                        continue;
+                    case 'b':
+                        out = g_string_append_c (out, '\b');
+                        continue;
+                    case 't':
+                        out = g_string_append_c (out, '\t');
+                        continue;
+                    case 'n':
+                        out = g_string_append_c (out, '\n');
+                        continue;
+                    case 'v':
+                        out = g_string_append_c (out, '\v');
+                        continue;
+                    case 'f':
+                        out = g_string_append_c (out, '\f');
+                        continue;
+                    case 'r':
+                        out = g_string_append_c (out, '\r');
+                        continue;
+                    case 'e':
+                        out = g_string_append_c (out, '\027');
+                        continue;
+                    case 'x':
+                        {
+                            int i, c = -1;
+                            for (i = 1; i <= 2; i++)
+                            {
+                                int x;
+                                if (curr_index + 1 >= len)
+                                {
+                                    if (c < 0)
+                                        out = g_string_append_c (out, 'x');
+                                    continue;
+                                }
+                                x = string[++curr_index];
+                                if (x >= 'a' && x <= 'f')
+                                    x -= 'a' - 10;
+                                else if (x >= 'A' && x <= 'F')
+                                    x -= 'A' - 10;
+                                else if (x >= '0' && x <= '9')
+                                    x -= '0';
+                                else
+                                {
+                                    if (c >= 0)
+                                        out = g_string_append_c (out, c);
+                                    else
+                                        out = g_string_append_c (out, 'x');
+                                    c = -1;
+                                    curr_index--;
+                                    break;
+                                }
+                                c = c == -1 ? 0 : c << 4;
+                                c |= x & 0x0f;
+                            }
+                            if (c >= 0)
+                                out = g_string_append_c (out, c);
+                        }
+                        continue;
+                    case '0':
+                    case '1':
+                    case '2':
+                    case '3':
+                    case '4':
+                    case '5':
+                    case '6':
+                    case '7':
+                        {
+                            int i, c = -1;
+
+                            curr_index = curr_index - 1;
+                            for (i = 1; i <= 3; i++)
+                            {
+                                int o;
+                                if (curr_index + 1 >= len)
+                                    break;
+                                o = string[++curr_index];
+                                if (o >= '0' && o <= '7')
+                                    o -= '0';
+                                else
+                                {
+                                    out = g_string_append_c (out, c&0xff);
+                                    out = g_string_append_c (out, o);
+                                    c = -1;
+                                    break;
+                                }
+                                c = c == -1 ? 0 : c << 3;
+                                c |= o & 0x0f;
+                            }
+                            if (c > 0xff && show_warn)
+                            {
+                                char *tmp;
+
+                                tmp = g_strdup_printf (_("Octal value out "
+                                      "of range (000-377) at %u: %03o\n"
+                                      "Value converted to: %03o"),
+                                      curr_index, c, c&0xff);
+                                if (query_dialog (_("Warning"), tmp, D_ERROR, 2, _("&Dismiss"), _("Dismiss &All")) == 1)
+                                    show_warn = 0;
+
+                                g_free (tmp);
+                            }
+                            if (c >= 0)
+                                out = g_string_append_c (out, c&0xff);
+                            continue;
+                        }
+                    case 'u':
+                        if (accept_u_and_conv)
+                        {
+                            gint32 u = -1;
+                            int i;
+                            for (i = 1; i <= 4; i++)
+                            {
+                                int x;
+                                if (curr_index + 1 >= len)
+                                {
+                                    if (u < 0)
+                                        out = g_string_append_c (out, 'u');
+                                    break;
+                                }
+                                x = string[++curr_index];
+                                if (x >= 'a' && x <= 'f')
+                                    x -= 'a' - 10;
+                                else if (x >= 'A' && x <= 'F')
+                                    x -= 'A' - 10;
+                                else if (x >= '0' && x <= '9')
+                                    x -= '0';
+                                else
+                                {
+                                    if (u < 0)
+                                    {
+                                        out = g_string_append_c (out, 'x');
+                                    }
+                                    curr_index--;
+                                    break;
+                                }
+                                u = u == -1 ? 0 : u << 4;
+                                u |= x & 0x0f;
+                            }
+                            if (u >= 0)
+                                edit_utf16recode (cnvu, u, &out, &show_warn, curr_index);
+                        }
+                        continue;
+                    default:
+                        out = g_string_append_c (out, string[curr_index]);
+                        continue;
+                    }
+                    break;
+                case ESC_HTML:
+                    if (string[curr_index] != '&' || cnvu == INVALID_CONV)
+                    {
+                        out = g_string_append_c (out, string[curr_index]);
+                        continue;
+                    }
+                    curr_index++;
+                    if (curr_index == len)
+                    {
+                        out = g_string_append_c (out, '&');
+                        continue;
+                    }
+                    else if (string[curr_index] != '#')
+                    {
+                        gsize i;
+                        int hlen;
+
+                        for (i = curr_index; i < len; i++)
+                            if (string[i] == ';')
+                                break;
+                        if (string[i] != ';')
+                        {
+                            out = g_string_append_c (out, '&');
+                            curr_index--;
+                            continue;
+                        }
+                        hlen = i - curr_index;
+                        for (i = 0; html_enc_table[i].name != NULL; i++)
+                        {
+                            if (strncmp (html_enc_table[i].name,
+                                         &string[curr_index], hlen) == 0)
+                                break;
+                        }
+                        if (html_enc_table[i].name == NULL)
+                        {
+                            out = g_string_append_c (out, '&');
+                            curr_index--;
+                            continue;
+                        }
+                        edit_utf16recode (cnvu, html_enc_table[i].u, &out, &show_warn, curr_index);
+                        curr_index += hlen;
+                        continue;
+                    }
+                    else if (curr_index + 1 < len && 
+                             string[curr_index + 1] >= '0' && string[curr_index + 1] <= '9')
+                    {
+                        gint32 u = -1;
+                        int i, x = 0;
+
+                        for (i = 1; i <= 6; i++)
+                        {
+                            if (curr_index + 1 >= len)
+                            {
+                                out = g_string_append (out, "&#");
+                                u = -1;
+                                curr_index -= i;
+                                break;
+                            }
+                            x = string[++curr_index];
+                            if (x >= '0' && x <= '9')
+                                x -= '0';
+                            else
+                                break;
+                            u = u == -1 ? 0 : u * 10;
+                            u += x;
+                        }
+                        if (x != ';')
+                        {
+                            out = g_string_append (out, "&#");
+                            u = -1;
+                            curr_index -= i;
+                            continue;
+                        }
+                        if (u >= 0)
+                            edit_utf16recode (cnvu, u, &out, &show_warn, curr_index);
+                    }
+                    else if (curr_index + 2 < len && string[curr_index + 1] == 'x')
+                    {
+                        gint32 u = -1;
+                        int i, x = 0;
+                        curr_index++;
+                        for (i = 1; i <= 5; i++)
+                        {
+                            if (curr_index + 1 >= len)
+                            {
+                                out = g_string_append (out, "&#");
+                                u = -1;
+                                curr_index -= i;
+                                break;
+                            }
+                            x = string[++curr_index];
+                            if (x >= 'a' && x <= 'f')
+                                x -= 'a' - 10;
+                            else if (x >= 'A' && x <= 'F')
+                                x -= 'A' - 10;
+                            else if (x >= '0' && x <= '9')
+                                x -= '0';
+                            else
+                                break;
+                            u = u == -1 ? 0 : u << 4;
+                            u += x;
+                        }
+                        if (x != ';')
+                        {
+                            out = g_string_append (out, "&#");
+                            u = -1;
+                            curr_index -= i;
+                            continue;
+                        }
+                        if (u >= 0)
+                            edit_utf16recode (cnvu, u, &out, &show_warn, curr_index);
+                    }
+                    else
+                    {
+                        out = g_string_append (out, "&#");
+                        continue;
+                    }
+                    break;
+                case ESC_URL:
+                    if (string[curr_index] != '%')
+                    {
+                        out = g_string_append_c (out, string[curr_index]);
+                        continue;
+                    }
+                    curr_index++;
+                    if (curr_index == len)
+                    {
+                        out = g_string_append_c (out, '%');
+                        continue;
+                    }
+                    else if (accept_u_and_conv && string[curr_index] == 'u')
+                    {
+                        gint32 u = -1;
+                        int i;
+                        for (i = 1; i <= 4; i++)
+                        {
+                            int x;
+                            if (curr_index + 1 >= len)
+                            {
+                                if (u < 0)
+                                    out = g_string_append_c (out, 'u');
+                                break;
+                            }
+                            x = string[++curr_index];
+                            if (x >= 'a' && x <= 'f')
+                                x -= 'a' - 10;
+                            else if (x >= 'A' && x <= 'F')
+                                x -= 'A' - 10;
+                            else if (x >= '0' && x <= '9')
+                                x -= '0';
+                            else
+                            {
+                                if (u < 0)
+                                {
+                                    out = g_string_append_c (out, 'u');
+                                }
+                                curr_index--;
+                                break;
+                            }
+                            u = u == -1 ? 0 : u << 4;
+                            u |= x & 0x0f;
+                        }
+                        if (u >= 0)
+                            edit_utf16recode (cnvu, u, &out, &show_warn, curr_index);
+                        continue;
+                    }
+                    else
+                    {
+                        int i, c = -1;
+                        curr_index--;
+                        for (i = 0; i < 2; i++)
+                        {
+                            int x;
+                            if (curr_index + 1 >= len)
+                            {
+                                if (c < 0)
+                                    out = g_string_append_c (out, '%');
+                                break;
+                            }
+                            x = string[++curr_index];
+                            if (x >= 'a' && x <= 'f')
+                                x -= 'a' - 10;
+                            else if (x >= 'A' && x <= 'F')
+                                x -= 'A' - 10;
+                            else if (x >= '0' && x <= '9')
+                                x -= '0';
+                            else
+                            {
+                                if (c >= 0)
+                                    out = g_string_append_c (out, c);
+                                else
+                                    out = g_string_append_c (out, '%');
+                                c = -1;
+                                curr_index--;
+                                break;
+                            }
+                            c = c == -1 ? 0 : c << 4;
+                            c |= x & 0x0f;
+                        }
+                        if (c >= 0)
+                            out = g_string_append_c (out, c);
+                        continue;
+                    }
+                    break;
+                case ESC_HEX:
+                    if (string[curr_index] < '0' ||
+                           string[curr_index] > '9' && string[curr_index] < 'A' ||
+                           string[curr_index] > 'F' && string[curr_index] < 'a' ||
+                           string[curr_index] > 'f')
+                    {
+                        if (accept_i)
+                            out = g_string_append_c (out, string[curr_index]);
+                        continue;
+                    }
+                    else
+                    {
+                        int i, c = -1;
+                        curr_index--;
+                        for (i=0; i<2; i++)
+                        {
+                            int x;
+                            if (curr_index + 1 == len)
+                            {
+                               break;
+                            }
+                            x = string[++curr_index];
+                            if (x >= 'a' && x <= 'f')
+                                x -= 'a' - 10;
+                            else if (x >= 'A' && x <= 'F')
+                                x -= 'A' - 10;
+                            else if (x >= '0' && x <= '9')
+                                x -= '0';
+                            else
+                            {
+                                if (c >= 0)
+                                    out = g_string_append_c (out, c);
+                                out = g_string_append_c (out, x);
+                                c = -1;
+                                break;
+                            }
+                            c = c == -1 ? 0 : c << 4;
+                            c |= x & 0x0f;
+                        }
+                        if (c >= 0)
+                            out = g_string_append_c (out, c);
+                        continue;
+                    }
+                case ESC_NUMP:
+                    if (string[curr_index] != '^')
+                    {
+                        out = g_string_append_c (out, string[curr_index]);
+                        continue;
+                    }
+                    curr_index++;
+                    if (curr_index == len)
+                    {
+                        out = g_string_append_c (out, '^');
+                        continue;
+                    }
+                    else if (accept_u_and_conv && string[curr_index] == '+')
+                    {
+                        gint32 u = -1;
+                        int i;
+                        for (i = 1; i <= 4; i++)
+                        {
+                            int x;
+                            if (curr_index + 1 >= len)
+                            {
+                                if (u < 0)
+                                    out = g_string_append_c (out, '+');
+                                break;
+                            }
+                            x = string[++curr_index];
+                            if (x >= 'a' && x <= 'f')
+                                x -= 'a' - 10;
+                            else if (x >= 'A' && x <= 'F')
+                                x -= 'A' - 10;
+                            else if (x >= '0' && x <= '9')
+                                x -= '0';
+                            else
+                            {
+                                if (u < 0)
+                                {
+                                    out = g_string_append_c (out, '+');
+                                }
+                                curr_index--;
+                                break;
+                            }
+                            u = u == -1 ? 0 : u << 4;
+                            u |= x & 0x0f;
+                        }
+                        if (u >= 0)
+                            edit_utf16recode (cnvu, u, &out, &show_warn, curr_index);
+                        continue;
+                    }
+                    else
+                    {
+                        int i, c = -1;
+                        curr_index--;
+                        for (i = 0; i < 3; i++)
+                        {
+                            int x;
+                            if (curr_index + 1 >= len)
+                            {
+                                if (c < 0)
+                                    out = g_string_append_c (out, '^');
+                                break;
+                            }
+                            x = string[++curr_index];
+                            if (x >= '0' && x <= '9')
+                                x -= '0';
+                            else
+                            {
+                                if (c >= 0)
+                                    out = g_string_append_c (out, c);
+                                else
+                                    out = g_string_append_c (out, '^');
+                                c = -1;
+                                curr_index--;
+                                break;
+                            }
+                            c = c == -1 ? 0 : c * 10;
+                            c += x;
+                        }
+                        if (c > 0xff && show_warn)
+                        {
+                            char *tmp;
+
+                            tmp = g_strdup_printf (_("Decimal value out "
+                                  "of range (0-255) at %u: %3d\n"
+                                  "Value converted to: %3d"),
+                                  curr_index, c, c&0xff);
+                            if (query_dialog (_("Warning"), tmp, D_ERROR, 2, _("&Dismiss"), _("Dismiss &All")) == 1)
+                                show_warn = 0;
+                            g_free (tmp);
+                        }
+                        if (c >= 0)
+                            out = g_string_append_c (out, c&0xff);
+                        continue;
+                    }
+                    break;
+                }
+            }
+#ifdef HAVE_CHARSET
+            if (recode)
+            {
+                GIConv cnv;
+
+                cnv = g_iconv_open (get_codepage_id (cp_to),
+                                    get_codepage_id (cp_id));
+
+                if (cnv != INVALID_CONV)
+                {
+                    GError *err = NULL;
+                    gchar *ostr;
+
+                    ostr = g_convert_with_iconv (out->str, out->len, cnv, NULL, NULL, &err);
+                    if (show_warn && (err != NULL || out == NULL))
+                    {
+                        char *tmp;
+                        tmp = g_strdup_printf (_("Error(s) when reencoding string at %u:\n%s"), out->len,
+                                               err == NULL ? "No result from conversion!" : err->message);
+                        edit_error_dialog (_("Warning"), tmp);
+                        g_free (tmp);
+                    }
+                    if (ostr != NULL)
+                    {
+                        g_string_truncate (out, 0);
+                        g_string_append (out, ostr);
+                        g_free (ostr);
+                    }
+                    g_iconv_close (cnv);
+                }
+                else
+                {
+                        char *tmp;
+                        tmp = g_strdup_printf (_("Cannot initialise conversion from: %s to %s"),
+                                               get_codepage_id (cp_to),
+                                               get_codepage_id (cp_id));
+                        edit_error_dialog (_("Warning"), tmp);
+                        g_free (tmp);
+                }
+            }
+#endif /* HAVE_CHARSET */
+            if (insert_from_file)
+            {
+                if (insert_from_file != 2)
+                {
+
+                    if (write (fdout, out->str, out->len) != (ssize_t)out->len)
+                    {
+                        edit_error_dialog (_("Error"), get_sys_error (_("Cannot write temporary file")));
+                        break;
+                    }
+                    goto continue_file;
+                }
+            }
+            else
+            {
+                for (len = 0; len < out->len; len++)
+                    edit_insert (edit, out->str[len]);
+                g_string_free (out, TRUE);
+            }
+#ifdef HAVE_CHARSET
+            if (cnvu != INVALID_CONV)
+                g_iconv_close (cnvu);
+#endif /* HAVE_CHARSET */
+            if (insert_from_file == 0)
+                g_free (string);
+            break;
+        }
+        if (insert_from_file == 0)
+            g_free (string);
+    }
+#ifdef HAVE_CHARSET
+    g_string_free (str_recode, TRUE);
+#endif /* HAVE_CHARSET */
+}
diff --git a/src/editor/editmenu.c b/src/editor/editmenu.c
index a55636d..249d888 100644
--- a/src/editor/editmenu.c
+++ b/src/editor/editmenu.c
@@ -204,6 +204,8 @@ create_format_menu (void)
 
     entries =
         g_list_prepend (entries, menu_entry_create (_("Insert &literal..."), CK_InsertLiteral));
+    entries =
+        g_list_prepend (entries, menu_entry_create (_("Insert esc&aped string..."), CK_InsertEstring));
     entries = g_list_prepend (entries, menu_entry_create (_("Insert &date/time"), CK_Date));
     entries = g_list_prepend (entries, menu_separator_create ());
     entries =
diff --git a/src/editor/html_enc_table.h b/src/editor/html_enc_table.h
new file mode 100644
index 0000000..446c032
--- /dev/null
+++ b/src/editor/html_enc_table.h
@@ -0,0 +1,258 @@
+static html_enc_t html_enc_table[] =
+{
+    {"quot", 0x0022},
+    {"amp", 0x0026},
+    {"apos", 0x0027},
+    {"lt", 0x003C},
+    {"gt", 0x003E},
+    {"nbsp", 0x00A0},
+    {"iexcl", 0x00A1},
+    {"cent", 0x00A2},
+    {"pound", 0x00A3},
+    {"curren", 0x00A4},
+    {"yen", 0x00A5},
+    {"brvbar", 0x00A6},
+    {"sect", 0x00A7},
+    {"uml", 0x00A8},
+    {"copy", 0x00A9},
+    {"ordf", 0x00AA},
+    {"laquo", 0x00AB},
+    {"not", 0x00AC},
+    {"shy", 0x00AD},
+    {"reg", 0x00AE},
+    {"macr", 0x00AF},
+    {"deg", 0x00B0},
+    {"plusmn", 0x00B1},
+    {"sup2", 0x00B2},
+    {"sup3", 0x00B3},
+    {"acute", 0x00B4},
+    {"micro", 0x00B5},
+    {"para", 0x00B6},
+    {"middot", 0x00B7},
+    {"cedil", 0x00B8},
+    {"sup1", 0x00B9},
+    {"ordm", 0x00BA},
+    {"raquo", 0x00BB},
+    {"frac14", 0x00BC},
+    {"frac12", 0x00BD},
+    {"frac34", 0x00BE},
+    {"iquest", 0x00BF},
+    {"Agrave", 0x00C0},
+    {"Aacute", 0x00C1},
+    {"Acirc", 0x00C2},
+    {"Atilde", 0x00C3},
+    {"Auml", 0x00C4},
+    {"Aring", 0x00C5},
+    {"AElig", 0x00C6},
+    {"Ccedil", 0x00C7},
+    {"Egrave", 0x00C8},
+    {"Eacute", 0x00C9},
+    {"Ecirc", 0x00CA},
+    {"Euml", 0x00CB},
+    {"Igrave", 0x00CC},
+    {"Iacute", 0x00CD},
+    {"Icirc", 0x00CE},
+    {"Iuml", 0x00CF},
+    {"ETH", 0x00D0},
+    {"Ntilde", 0x00D1},
+    {"Ograve", 0x00D2},
+    {"Oacute", 0x00D3},
+    {"Ocirc", 0x00D4},
+    {"Otilde", 0x00D5},
+    {"Ouml", 0x00D6},
+    {"times", 0x00D7},
+    {"Oslash", 0x00D8},
+    {"Ugrave", 0x00D9},
+    {"Uacute", 0x00DA},
+    {"Ucirc", 0x00DB},
+    {"Uuml", 0x00DC},
+    {"Yacute", 0x00DD},
+    {"THORN", 0x00DE},
+    {"szlig", 0x00DF},
+    {"agrave", 0x00E0},
+    {"aacute", 0x00E1},
+    {"acirc", 0x00E2},
+    {"atilde", 0x00E3},
+    {"auml", 0x00E4},
+    {"aring", 0x00E5},
+    {"aelig", 0x00E6},
+    {"ccedil", 0x00E7},
+    {"egrave", 0x00E8},
+    {"eacute", 0x00E9},
+    {"ecirc", 0x00EA},
+    {"euml", 0x00EB},
+    {"igrave", 0x00EC},
+    {"iacute", 0x00ED},
+    {"icirc", 0x00EE},
+    {"iuml", 0x00EF},
+    {"eth", 0x00F0},
+    {"ntilde", 0x00F1},
+    {"ograve", 0x00F2},
+    {"oacute", 0x00F3},
+    {"ocirc", 0x00F4},
+    {"otilde", 0x00F5},
+    {"ouml", 0x00F6},
+    {"divide", 0x00F7},
+    {"oslash", 0x00F8},
+    {"ugrave", 0x00F9},
+    {"uacute", 0x00FA},
+    {"ucirc", 0x00FB},
+    {"uuml", 0x00FC},
+    {"yacute", 0x00FD},
+    {"thorn", 0x00FE},
+    {"yuml", 0x00FF},
+    {"OElig", 0x0152},
+    {"oelig", 0x0153},
+    {"Scaron", 0x0160},
+    {"scaron", 0x0161},
+    {"Yuml", 0x0178},
+    {"fnof", 0x0192},
+    {"circ", 0x02C6},
+    {"tilde", 0x02DC},
+    {"Alpha", 0x0391},
+    {"Beta", 0x0392},
+    {"Gamma", 0x0393},
+    {"Delta", 0x0394},
+    {"Epsilon", 0x0395},
+    {"Zeta", 0x0396},
+    {"Eta", 0x0397},
+    {"Theta", 0x0398},
+    {"Iota", 0x0399},
+    {"Kappa", 0x039A},
+    {"Lambda", 0x039B},
+    {"Mu", 0x039C},
+    {"Nu", 0x039D},
+    {"Xi", 0x039E},
+    {"Omicron", 0x039F},
+    {"Pi", 0x03A0},
+    {"Rho", 0x03A1},
+    {"Sigma", 0x03A3},
+    {"Tau", 0x03A4},
+    {"Upsilon", 0x03A5},
+    {"Phi", 0x03A6},
+    {"Chi", 0x03A7},
+    {"Psi", 0x03A8},
+    {"Omega", 0x03A9},
+    {"alpha", 0x03B1},
+    {"beta", 0x03B2},
+    {"gamma", 0x03B3},
+    {"delta", 0x03B4},
+    {"epsilon", 0x03B5},
+    {"zeta", 0x03B6},
+    {"eta", 0x03B7},
+    {"theta", 0x03B8},
+    {"iota", 0x03B9},
+    {"kappa", 0x03BA},
+    {"lambda", 0x03BB},
+    {"mu", 0x03BC},
+    {"nu", 0x03BD},
+    {"xi", 0x03BE},
+    {"omicron", 0x03BF},
+    {"pi", 0x03C0},
+    {"rho", 0x03C1},
+    {"sigmaf", 0x03C2},
+    {"sigma", 0x03C3},
+    {"tau", 0x03C4},
+    {"upsilon", 0x03C5},
+    {"phi", 0x03C6},
+    {"chi", 0x03C7},
+    {"psi", 0x03C8},
+    {"omega", 0x03C9},
+    {"thetasym", 0x03D1},
+    {"upsih", 0x03D2},
+    {"piv", 0x03D6},
+    {"ensp", 0x2002},
+    {"emsp", 0x2003},
+    {"thinsp", 0x2009},
+    {"zwnj", 0x200C},
+    {"zwj", 0x200D},
+    {"lrm", 0x200E},
+    {"rlm", 0x200F},
+    {"ndash", 0x2013},
+    {"mdash", 0x2014},
+    {"lsquo", 0x2018},
+    {"rsquo", 0x2019},
+    {"sbquo", 0x201A},
+    {"ldquo", 0x201C},
+    {"rdquo", 0x201D},
+    {"bdquo", 0x201E},
+    {"dagger", 0x2020},
+    {"Dagger", 0x2021},
+    {"bull", 0x2022},
+    {"hellip", 0x2026},
+    {"permil", 0x2030},
+    {"prime", 0x2032},
+    {"Prime", 0x2033},
+    {"lsaquo", 0x2039},
+    {"rsaquo", 0x203A},
+    {"oline", 0x203E},
+    {"frasl", 0x2044},
+    {"euro", 0x20AC},
+    {"image", 0x2111},
+    {"weierp", 0x2118},
+    {"real", 0x211C},
+    {"trade", 0x2122},
+    {"alefsym", 0x2135},
+    {"larr", 0x2190},
+    {"uarr", 0x2191},
+    {"rarr", 0x2192},
+    {"darr", 0x2193},
+    {"harr", 0x2194},
+    {"crarr", 0x21B5},
+    {"lArr", 0x21D0},
+    {"uArr", 0x21D1},
+    {"rArr", 0x21D2},
+    {"dArr", 0x21D3},
+    {"hArr", 0x21D4},
+    {"forall", 0x2200},
+    {"part", 0x2202},
+    {"exist", 0x2203},
+    {"empty", 0x2205},
+    {"nabla", 0x2207},
+    {"isin", 0x2208},
+    {"notin", 0x2209},
+    {"ni", 0x220B},
+    {"prod", 0x220F},
+    {"sum", 0x2211},
+    {"minus", 0x2212},
+    {"lowast", 0x2217},
+    {"radic", 0x221A},
+    {"prop", 0x221D},
+    {"infin", 0x221E},
+    {"ang", 0x2220},
+    {"and", 0x2227},
+    {"or", 0x2228},
+    {"cap", 0x2229},
+    {"cup", 0x222A},
+    {"int", 0x222B},
+    {"there4", 0x2234},
+    {"sim", 0x223C},
+    {"cong", 0x2245},
+    {"asymp", 0x2248},
+    {"ne", 0x2260},
+    {"equiv", 0x2261},
+    {"le", 0x2264},
+    {"ge", 0x2265},
+    {"sub", 0x2282},
+    {"sup", 0x2283},
+    {"nsub", 0x2284},
+    {"sube", 0x2286},
+    {"supe", 0x2287},
+    {"oplus", 0x2295},
+    {"otimes", 0x2297},
+    {"perp", 0x22A5},
+    {"sdot", 0x22C5},
+    {"vellip", 0x22EE},
+    {"lceil", 0x2308},
+    {"rceil", 0x2309},
+    {"lfloor", 0x230A},
+    {"rfloor", 0x230B},
+    {"lang", 0x2329},
+    {"rang", 0x232A},
+    {"loz", 0x25CA},
+    {"spades", 0x2660},
+    {"clubs", 0x2663},
+    {"hearts", 0x2665},
+    {"diams", 0x2666},
+    {NULL, 0}
+};
diff --git a/src/keybind-defaults.c b/src/keybind-defaults.c
index 11d636e..069c5ef 100644
--- a/src/keybind-defaults.c
+++ b/src/keybind-defaults.c
@@ -397,6 +397,7 @@ static const global_keymap_ini_t default_editor_keymap[] = {
     {"MarkColumnPageUp", "alt-pgup"},
     {"MarkColumnPageDown", "alt-pgdn"},
     {"InsertLiteral", "ctrl-q"},
+    {"InsertEstring", "ctrl-w"},
     {"Complete", "alt-tab"},
     {"MatchBracket", "alt-b"},
     {"ParagraphFormat", "alt-p"},
