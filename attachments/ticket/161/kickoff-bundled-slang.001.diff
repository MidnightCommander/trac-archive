diff --git a/.gitignore b/.gitignore
index 7610001..c5267ef 100644
--- a/.gitignore
+++ b/.gitignore
@@ -36,3 +36,4 @@ tmpout
 debug
 Doxyfile
 mc.kdevelop
+confdefs.h
diff --git a/ChangeLog b/ChangeLog
index 291791f..ba97702 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,7 @@
+2009-01-07  Enrico Weigelt, metux ITS <weigelt@metux.de>
+
+	* removed bundled slang
+
 2008-12-18  Roland Illig  <roland.illig@gmx.de>
 
 	* doc/mcedit.1: Documented the newly added filename:lineno
diff --git a/INSTALL b/INSTALL
index 7081b98..1ff7f50 100644
--- a/INSTALL
+++ b/INSTALL
@@ -169,19 +169,11 @@ included one, but you can override this by using the following flag
 (please note that since S-Lang is default, it is tested better than
 ncurses):
 
-`--with-screen={slang|mcslang|ncurses}'
+`--with-screen={slang|ncurses}'
      Choose the library used to manage interaction with the terminal.
      `slang' means S-Lang library already installed on the system,
-     `mcslang' means S-Lang library included with the sources of
-     GNU Midnight Commander, `ncurses' means ncurses library already
-     installed on the system.  The installed S-Lang library is used
-     by default if found, otherwise the included S-Lang library is
-     used.
-
-`--with-termcap'
-     If the included S-Lang library is used, this option forces it to
-     use the termcap database, as opposed to the default terminfo
-     database.
+     `ncurses' means ncurses library already installed on the system.  
+     The installed S-Lang library is used by default if found.
 
 On systems that require unusual options for compilation or linking that
 the package's `configure' script does not know about, you can give
diff --git a/INSTALL.FAST b/INSTALL.FAST
index 7f547b6..e448863 100644
--- a/INSTALL.FAST
+++ b/INSTALL.FAST
@@ -24,14 +24,11 @@ The most often needed options to configure are following:
 	You can specify an installation prefix other than default by
 	giving `configure' the option `--prefix=PATH'.
 
-`--with-screen={slang|mcslang|ncurses}'
+`--with-screen={slang|ncurses}'
 	Choose the library used to manage interaction with the terminal.
 	`slang' means S-Lang library already installed on the system,
-	`mcslang' means S-Lang library included with the sources of
-	GNU Midnight Commander, `ncurses' means ncurses library already
-	installed on the system.  The installed S-Lang library is used
-	by default if found, otherwise the included S-Lang library is
-	used.
+	`ncurses' means ncurses library already installed on the system.  
+	The installed S-Lang library is used by default if found.
 
 You may also want to specify CFLAGS for the compiler, even if it finds
 itself some defaults by typing e.g.
diff --git a/Makefile.am b/Makefile.am
index f7adf26..26ef966 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2,7 +2,7 @@
 
 AUTOMAKE_OPTIONS = 1.5
 
-SUBDIRS = intl po m4 vfs slang edit src lib doc syntax
+SUBDIRS = intl po m4 vfs edit src lib doc syntax
 
 EXTRA_DIST = FAQ HACKING INSTALL.FAST MAINTAINERS README.QNX TODO pkginfo.in prototype.in mc.qpg mc.spec
 
diff --git a/acinclude.m4 b/acinclude.m4
index f4c0e3b..06b689a 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -362,7 +362,7 @@ AC_DEFUN([MC_SLANG_TERMCAP], [
 ])
 
 dnl
-dnl Common code for MC_WITH_SLANG and MC_WITH_MCSLANG
+dnl Common code for MC_WITH_SLANG
 dnl
 AC_DEFUN([_MC_WITH_XSLANG], [
     screen_type=slang
@@ -373,7 +373,7 @@ AC_DEFUN([_MC_WITH_XSLANG], [
 
 dnl
 dnl Check if the system S-Lang library can be used.
-dnl If not, and $1 is "strict", exit, otherwise fall back to mcslang.
+dnl If not, and $1 is "strict", exit.
 dnl
 AC_DEFUN([MC_WITH_SLANG], [
     with_screen=slang
@@ -383,7 +383,7 @@ AC_DEFUN([MC_WITH_SLANG], [
     AC_CHECK_HEADERS([slang.h slang/slang.h],
 		     [slang_h_found=yes; break])
     if test -z "$slang_h_found"; then
-	with_screen=mcslang
+	AC_MSG_ERROR([Slang header not found])
     fi
 
     dnl Check if termcap is needed.
@@ -395,78 +395,23 @@ AC_DEFUN([MC_WITH_SLANG], [
     dnl Check the library
     if test x$with_screen = xslang; then
 	AC_CHECK_LIB([slang], [SLang_init_tty], [MCLIBS="$MCLIBS -lslang"],
-		     [with_screen=mcslang], ["$MCLIBS"])
+		     AC_MSG_ERROR([Slang library not found]), ["$MCLIBS"])
     fi
 
     dnl Unless external S-Lang was requested, reject S-Lang with UTF-8 hacks
     if test x$with_screen = xslang; then
-	:
-	m4_if([$1], strict, ,
-	      [AC_CHECK_LIB([slang], [SLsmg_write_nwchars],
-	    		    [AC_MSG_WARN([Rejecting S-Lang with UTF-8 support, \
-it's not fully supported yet])
-	      with_screen=mcslang])])
+	AC_CHECK_LIB(
+	    [slang],
+	    [SLsmg_write_nwchars],
+	    [AC_MSG_ERROR([Rejecting S-Lang with UTF-8 support, it's not fully supported yet])])
     fi
 
     if test x$with_screen = xslang; then
-	AC_DEFINE(HAVE_SYSTEM_SLANG, 1,
-		  [Define to use S-Lang library installed on the system])
 	MC_SLANG_PRIVATE
 	screen_type=slang
 	screen_msg="S-Lang library (installed on the system)"
     else
-	m4_if([$1], strict,
-	    [if test $with_screen != slang; then
-		AC_MSG_ERROR([S-Lang library not found])
-	    fi],
-	    [MC_WITH_MCSLANG]
-	)
-    fi
-
-    _MC_WITH_XSLANG
-])
-
-
-dnl
-dnl Use the included S-Lang library.
-dnl
-AC_DEFUN([MC_WITH_MCSLANG], [
-    screen_type=mcslang
-    screen_msg="Included S-Lang library (mcslang)"
-
-    dnl Type checks from S-Lang sources
-    AC_CHECK_SIZEOF(short, 2)
-    AC_CHECK_SIZEOF(int, 4)
-    AC_CHECK_SIZEOF(long, 4)
-    AC_CHECK_SIZEOF(float, 4)
-    AC_CHECK_SIZEOF(double, 8)
-    AC_TYPE_OFF_T
-    AC_CHECK_SIZEOF(off_t)
-    AC_CHECK_TYPES(long long)
-    AC_CHECK_SIZEOF(long long)
-    AC_CHECK_FUNCS(atexit on_exit)
-
-    # Search for terminfo database.
-    use_terminfo=
-    if test x"$with_termcap" != xyes; then
-	if test x"$with_termcap" = xno; then
-	    use_terminfo=yes
-	fi
-	if test -n "$TERMINFO" && test -r "$TERMINFO/v/vt100"; then
-	    use_terminfo=yes
-	fi
-	for dir in "/usr/share/terminfo" "/usr/lib/terminfo" \
-		   "/usr/share/lib/terminfo" "/etc/terminfo" \
-		   "/usr/local/lib/terminfo" "$HOME/.terminfo"; do
-	    if test -r "$dir/v/vt100"; then
-		use_terminfo=yes
-	    fi
-	done
-    fi
-
-    # If there is no terminfo, use termcap
-    if test -z "$use_terminfo"; then
-	MC_USE_TERMCAP
+	AC_MSG_ERROR([S-Lang library not found])
     fi
 
     _MC_WITH_XSLANG
diff --git a/configure.ac b/configure.ac
index cfaaa7d..adbfccd 100644
--- a/configure.ac
+++ b/configure.ac
@@ -184,12 +184,6 @@ AC_CHECK_FUNCS([\
 	tcgetattr tcsetattr truncate \
 ])
 
-dnl S-Lang needs all four functions to be defined to use POSIX signal API
-AC_CHECK_FUNCS([sigaction sigemptyset sigprocmask sigaddset], , [slang_signals=no])
-if test x$slang_signals != xno; then
-    AC_DEFINE(SLANG_POSIX_SIGNALS, 1, [Define to use POSIX signal API in S-Lang])
-fi
-
 dnl
 dnl getpt is a GNU Extension (glibc 2.1.x)
 dnl
@@ -454,19 +448,16 @@ subshell="$result"
 
 
 dnl
-dnl Select the screen library.  mcslang is the included S-Lang library.
+dnl Select the screen library.
 dnl
 AC_ARG_WITH(screen,
-	[  --with-screen=LIB        Compile with screen library: slang, mcslang or
-                           ncurses [[slang if found, else mcslang]]])
+	[  --with-screen=LIB        Compile with screen library: slang or
+                           ncurses [[slang if found]]])
 
 case x$with_screen in
 xslang)
 	MC_WITH_SLANG(strict)
 	;;
-xmcslang)
-	MC_WITH_MCSLANG
-	;;
 xncurses)
 	MC_WITH_NCURSES
 	;;
@@ -480,18 +471,6 @@ esac
 
 
 dnl
-dnl Force using termcap.  This option is processed in MC_WITH_MCSLANG.
-dnl Report an error if this option is not applicable.
-dnl
-AC_ARG_WITH(termcap,
-	[  --with-termcap           Try using termcap database [[only if no terminfo]]],
-	[if test x$with_screen != xmcslang; then
-		AC_MSG_ERROR([Option `--with-termcap' only works with `--with-screen=mcslang'])
-	fi
-])
-
-
-dnl
 dnl Internal editor support.
 dnl
 AC_ARG_WITH(edit,
@@ -574,7 +553,6 @@ AM_CONDITIONAL(USE_VFS_NET, [test x"$use_net_code" = xtrue])
 AM_CONDITIONAL(USE_UNDEL_FS, [test -n "$use_undelfs"])
 AM_CONDITIONAL(USE_SAMBA_FS, [test -n "$use_smbfs"])
 AM_CONDITIONAL(USE_MCFS, [test -n "$use_mcfs"])
-AM_CONDITIONAL(INCLUDED_SLANG, [test "x$with_screen" = xmcslang])
 AM_CONDITIONAL(CHARSET, [test -n "$have_charset"])
 AM_CONDITIONAL(CONS_SAVER, [test -n "$cons_saver"])
 
@@ -589,7 +567,6 @@ vfs/Makefile
 vfs/extfs/Makefile
 lib/Makefile
 src/Makefile
-slang/Makefile 
 edit/Makefile 
 syntax/Makefile
 m4/Makefile
diff --git a/maint/mc-test b/maint/mc-test
index 7c6b2d0..d3fea71 100755
--- a/maint/mc-test
+++ b/maint/mc-test
@@ -49,7 +49,7 @@ mc_cflags=""
 mc_ldflags=""
 
 mc_tests="plain glib12 charset no_charset vfs no_vfs mcfs no_mcfs samba "\
-"no_samba ext2undel no_ext2undel slang mcslang ncurses maintainer "\
+"no_samba ext2undel no_ext2undel slang ncurses maintainer "\
 "no_maintainer i18n no_i18n no_features all_features"
 
 do_clean_basedir=no
@@ -443,12 +443,6 @@ test_slang() {
 	confbuild
 }
 
-test_mcslang() {
-	testname="mcslang"
-	configure_args="--with-screen=mcslang"
-	confbuild
-}
-
 test_ncurses() {
 	testname="ncurses"
 	configure_args="--with-screen=ncurses"
diff --git a/maint/mc-test-example.conf b/maint/mc-test-example.conf
index 973299b..6657f67 100644
--- a/maint/mc-test-example.conf
+++ b/maint/mc-test-example.conf
@@ -48,7 +48,7 @@
 
 # The list of tests that will be run.
 #mc_tests="plain glib12 charset no_charset vfs no_vfs mcfs no_mcfs samba "\
-#"no_samba ext2undel no_ext2undel slang mcslang ncurses maintainer "\
+#"no_samba ext2undel no_ext2undel slang ncurses maintainer "\
 #"no_maintainer i18n no_i18n no_features all_features"
 
 # This cleans mc_basedir and all its subdirectories. Any directories outside
diff --git a/maint/mcsnap b/maint/mcsnap
index e60679c..8c1d48f 100755
--- a/maint/mcsnap
+++ b/maint/mcsnap
@@ -78,7 +78,7 @@ mkdir "$RPM_SRC_DIR/RPMS"
 mkdir "$RPM_SRC_DIR/RPMS/i386"
 mkdir "$RPM_SRC_DIR/SPECS"
 $RPMBUILD -tb --define="_topdir $RPM_SRC_DIR" \
-  --define="_with_included_slang 1" "$MCTARBALL"
+  "$MCTARBALL"
 MC_RPM_VERSION=`echo $MCVERSION | sed s/-//g`
 MC_RPM=$RPM_SRC_DIR/RPMS/i386/mc-$MC_RPM_VERSION-1.i386.rpm
 if test ! -f $MC_RPM; then
diff --git a/maint/mctest b/maint/mctest
index b62a6af..a2e3030 100755
--- a/maint/mctest
+++ b/maint/mctest
@@ -40,7 +40,7 @@ echo "Checking the default configuration"
 distcheck 1
 
 echo "Checking the configuration with maximal code coverage"
-distcheck 2 with_screen=mcslang enable_charset=yes with_samba=yes \
+distcheck 2 enable_charset=yes with_samba=yes \
      with_mcfs=yes with_included_gettext=yes with_glib12=yes
 
 echo "Checking the configuration with minimal code coverage"
@@ -54,7 +54,7 @@ distcheck 4 enable_largefile=no enable_nls=no with_vfs=no \
      with_screen=ncurses
 
 echo "Checking the configuration with experimental and rarely used options"
-distcheck 5 with_screen=mcslang with_termcap=yes \
+distcheck 5 with_termcap=yes \
      with_mmap=no with_subshell=optional enable_netcode=no
 
 RPMBUILD=/usr/bin/rpmbuild
diff --git a/mc.spec.in b/mc.spec.in
index 2ce44bc..9385592 100644
--- a/mc.spec.in
+++ b/mc.spec.in
@@ -1,7 +1,6 @@
 # Conditional build (replace "#" with "%" to enable):
 #
 #define _with_ncurses		 1 # use ncurses
-#define _with_included_slang	 1 # use included S-Lang library
 #define _with_charset		 1 # enable code for charset conversion
 #define _with_samba		 1 # enable SMB/CIFS virtual file system
 #define _with_ext2undel		 1 # compile with ext2 undelete code
@@ -26,7 +25,7 @@ BuildRoot: /var/tmp/mc-%{PACKAGE_VERSION}-root
 
 # Names of those packages are distribution specific
 #BuildRequires: glib-devel
-#%{!?_with_included_slang:%{!?_with_ncurses:BuildRequires: slang-devel}}
+#%{!?_with_ncurses:BuildRequires: slang-devel}
 #%{?_with_ncurses:BuildRequires: ncurses-devel}
 
 %description
@@ -46,7 +45,6 @@ CFLAGS="$RPM_OPT_FLAGS" LDFLAGS="-s" ./configure \
 	--prefix=%{_prefix} \
 	--mandir=%{_mandir} \
 %{?_with_ncurses: --with-screen=ncurses} \
-%{?_with_included_slang: --with-screen=mcslang} \
 %{?_with_charset: --enable-charset} \
 %{?_with_samba: --with-samba} \
 %{?_with_ext2undel: --with-ext2undel} \
diff --git a/slang/.gitignore b/slang/.gitignore
deleted file mode 100644
index 6f30a4d..0000000
--- a/slang/.gitignore
+++ /dev/null
@@ -1,4 +0,0 @@
-.deps
-Makefile
-Makefile.in
-slang.h
diff --git a/slang/ChangeLog b/slang/ChangeLog
deleted file mode 100644
index 618c11f..0000000
--- a/slang/ChangeLog
+++ /dev/null
@@ -1,287 +0,0 @@
-2006-02-20  Pavel Tsekov  <ptsekov@gmx.net>
-
-	* slmisc.c: Import SLmake_string() and SLmake_nstring().
-
-2006-02-15  Leonard den Ottolander  <leonard den ottolander nl>
-
-	* slcommon.c: Patch to slang-2.0.6 leaving local patches intact.
-	* sldisply.c: Likewise.
-	* slerr.c: Likewise.
-	* slgetkey.c: Likewise.
-	* slmisc.c: Likewise.
-	* slsignal.c: Likewise.
-	* slsmg.c: Likewise.
-	* slstring.c: Likewise.
-	* sltermin.c: Likewise.
-	* slutty.c: Likewise.
-	* include/_slang.h: Likewise.
-	* include/slang.h: Likewise.
-
-2006-02-01  Vladimir Nadvorknik  <nadvornik@suse.cz>
-
-	* slcommon.c (utf8_enable_function): Use '==' instead of '=' for
-	comparison. Reported by David Binderman.
-
-2006-01-18  Pavel Shirshov  <me@pavelsh.pp.ru>
-
-	* include/slang.h: comment out declaration of SLmemset(), SLmemchr(),
-	SLmemcpy(), SLmemcmp(), SLmalloc(), SLfree(), SLrealloc().
-	* slcommon.c: comment out definitions of SLmalloc(), SLfree(),
-	SLrealloc().
-	* include/jdmacros.h: Fully rewritten to use glib rather than S-Lang
-	replacements.
-	* slmisc.c: Remove SLang_Version variable.
-
-2006-01-14  Pavel Shirshov  <me@pavelsh.pp.ru>
-
-	* sldisply.c (SLtt_initialize): Fix typo. Change Is_Bg_BGR
-	to Is_Fg_BGR.  (SLtt_goto_rc): Disable cursor movement optimizations
-	for qansi-m consoles. Needed on QNX Neutrino. (SLtt_initialize): Init
-	QANSI_Console variable. (SLtt_erase_line): Use tt_write() instead
-	tt_write_string(). (SLtt_cls): Use tt_write() instead tt_write_string().
-	(SLtt_tgetstr): Fix warning.
-	* slmisc.c: Trimmed down for use in GNU Midnight Commander.
-	* sltermin.c (_pSLtt_tigetent): Avoid strncpy, home_ti is 1K long and
-	obody really needs it whole cleared. Fix possible off-by-one error.
-	* include/slang.h: Define __unix__ if __MACH__, __NetBSD__,  _AIX is
-	defined.
-
-2005-11-28  Pavel Roskin  <proski@gnu.org>
-
-	* slvideo.c: Remove, it's only used by the obsolete PC port.
-	* slw32tty.c: Likewise.
-	* Makefile.am: Adjust for the above.
-
-2005-11-17  Leonard den Ottolander  <leonard den ottolander nl>
-
-	* Makefile.am: Reinstate ChangeLog.
-
-2005-11-16  Roland Illig  <roland.illig@gmx.de>
-
-	* slcommon.c (_pSLsecure_issetugid): Made the #ifdef more
-	readable.
-
-2005-11-15  Leonard den Ottolander  <leonard den ottolander nl>
-
-	* slcommon.c (_pSLsecure_issetugid): Remove dependency on glibc
-	private integer __libc_enable_secure.
-
-2005-11-10  Leonard den Ottolander  <leonard den ottolander nl>
-
-	* *: Upgrade slang to 2.0.5.
-
-2005-07-30  Roland Illig  <roland.illig@gmx.de>
-
-	* include/slang.h: Define __unix__ if __MACH__ is defined.
-
-2005-03-19  Pavel S. Shirshov  <me@pavelsh.pp.ru>
-
-	* sldisply.c (SLtt_initialize): Fix typo. Change Is_Bg_BGR,
-	not Is_Fg_BGR.
-
-2005-02-10  Roland Illig  <roland.illig@gmx.de>
-
-	* include/slang.h: Define __unix__ if __NetBSD__ is defined.
-
-2004-11-29  Pavel S. Shirshov  <me@pavelsh.pp.ru>
-
-	* Makefile.am: Use AM_CPPFLAGS for path to mc-slang includes.
-	* slmisc.c (SLang_Version): Declare const. Use SLANG_VERSION for version
-	number.
-	* include/slang.h (SLang_Version): Declare const.
-
-2004-11-09  Andrew V. Samoilov  <sav@bcs.zp.ua>
-
-	* sldisply.c (SLtt_delete_nlines): Add boundary check.
-	(forward_cursor): Remove unneeded boundary check.
-	(tt_write): Remove unneeded cast.
-
-2004-11-09  Pavel S. Shirshov  <me@pavelsh.pp.ru>
-
-	* include/slang.h (SLang_Version): Delete const qualifier for
-	compatibility with system slang library.
-	* slmisc.c: Likewise.
-
-	* sldisply.c (tt_sprintf): Import last changes from libslang-current.
-	Add code to check for a buffer overflow.
-	(tt_printf): Likewise.
-	(forward_cursor): Likewise.
-
-	From: John E. Davis <davis@space.mit.edu>
-
-2004-11-08  Andrew V. Samoilov  <sav@bcs.zp.ua>
-
-	* include/slang.h (SLang_Version): Declare const.
-	* slmisc.c: Add SLang_Version.
-
-2004-11-01  Pavel S. Shirshov  <me@pavelsh.pp.ru>
-
-	* README: Imported slang-1.4.9.
-	* sldisply.c: Likewise.
-	* slerr.c: Likewise.
-	* slgetkey.c: Likewise.
-	* slmisc.c: Likewise.
-	* slsignal.c: Likewise.
-	* slsmg.c: Likewise.
-	* sltermin.c: Likewise.
-	* slutty.c: Likewise.
-	* slvideo.c: Likewise.
-	* slw32tty.c: Likewise.
-	* include/_slang.h: Likewise.
-	* include/jdmacros.h: Likewise.
-	* include/sl-feat.h: Likewise.
-	* include/slang.h: Likewise.
-	* include/slinclud.h: Likewise.
-	* include/sllimits.h: Likewise.
-
-2004-10-27  Nerijus Baliunas  <nerijus@users.sourceforge.net>
-
-	* include/slang.h: Define __unix__ if _AIX is defined.
-	Needed on AIX.
-
-2004-10-14  Andrew V. Samoilov  <sav@bcs.zp.ua>
-
-	* sldisply.c (tt_sprintf): Add missed break.
-	* sldisply.c (SLtt_erase_line): Use tt_write() instead
-	tt_write_string().
-
-2004-09-26  Mike Gorchak  <mike@malva.ua>
-
-	* sldisplay.c (SLtt_goto_rc): Disable cursor movement optimizations
-	for qansi-m consoles. Needed on QNX Neutrino.
-	(SLtt_initialize): Init QANSI_Console variable.
-
-2004-09-24  Roland Illig  <roland.illig@gmx.de>
-
-	* slsignal.c (SLsystem): Replaced NULL with (char *) NULL in
-	call to execl.
-
-	From patches from the OpenBSD ports collection.
-
-2004-09-04  Pavel S. Shirshov  <me@pavelsh.pp.ru>
-
-	* sltermin.c (_SLtt_tigetent): Avoid strncpy, home_ti is 1K long and
-	nobody really needs it whole cleared
-
-2004-08-31  Pavel S. Shirshov  <me@pavelsh.pp.ru>
-
-	* include/slang.h: Revert last changes - it breaks compiling
-	* sldisply.c: Likewise.
-	* slerr.c: Likewise.
-	* slsmg.c: Likewise.
-	* sltermin.c: Likewise.
-
-2004-08-29  Roland Illig  <roland.illig@gmx.de>
-
-	* slang.h: Added const qualifier to some of the SLang functions.
-
-2003-09-26  Andrew V. Samoilov  <sav@bcs.zp.ua>
-
-	* sldisply.c (RGB_to_BGR): Make const.
-	* slsignal.c (SLsystem): Commented out.
-
-2003-09-11  Andrew V. Samoilov  <sav@bcs.zp.ua>
-
-	* slerr.c (SLang_doerror): Fix possible off-by-one error.
-	* sltermin.c (_SLtt_tigetent): Likewise.
-
-2002-11-28  Pavel Roskin  <proski@gnu.org>
-
-	* sldisply.c: Fix for the previous patch.  Only swap colors if
-	setf and setb are not empty.
-	Reported by Andras Barthazi <andras@barthazi.hu>
-
-2002-10-25  Pavel Roskin  <proski@gnu.org>
-
-	* sldisply.c: Patch to swap blue and red colors for setf/setb
-	capabilities.  Needed on QNX Neutrino.
-	Reported by Pavel Shirshov <me@pavelsh.pp.ru>
-
-2002-10-07  Pavel Roskin  <proski@gnu.org>
-
-	* include/jdmacros.h: Define SLMEMSET and SLMEMCPY
-	unconditionally, use macros with arguments.
-	* include/_slang.h: Make it clear which parts are disabled
-	for compatibility with glib.
-	* include/slinclud.h: Include malloc.h only if STDC_HEADERS is
-	not defined.
-
-2002-10-07  Andrew V. Samoilov  <sav@bcs.zp.ua>
-
-	* sldisply.c (Color_Def_Type): Make const.
-	* slsmg.c (Fake_Alt_Char_Pairs): Likewise.
-	* sltermin.c (Tgetstr_Map_Type): Likewise.
-	* slutty.c (Baud_Rate_Type): Likewise.
-
-2002-10-07  Pavel Roskin  <proski@gnu.org>
-
-	Update to S-Lang 1.4.5.  Move include files to "include"
-	directory to avoid the need to rename slang.h.
-	* Makefile.am: Adjust file list.  Add "-Iinclude" to the
-	compiler flags.
-	* include/jdmacros.h: Rewrite to use glib.
-	* slmisc.c: Trim to include only needed functions.
-
-2002-09-18  Andrew V. Samoilov  <sav@bcs.zp.ua>
-
-	* slerr.c (SLang_doerror): Use error parameter.  Eliminate
-	err[] array.
-
-2002-08-21  Pavel Roskin  <proski@gnu.org>
-
-	* slsmg.c (Fake_Alt_Char_Pairs): Update from slang-1.4.5.  This
-	fixes the MC logo in the help screen.
-
-2002-01-21  Pavel Roskin  <proski@gnu.org>
-
-	* slvideo.c: Include _slang.h, not slang.h.
-
-	* slos2tty.c: Remove since OS/2 is no longer supported.
-	* Makefile.am (EXTRASRC): Remove slos2tty.c.
-
-2001-12-21  Pavel Roskin  <proski@gnu.org>
-
-	* _slang.h: Include slang-mc.h.
-	* slang-mc.h: Add protection against using with system installed
-	S-Lang library.
-	* sl*.c: Only include _slang.h, but not slang.h to avoid making
-	symlinks.
-
-2001-09-04  Pavel Roskin  <proski@gnu.org>
-
-	* Makefile.am (AM_CFLAGS): Remove CFLAGS, don't use substituted
-	values directly.
-
-2001-08-26  Pavel Roskin  <proski@gnu.org>
-
-	* Makefile.am: Don't install libmcslang.a.
-
-	* Makefile.am (AM_CPPFLAGS): Remove, it's not needed.
-
-2001-08-25  Pavel Roskin  <proski@gnu.org>
-
-	* Makefile.in: Converted to ...
-	* Makefile.am: ... this.
-
-2001-02-22  Pavel Roskin  <proski@gnu.org>
-
-	* _slang.h: Include glib.h.
-
-Tue Apr 13 07:07:36 1999  Norbert Warmuth  <nwarmuth@privat.circular.de>
-
-	* slutty.c (SLsys_getkey): handle EOF on stdin (return
-	SLANG_GETKEY_ERROR on EOF instead of returning garbage)
-
-	* Makefile.in (clean): remove the symbolic link slang.h on the
-	distclean target and not on the clean target.
-
-Sun Feb 14 01:05:42 1999  Norbert Warmuth  <nwarmuth@privat.circular.de>
-
-	* sldisply.c (SLtt_get_terminfo): use g_snprintf instead of
-	sprintf
-
-	* slsmg.c (SLsmg_printf): ditto
-
-	* sltermin.c (SLtt_tigetent): ditto
-
-
diff --git a/slang/Makefile.am b/slang/Makefile.am
deleted file mode 100644
index c635015..0000000
--- a/slang/Makefile.am
+++ /dev/null
@@ -1,38 +0,0 @@
-AM_CFLAGS = $(GLIB_CFLAGS)
-AM_CPPFLAGS = -I$(srcdir)/include
-
-if INCLUDED_SLANG
-noinst_LIBRARIES = libmcslang.a
-else
-noinst_LIBRARIES =
-endif
-
-SLANG_INCLUDES = \
-	include/_slang.h \
-	include/jdmacros.h \
-	include/sl-feat.h \
-	include/slang.h \
-	include/slinclud.h \
-	include/sllimits.h \
-	include/sllower.h \
-	include/slupper.h \
-	include/slwcwidth.h
-
-libmcslang_a_SOURCES = \
-	slcommon.c \
-	sldisply.c \
-	slerr.c \
-	slgetkey.c \
-	sllower.c \
-	slmisc.c \
-	slsignal.c \
-	slsmg.c \
-	slstring.c \
-	sltermin.c \
-	slupper.c \
-	slutf8.c \
-	slutty.c \
-	slwcwidth.c \
-	$(SLANG_INCLUDES)
-
-EXTRA_DIST = ChangeLog README
diff --git a/slang/README b/slang/README
deleted file mode 100644
index 393acda..0000000
--- a/slang/README
+++ /dev/null
@@ -1,11 +0,0 @@
-This is the S-Lang library, version 2.0.5.  It has been radically
-stripped down to remove functions that are either unused by the Midnight
-Commander or already provided by the glib library.  The complete
-distribution can be downloaded from:
-
-http://www.s-lang.org/
-
-The sources in this directory are only used if you don't have the S-Lang
-library installed on your system or if you request to use these sources
-by specifying the option `--with-screen=mcslang' to the `configure'
-script.
diff --git a/slang/include/_slang.h b/slang/include/_slang.h
deleted file mode 100644
index b92f244..0000000
--- a/slang/include/_slang.h
+++ /dev/null
@@ -1,1406 +0,0 @@
-#ifndef PRIVATE_SLANG_H_
-#define PRIVATE_SLANG_H_
-/* header file for S-Lang internal structures that users do not (should not)
-   need.  Use slang.h for that purpose. */
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-/* #include "config.h" */
-#include "jdmacros.h"
-#include "sllimits.h"
-
-#ifdef VMS
-# define SLANG_SYSTEM_NAME "_VMS"
-#else
-# if defined (IBMPC_SYSTEM)
-#  define SLANG_SYSTEM_NAME "_IBMPC"
-# else
-#  define SLANG_SYSTEM_NAME "_UNIX"
-# endif
-#endif  /* VMS */
-
-/* These quantities are main_types for byte-compiled code.  They are used
- * by the inner_interp routine.  The _BC_ means byte-code.
- */
-
-/* Nametype byte-codes --- these must correspond to those in slang.h */
-typedef enum
-{
-   SLANG_BC_LAST_BLOCK		= 0,
-   SLANG_BC_LVARIABLE		= SLANG_LVARIABLE,   /* 0x01 */
-   SLANG_BC_GVARIABLE		= SLANG_GVARIABLE,   /* 0x02 */
-   SLANG_BC_IVARIABLE		= SLANG_IVARIABLE,   /* 0x03 */
-   SLANG_BC_RVARIABLE		= SLANG_RVARIABLE,   /* 0x04 */
-   SLANG_BC_INTRINSIC		= SLANG_INTRINSIC,   /* 0x05 */
-   SLANG_BC_FUNCTION		= SLANG_FUNCTION,   /* 0x06 */
-   SLANG_BC_MATH_UNARY		= SLANG_MATH_UNARY,   /* 0x07 */
-   SLANG_BC_APP_UNARY		= SLANG_APP_UNARY,   /* 0x08 */
-   SLANG_BC_ARITH_UNARY		= SLANG_ARITH_UNARY,   /* 0x09 */
-   SLANG_BC_ARITH_BINARY	= SLANG_ARITH_BINARY,   /* 0x0A */
-   SLANG_BC_ICONST		= SLANG_ICONSTANT,   /* 0x0B */
-   SLANG_BC_DCONST		= SLANG_DCONSTANT,   /* 0x0C */
-   SLANG_BC_FCONST		= SLANG_FCONSTANT,   /* 0x0D */
-   SLANG_BC_LLCONST		= SLANG_LLCONSTANT,   /* 0x0E */
-   SLANG_BC_PVARIABLE		= SLANG_PVARIABLE,   /* 0x0F */
-   SLANG_BC_PFUNCTION		= SLANG_PFUNCTION,   /* 0x10 */
-   SLANG_BC_HCONST		= SLANG_HCONSTANT,   /* 0x11 */
-   SLANG_BC_LCONST		= SLANG_LCONSTANT,   /* 0x12 */
-   SLANG_BC_UNUSED_0x12		= 0x12,
-   SLANG_BC_UNUSED_0x13		= 0x13,
-   SLANG_BC_UNUSED_0x14		= 0x14,
-   SLANG_BC_UNUSED_0x15		= 0x15,
-   SLANG_BC_UNUSED_0x16		= 0x16,
-   SLANG_BC_UNUSED_0x17		= 0x17,
-   SLANG_BC_UNUSED_0x18		= 0x18,
-   SLANG_BC_UNUSED_0x19		= 0x19,
-   SLANG_BC_UNUSED_0x1A		= 0x1A,
-   SLANG_BC_UNUSED_0x1B		= 0x1B,
-   SLANG_BC_UNUSED_0x1C		= 0x1C,
-   SLANG_BC_UNUSED_0x1D		= 0x1D,
-   SLANG_BC_UNUSED_0x1E		= 0x1E,
-   SLANG_BC_UNUSED_0x1F		= 0x1F,
-
-   /* bytes codes for setting/assigning variables/arrays/structures/refs */
-   SLANG_BC_SET_LOCAL_LVALUE	= 0x20,
-   SLANG_BC_SET_GLOBAL_LVALUE	= 0x21,
-   SLANG_BC_SET_INTRIN_LVALUE	= 0x22,
-   SLANG_BC_SET_STRUCT_LVALUE	= 0x23,
-   SLANG_BC_SET_ARRAY_LVALUE	= 0x24,
-   SLANG_BC_SET_DEREF_LVALUE	= 0x25,
-   SLANG_BC_FIELD		= 0x26,
-   SLANG_BC_METHOD		= 0x27,
-   SLANG_BC_LVARIABLE_AGET	= 0x28,
-   SLANG_BC_LVARIABLE_APUT	= 0x29,
-   SLANG_BC_LOBJPTR		= 0x2A,
-   SLANG_BC_GOBJPTR		= 0x2B,
-   SLANG_BC_UNUSED_0x2C		= 0x2C,
-   SLANG_BC_UNUSED_0x2D		= 0x2D,
-   SLANG_BC_UNUSED_0x2E		= 0x2E,
-   SLANG_BC_UNUSED_0x2F		= 0x2F,
-   SLANG_BC_UNUSED_0x30		= 0x30,
-   SLANG_BC_UNUSED_0x31		= 0x31,
-   SLANG_BC_UNUSED_0x32		= 0x32,
-   SLANG_BC_UNUSED_0x33		= 0x33,
-   SLANG_BC_UNUSED_0x34		= 0x34,
-   SLANG_BC_UNUSED_0x35		= 0x35,
-   SLANG_BC_UNUSED_0x36		= 0x36,
-   SLANG_BC_UNUSED_0x37		= 0x37,
-   SLANG_BC_UNUSED_0x38		= 0x38,
-   SLANG_BC_UNUSED_0x39		= 0x39,
-   SLANG_BC_UNUSED_0x3A		= 0x3A,
-   SLANG_BC_UNUSED_0x3B		= 0x3B,
-   SLANG_BC_UNUSED_0x3C		= 0x3C,
-   SLANG_BC_UNUSED_0x3D		= 0x3D,
-   SLANG_BC_UNUSED_0x3E		= 0x3E,
-   SLANG_BC_UNUSED_0x3F		= 0x3F,
-   
-   /* byte codes for literals */
-   SLANG_BC_LITERAL		= 0x40,           /* constant objects */
-   SLANG_BC_LITERAL_INT		= 0x41,
-   SLANG_BC_LITERAL_DBL		= 0x42,
-   SLANG_BC_LITERAL_STR		= 0x43,
-   SLANG_BC_DOLLAR_STR		= 0x44,
-   SLANG_BC_LITERAL_SHORT	= 0x45,
-   SLANG_BC_LITERAL_LONG	= 0x46,
-   SLANG_BC_UNUSED_0x45		= 0x45,
-   SLANG_BC_UNUSED_0x46		= 0x46,
-   SLANG_BC_UNUSED_0x47		= 0x47,
-   SLANG_BC_UNUSED_0x48		= 0x48,
-   SLANG_BC_UNUSED_0x49		= 0x49,
-   SLANG_BC_UNUSED_0x4A		= 0x4A,
-   SLANG_BC_UNUSED_0x4B		= 0x4B,
-   SLANG_BC_UNUSED_0x4C		= 0x4C,
-   SLANG_BC_UNUSED_0x4D		= 0x4D,
-   SLANG_BC_UNUSED_0x4E		= 0x4E,
-   SLANG_BC_UNUSED_0x4F		= 0x4F,
-   
-   /* Unary/Binary operation codes */
-   SLANG_BC_UNARY		= 0x50,
-   SLANG_BC_BINARY		= 0x51,
-   SLANG_BC_INTEGER_PLUS	= 0x52,
-   SLANG_BC_INTEGER_MINUS	= 0x53,
-   SLANG_BC_UNUSED_0x54		= 0x54,
-   SLANG_BC_UNUSED_0x55		= 0x55,
-   SLANG_BC_UNUSED_0x56		= 0x56,
-   SLANG_BC_UNUSED_0x57		= 0x57,
-   SLANG_BC_UNUSED_0x58		= 0x58,
-   SLANG_BC_UNUSED_0x59		= 0x59,
-   SLANG_BC_UNUSED_0x5A		= 0x5A,
-   SLANG_BC_UNUSED_0x5B		= 0x5B,
-   SLANG_BC_UNUSED_0x5C		= 0x5C,
-   SLANG_BC_UNUSED_0x5D		= 0x5D,
-   SLANG_BC_UNUSED_0x5E		= 0x5E,
-   SLANG_BC_UNUSED_0x5F		= 0x5F,
-   
-   /* byte codes associated with keywords and blocks */
-   SLANG_BC_TMP			= 0x60,
-   SLANG_BC_EXCH		= 0x61,
-   SLANG_BC_LABEL		= 0x62,
-   SLANG_BC_BLOCK		= 0x63,
-   SLANG_BC_RETURN		= 0x64,
-   SLANG_BC_BREAK		= 0x65,
-   SLANG_BC_CONTINUE		= 0x66,
-   SLANG_BC_IF_BLOCK		= 0x67,   /* optimized code */
-   SLANG_BC_UNUSED_0x68		= 0x68,
-   SLANG_BC_UNUSED_0x69		= 0x69,
-   SLANG_BC_X_ERROR		= 0x6A,
-   SLANG_BC_X_USER0		= 0x6B,
-   SLANG_BC_X_USER1		= 0x6C,
-   SLANG_BC_X_USER2		= 0x6D,
-   SLANG_BC_X_USER3		= 0x6E,
-   SLANG_BC_X_USER4		= 0x6F,
-   
-   /* byte codes for dealing with the frame pointer and arg list */
-   SLANG_BC_CALL_DIRECT		= 0x70,
-   SLANG_BC_CALL_DIRECT_FRAME	= 0x71,
-   /* SLANG_BC_ARG_LVARIABLE	= 0x72, */
-   SLANG_BC_UNUSED_0x72		= 0x72,
-   SLANG_BC_EARG_LVARIABLE	= 0x73,
-   SLANG_BC_LINE_NUM		= 0x74,
-   SLANG_BC_BOS			= 0x75,
-   SLANG_BC_EOS			= 0x76,
-   SLANG_BC_UNUSED_0x77		= 0x77,
-   SLANG_BC_UNUSED_0x78		= 0x78,
-   SLANG_BC_UNUSED_0x79		= 0x79,
-   SLANG_BC_UNUSED_0x7A		= 0x7A,
-   SLANG_BC_UNUSED_0x7B		= 0x7B,
-   SLANG_BC_UNUSED_0x7C		= 0x7C,
-   SLANG_BC_UNUSED_0x7D		= 0x7D,
-   SLANG_BC_UNUSED_0x7E		= 0x7E,
-   SLANG_BC_UNUSED_0x7F		= 0x7F,
-   
-   /* These are used only when compiled with USE_COMBINED_BYTECODES */
-   SLANG_BC_CALL_DIRECT_INTRINSIC= 0x80,
-   SLANG_BC_INTRINSIC_CALL_DIRECT= 0x81,
-   SLANG_BC_CALL_DIRECT_LSTR	= 0x82,
-   SLANG_BC_CALL_DIRECT_SLFUN	= 0x83,
-   SLANG_BC_CALL_DIRECT_RETINTR	= 0x84,
-   SLANG_BC_RET_INTRINSIC	= 0x85,
-   SLANG_BC_CALL_DIRECT_EARG_LVAR= 0x86,
-   SLANG_BC_CALL_DIRECT_LINT	= 0x87,
-   SLANG_BC_CALL_DIRECT_LVAR	= 0x88,
-   SLANG_BC_LLVARIABLE_BINARY	= 0x89,
-   SLANG_BC_LGVARIABLE_BINARY	= 0x8A,
-   SLANG_BC_GLVARIABLE_BINARY	= 0x8B,
-   SLANG_BC_GGVARIABLE_BINARY	= 0x8C,
-   SLANG_BC_LIVARIABLE_BINARY	= 0x8D,
-   SLANG_BC_LDVARIABLE_BINARY	= 0x8E,
-   SLANG_BC_ILVARIABLE_BINARY	= 0x8F,
-   SLANG_BC_DLVARIABLE_BINARY	= 0x90,
-   SLANG_BC_LVARIABLE_BINARY	= 0x91,
-   SLANG_BC_GVARIABLE_BINARY	= 0x92,
-   SLANG_BC_LITERAL_INT_BINARY	= 0x93,
-   SLANG_BC_LITERAL_DBL_BINARY	= 0x94,
-   SLANG_BC_LASSIGN_LLBINARY	= 0x95,
-   SLANG_BC_LASSIGN_LIBINARY	= 0x96,
-   SLANG_BC_LASSIGN_ILBINARY	= 0x97,
-   SLANG_BC_LASSIGN_LDBINARY	= 0x98,
-   SLANG_BC_LASSIGN_DLBINARY	= 0x99,
-   SLANG_BC_RET_LVARIABLE	= 0x9A,
-   SLANG_BC_RET_LITERAL_INT	= 0x9B,
-   SLANG_BC_MANY_LVARIABLE	= 0x9C,
-   SLANG_BC_MANY_LVARIABLE_DIR	= 0x9D,
-   SLANG_BC_LVARIABLE_AGET1	= 0x9E,
-   SLANG_BC_LITERAL_AGET1	= 0x9F,
-   SLANG_BC_LVARIABLE_APUT1	= 0xA0,
-   SLANG_BC_LITERAL_APUT1	= 0xA1,
-   SLANG_BC_UNUSED_0xA2		= 0xA2,
-   SLANG_BC_UNUSED_0xA3		= 0xA3,
-   SLANG_BC_UNUSED_0xA4		= 0xA4,
-   SLANG_BC_UNUSED_0xA5		= 0xA5,
-   SLANG_BC_UNUSED_0xA6		= 0xA6,
-   SLANG_BC_UNUSED_0xA7		= 0xA7,
-   SLANG_BC_UNUSED_0xA8		= 0xA8,
-   SLANG_BC_UNUSED_0xA9		= 0xA9,
-   SLANG_BC_UNUSED_0xAA		= 0xAA,
-   SLANG_BC_UNUSED_0xAB		= 0xAB,
-   SLANG_BC_UNUSED_0xAC		= 0xAC,
-   SLANG_BC_UNUSED_0xAD		= 0xAD,
-   SLANG_BC_UNUSED_0xAE		= 0xAE,
-   SLANG_BC_UNUSED_0xAF		= 0xAF,
-   /* The following do not actually occur in inner_interp.  They used 
-    * to signify the bytecode has been combined with another.
-    */
-   SLANG_BC_LVARIABLE_COMBINED	= 0xB0,
-   SLANG_BC_GVARIABLE_COMBINED	= 0xB1,
-   SLANG_BC_LITERAL_COMBINED	= 0xB2,
-   SLANG_BC_CALL_DIRECT_COMB	= 0xB3,
-   SLANG_BC_COMBINED		= 0xB4,
-   SLANG_BC_UNUSED_0xB5		= 0xB5,
-   SLANG_BC_UNUSED_0xB6		= 0xB6,
-   SLANG_BC_UNUSED_0xB7		= 0xB7,
-   SLANG_BC_UNUSED_0xB8		= 0xB8,
-   SLANG_BC_UNUSED_0xB9		= 0xB9,
-   SLANG_BC_UNUSED_0xBA		= 0xBA,
-   SLANG_BC_UNUSED_0xBB		= 0xBB,
-   SLANG_BC_UNUSED_0xBC		= 0xBC,
-   SLANG_BC_UNUSED_0xBD		= 0xBD,
-   SLANG_BC_UNUSED_0xBE		= 0xBE,
-   SLANG_BC_UNUSED_0xBF		= 0xBF,
-   SLANG_BC_UNUSED_0xC0		= 0xC0,
-   SLANG_BC_UNUSED_0xC1		= 0xC1,
-   SLANG_BC_UNUSED_0xC2		= 0xC2,
-   SLANG_BC_UNUSED_0xC3		= 0xC3,
-   SLANG_BC_UNUSED_0xC4		= 0xC4,
-   SLANG_BC_UNUSED_0xC5		= 0xC5,
-   SLANG_BC_UNUSED_0xC6		= 0xC6,
-   SLANG_BC_UNUSED_0xC7		= 0xC7,
-   SLANG_BC_UNUSED_0xC8		= 0xC8,
-   SLANG_BC_UNUSED_0xC9		= 0xC9,
-   SLANG_BC_UNUSED_0xCA		= 0xCA,
-   SLANG_BC_UNUSED_0xCB		= 0xCB,
-   SLANG_BC_UNUSED_0xCC		= 0xCC,
-   SLANG_BC_UNUSED_0xCD		= 0xCD,
-   SLANG_BC_UNUSED_0xCE		= 0xCE,
-   SLANG_BC_UNUSED_0xCF		= 0xCF,
-   SLANG_BC_UNUSED_0xD0		= 0xD0,
-   SLANG_BC_UNUSED_0xD1		= 0xD1,
-   SLANG_BC_UNUSED_0xD2		= 0xD2,
-   SLANG_BC_UNUSED_0xD3		= 0xD3,
-   SLANG_BC_UNUSED_0xD4		= 0xD4,
-   SLANG_BC_UNUSED_0xD5		= 0xD5,
-   SLANG_BC_UNUSED_0xD6		= 0xD6,
-   SLANG_BC_UNUSED_0xD7		= 0xD7,
-   SLANG_BC_UNUSED_0xD8		= 0xD8,
-   SLANG_BC_UNUSED_0xD9		= 0xD9,
-   SLANG_BC_UNUSED_0xDA		= 0xDA,
-   SLANG_BC_UNUSED_0xDB		= 0xDB,
-   SLANG_BC_UNUSED_0xDC		= 0xDC,
-   SLANG_BC_UNUSED_0xDD		= 0xDD,
-   SLANG_BC_UNUSED_0xDE		= 0xDE,
-   SLANG_BC_UNUSED_0xDF		= 0xDF,
-   SLANG_BC_UNUSED_0xE0		= 0xE0,
-   SLANG_BC_UNUSED_0xE1		= 0xE1,
-   SLANG_BC_UNUSED_0xE2		= 0xE2,
-   SLANG_BC_UNUSED_0xE3		= 0xE3,
-   SLANG_BC_UNUSED_0xE4		= 0xE4,
-   SLANG_BC_UNUSED_0xE5		= 0xE5,
-   SLANG_BC_UNUSED_0xE6		= 0xE6,
-   SLANG_BC_UNUSED_0xE7		= 0xE7,
-   SLANG_BC_UNUSED_0xE8		= 0xE8,
-   SLANG_BC_UNUSED_0xE9		= 0xE9,
-   SLANG_BC_UNUSED_0xEA		= 0xEA,
-   SLANG_BC_UNUSED_0xEB		= 0xEB,
-   SLANG_BC_UNUSED_0xEC		= 0xEC,
-   SLANG_BC_UNUSED_0xED		= 0xED,
-   SLANG_BC_UNUSED_0xEE		= 0xEE,
-   SLANG_BC_UNUSED_0xEF		= 0xEF,
-   SLANG_BC_UNUSED_0xF0		= 0xF0,
-   SLANG_BC_UNUSED_0xF1		= 0xF1,
-   SLANG_BC_UNUSED_0xF2		= 0xF2,
-   SLANG_BC_UNUSED_0xF3		= 0xF3,
-   SLANG_BC_UNUSED_0xF4		= 0xF4,
-   SLANG_BC_UNUSED_0xF5		= 0xF5,
-   SLANG_BC_UNUSED_0xF6		= 0xF6,
-   SLANG_BC_UNUSED_0xF7		= 0xF7,
-   SLANG_BC_UNUSED_0xF8		= 0xF8,
-   SLANG_BC_UNUSED_0xF9		= 0xF9,
-   SLANG_BC_UNUSED_0xFA		= 0xFA,
-   SLANG_BC_UNUSED_0xFB		= 0xFB,
-   SLANG_BC_UNUSED_0xFC		= 0xFC,
-   SLANG_BC_UNUSED_0xFD		= 0xFD,
-   SLANG_BC_UNUSED_0xFE		= 0xFE,
-   SLANG_BC_UNUSED_0xFF		= 0xFF
-}
-_pSLang_BC_Type;
-   
-/* Byte-Code Sub Types (_BCST_) */
-
-/* These are sub_types of SLANG_BC_BLOCK */
-#define SLANG_BCST_ERROR_BLOCK	0x01
-#define SLANG_BCST_EXIT_BLOCK	0x02
-#define SLANG_BCST_USER_BLOCK0	0x03
-#define SLANG_BCST_USER_BLOCK1	0x04
-#define SLANG_BCST_USER_BLOCK2	0x05
-#define SLANG_BCST_USER_BLOCK3	0x06
-#define SLANG_BCST_USER_BLOCK4	0x07
-/* The user blocks MUST be in the above order */
-#define SLANG_BCST_LOOP	0x10
-#define SLANG_BCST_WHILE	0x11
-#define SLANG_BCST_FOR		0x12
-#define SLANG_BCST_FOREVER	0x13
-#define SLANG_BCST_CFOR	0x14
-#define SLANG_BCST_DOWHILE	0x15
-#define SLANG_BCST_FOREACH	0x16
-#define SLANG_BCST_TRY		0x17
-
-#define SLANG_BCST_IF		0x20
-#define SLANG_BCST_IFNOT	0x21
-#define SLANG_BCST_ELSE	0x22
-#define SLANG_BCST_ANDELSE	0x23
-#define SLANG_BCST_ORELSE	0x24
-#define SLANG_BCST_SWITCH	0x25
-#define SLANG_BCST_NOTELSE	0x26
-
-/* assignment (SLANG_BC_SET_*_LVALUE) subtypes.  The order MUST correspond
- * to the assignment token order with the ASSIGN_TOKEN as the first!
- */
-#define SLANG_BCST_ASSIGN		0x01
-#define SLANG_BCST_PLUSEQS		0x02
-#define SLANG_BCST_MINUSEQS		0x03
-#define SLANG_BCST_TIMESEQS		0x04
-#define SLANG_BCST_DIVEQS		0x05
-#define SLANG_BCST_BOREQS		0x06
-#define SLANG_BCST_BANDEQS		0x07
-#define SLANG_BCST_PLUSPLUS		0x08
-#define SLANG_BCST_POST_PLUSPLUS	0x09
-#define SLANG_BCST_MINUSMINUS		0x0A
-#define SLANG_BCST_POST_MINUSMINUS	0x0B
-
-/* These use SLANG_PLUS, SLANG_MINUS, SLANG_PLUSPLUS, etc... */
-
-
-#define LONG_IS_INT (SIZEOF_INT == SIZEOF_LONG)
-#define LONG_IS_NOT_INT (SIZEOF_INT != SIZEOF_LONG)
-#define SHORT_IS_INT (SIZEOF_INT == SIZEOF_SHORT)
-#define SHORT_IS_NOT_INT (SIZEOF_INT != SIZEOF_SHORT)
-#define LLONG_IS_LONG (SIZEOF_LONG == SIZEOF_LONG_LONG)
-#define LLONG_IS_NOT_LONG (SIZEOF_LONG != SIZEOF_LONG_LONG)
-
-/* If long or short are ints, then map the slang types to ints.  This is
- * done because slang has some optimizations for ints.
- */
-#if LONG_IS_INT
-# define _pSLANG_LONG_TYPE SLANG_INT_TYPE
-# define _pSLANG_ULONG_TYPE SLANG_UINT_TYPE
-#else
-# define _pSLANG_LONG_TYPE SLANG_LONG_TYPE
-# define _pSLANG_ULONG_TYPE SLANG_ULONG_TYPE
-#endif
-#if SHORT_IS_INT
-# define _pSLANG_SHORT_TYPE SLANG_INT_TYPE
-# define _pSLANG_USHORT_TYPE SLANG_UINT_TYPE
-#else
-# define _pSLANG_SHORT_TYPE SLANG_SHORT_TYPE
-# define _pSLANG_USHORT_TYPE SLANG_USHORT_TYPE
-#endif
-#if LLONG_IS_LONG
-# define _pSLANG_LLONG_TYPE _pSLANG_LONG_TYPE
-# define _pSLANG_ULLONG_TYPE _pSLANG_ULONG_TYPE
-#else
-# define _pSLANG_LLONG_TYPE SLANG_LLONG_TYPE
-# define _pSLANG_ULLONG_TYPE SLANG_ULLONG_TYPE
-#endif
-
-/* Map off_t to a slang type */
-#if defined(HAVE_LONG_LONG) && (SIZEOF_OFF_T == SIZEOF_LONG_LONG) && (SIZEOF_LONG_LONG > SIZEOF_LONG)
-# define SLANG_C_OFF_T_TYPE _pSLANG_LLONG_TYPE
-typedef long long _pSLc_off_t_Type;
-# define SLANG_PUSH_OFF_T SLang_push_long_long
-#else
-# if (SIZEOF_OFF_T == SIZEOF_INT)
-#  define SLANG_C_OFF_T_TYPE SLANG_INT_TYPE
-#  define SLANG_PUSH_OFF_T SLang_push_int
-typedef int _pSLc_off_t_Type;
-# else
-#  define SLANG_C_OFF_T_TYPE _pSLANG_LONG_TYPE
-#  define SLANG_PUSH_OFF_T SLang_push_long
-typedef long _pSLc_off_t_Type;
-# endif
-#endif
-
-#if SIZEOF_INT == 2
-# define _pSLANG_INT16_TYPE	SLANG_INT_TYPE
-# define _pSLANG_UINT16_TYPE	SLANG_UINT_TYPE
-#else
-# if SIZEOF_SHORT == 2
-#  define _pSLANG_INT16_TYPE	SLANG_SHORT_TYPE
-#  define _pSLANG_UINT16_TYPE	SLANG_USHORT_TYPE
-# else
-#  if SIZEOF_LONG == 2
-#   define _pSLANG_INT16_TYPE	SLANG_LONG_TYPE
-#   define _pSLANG_UINT16_TYPE	SLANG_ULONG_TYPE
-#  else
-#   define _pSLANG_INT16_TYPE	0
-#   define _pSLANG_UINT16_TYPE	0
-#  endif
-# endif
-#endif
-
-#if SIZEOF_INT == 4
-# define _pSLANG_INT32_TYPE	SLANG_INT_TYPE
-# define _pSLANG_UINT32_TYPE	SLANG_UINT_TYPE
-#else
-# if SIZEOF_SHORT == 4
-#  define _pSLANG_INT32_TYPE	SLANG_SHORT_TYPE
-#  define _pSLANG_UINT32_TYPE	SLANG_USHORT_TYPE
-# else
-#  if SIZEOF_LONG == 4
-#   define _pSLANG_INT32_TYPE	SLANG_LONG_TYPE
-#   define _pSLANG_UINT32_TYPE	SLANG_ULONG_TYPE
-#  else
-#   define _pSLANG_INT32_TYPE	0
-#   define _pSLANG_UINT32_TYPE	0
-#  endif
-# endif
-#endif
-
-#if SIZEOF_INT == 8
-# define _pSLANG_INT64_TYPE	SLANG_INT_TYPE
-# define _pSLANG_UINT64_TYPE	SLANG_UINT_TYPE
-#else
-# if SIZEOF_SHORT == 8
-#  define _pSLANG_INT64_TYPE	SLANG_SHORT_TYPE
-#  define _pSLANG_UINT64_TYPE	SLANG_USHORT_TYPE
-# else
-#  if SIZEOF_LONG == 8
-#   define _pSLANG_INT64_TYPE	SLANG_LONG_TYPE
-#   define _pSLANG_UINT64_TYPE	SLANG_ULONG_TYPE
-#  else
-#   if SIZEOF_LONG_LONG == 8
-#    define _pSLANG_INT64_TYPE	SLANG_LLONG_TYPE
-#    define _pSLANG_UINT64_TYPE	SLANG_ULLONG_TYPE
-#   else
-#    define _pSLANG_INT64_TYPE	0
-#    define _pSLANG_UINT64_TYPE	0
-#   endif
-#  endif
-# endif
-#endif
-
-
-typedef union
-{
-#if SLANG_HAS_FLOAT
-   double double_val;
-   float float_val;
-#endif
-#ifdef HAVE_LONG_LONG
-   long long llong_val;
-   unsigned long long ullong_val;
-#endif
-   long long_val;
-   unsigned long ulong_val;
-   VOID_STAR ptr_val;
-   char *s_val;
-   int int_val;
-   unsigned int uint_val;
-   SLang_MMT_Type *ref;
-   SLang_Name_Type *n_val;
-   struct _pSLang_Struct_Type *struct_val;
-   struct _pSLang_Array_Type *array_val;
-   short short_val;
-   unsigned short ushort_val;
-   char char_val;
-   unsigned char uchar_val;
-   SLindex_Type index_val;
-}
-_pSL_Object_Union_Type;
-
-typedef struct _pSLang_Object_Type
-{
-   SLtype data_type;	       /* SLANG_INT_TYPE, ... */
-   _pSL_Object_Union_Type v;
-}
-SLang_Object_Type;
-
-struct _pSLang_MMT_Type
-{
-   SLtype data_type;	       /* int, string, etc... */
-   VOID_STAR user_data;	       /* address of user structure */
-   unsigned int count;		       /* number of references */
-};
-
-extern int _pSLang_pop_object_of_type (SLtype, SLang_Object_Type *, int);
-
-typedef struct
-{
-   char *name;			       /* slstring */
-   SLang_Object_Type obj;
-}
-_pSLstruct_Field_Type;
-
-typedef struct _pSLang_Struct_Type
-{
-   _pSLstruct_Field_Type *fields;
-   unsigned int nfields;	       /* number used */
-   unsigned int num_refs;
-   /* user-defined methods */
-   SLang_Name_Type *destroy_method;
-}
-_pSLang_Struct_Type;
-
-extern void _pSLstruct_delete_struct (_pSLang_Struct_Type *);
-extern int _pSLang_push_struct (_pSLang_Struct_Type *);
-extern int _pSLang_pop_struct (_pSLang_Struct_Type **);
-extern int _pSLstruct_init (void);
-/* extern int _pSLstruct_get_field (char *); */
-extern int _pSLstruct_define_struct (void);
-extern int _pSLstruct_define_typedef (void);
-
-struct _pSLang_Ref_Type
-{
-   int is_global;
-   union
-     {
-	SLang_Name_Type *nt;
-	SLang_Object_Type *local_obj;
-     }
-   v;
-};
-
-extern int _pSLang_dereference_ref (SLang_Ref_Type *);
-extern int _pSLang_deref_assign (SLang_Ref_Type *);
-extern int _pSLang_push_ref (int, VOID_STAR);
-
-extern int _pSL_increment_frame_pointer (void);
-extern int _pSL_decrement_frame_pointer (void);
-
-extern int SLang_pop(SLang_Object_Type *);
-extern void SLang_free_object (SLang_Object_Type *);
-extern int _pSLanytype_typecast (SLtype, VOID_STAR, unsigned int,
-				SLtype, VOID_STAR);
-extern void _pSLstring_intrinsic (void);
-
-#if 0
-/* NULL not allowed here */
-extern char *_pSLmalloced_to_slstring (char *, unsigned int);
-/* But here it is ok */
-extern int _pSLpush_malloced_string (char *, unsigned int);
-#endif
-
-/* These functions are used to create slstrings of a fixed length.  Be
- * very careful how they are used.  In particular, if len bytes are allocated,
- * then the string must be len characters long, no more and no less.
- */
-extern char *_pSLallocate_slstring (unsigned int);
-extern char *_pSLcreate_via_alloced_slstring (char *, unsigned int);
-extern void _pSLunallocate_slstring (char *, unsigned int);
-extern int _pSLpush_alloced_slstring (char *, unsigned int);
-
-
-extern unsigned int _pSLstring_bytelen (SLstr_Type *);
-extern void _pSLang_free_slstring (SLstr_Type *);   /* slstring required and assumed */
-extern unsigned long _pSLstring_get_hash (SLstr_Type *s);   /* slstring required */
-
-typedef struct 
-{
-   char **buf;
-   unsigned int max_num;
-   unsigned int num;
-   unsigned int delta_num;
-   int is_malloced;		       /* non-zero if object was malloced */
-}
-_pSLString_List_Type;
-
-/* Note that _pSLstring_list_append makes no copy of the object-- it steals it.
- * For a copy, use _pSLstring_list_append_copy */
-extern int _pSLstring_list_append (_pSLString_List_Type *, char *);
-extern int _pSLstring_list_append_copy (_pSLString_List_Type *, char *);
-extern int _pSLstring_list_init (_pSLString_List_Type *, unsigned int, unsigned int);
-extern _pSLString_List_Type *_pSLstring_list_new (unsigned int, unsigned int);
-extern void _pSLstring_list_delete (_pSLString_List_Type *);
-extern int _pSLstring_list_push (_pSLString_List_Type *, int);
-extern SLang_Array_Type *_pSLstrings_to_array (char **strs, unsigned int n);
-
-/* This function assumes that s is an slstring. */
-extern char *_pSLstring_dup_slstring (char *);
-extern int _pSLang_dup_and_push_slstring (char *);
-
-
-extern int _pSLang_init_import (void);
-extern int _pSLinit_exceptions (void);
-
-/* This function checks to see if the referenced object is initialized */
-extern int _pSLang_is_ref_initialized (SLang_Ref_Type *);
-extern int _pSLcheck_identifier_syntax (char *);
-extern int _pSLang_uninitialize_ref (SLang_Ref_Type *);
-
-extern int _pSLpush_slang_obj (SLang_Object_Type *);
-
-extern char *_pSLexpand_escaped_char(char *, SLwchar_Type *, int *);
-extern void _pSLexpand_escaped_string (char *, char *, char *);
-
-/* returns a pointer to an SLstring string-- use SLang_free_slstring */
-extern char *_pSLstringize_object (SLang_Object_Type *);
-extern int _pSLdump_objects (char *, SLang_Object_Type *, unsigned int, int);
-
-extern SLang_Object_Type *_pSLang_get_run_stack_pointer (void);
-extern SLang_Object_Type *_pSLang_get_run_stack_base (void);
-extern int _pSLang_dump_stack (void);
-extern int _pSLang_peek_at_stack2 (SLtype *);
-
-struct _pSLang_NameSpace_Type
-{
-   struct _pSLang_NameSpace_Type *next;
-   char *name;			       /* this is the load_type name */
-   char *namespace_name;	       /* this name is assigned by implements */
-   char *private_name;
-   unsigned int table_size;
-   SLang_Name_Type **table;
-};
-extern SLang_NameSpace_Type *_pSLns_new_namespace (char *, unsigned int);
-extern SLang_NameSpace_Type *_pSLns_allocate_namespace (char *, unsigned int);
-extern void _pSLns_deallocate_namespace (SLang_NameSpace_Type *);
-extern SLang_NameSpace_Type *_pSLns_find_namespace (char *);
-extern int _pSLns_set_namespace_name (SLang_NameSpace_Type *, char *);
-extern SLang_Array_Type *_pSLnspace_apropos (SLang_NameSpace_Type *, char *, unsigned int);
-extern void _pSLang_use_namespace_intrinsic (char *name);
-extern char *_pSLang_cur_namespace_intrinsic (void);
-extern SLang_Array_Type *_pSLang_apropos (char *, char *, unsigned int);
-extern void _pSLang_implements_intrinsic (char *);
-extern SLang_Array_Type *_pSLns_list_namespaces (void);
-extern SLang_Name_Type *_pSLns_locate_hashed_name (SLang_NameSpace_Type *, char *, unsigned long);
-extern int _pSLns_add_hashed_name (SLang_NameSpace_Type *, SLang_Name_Type *, unsigned long);
-extern SLang_NameSpace_Type *_pSLns_find_object_namespace (SLang_Name_Type *nt);
-extern SLang_Name_Type *_pSLns_locate_name (SLang_NameSpace_Type *, char *);
-extern SLang_NameSpace_Type *_pSLns_get_private_namespace (char *name, char *nsname);
-extern SLang_NameSpace_Type *_pSLns_create_namespace2 (char *name, char *nsname);
-
-extern int _pSLang_Trace;
-extern char *_pSLang_current_function_name (void);
-
-extern int _pSLang_trace_fun(char *);
-
-/* This is a bitmapped variable */
-extern int _pSLang_Compile_Line_Num_Info;
-#if SLANG_HAS_BOSEOS
-extern int _pSLang_Compile_BOSEOS;
-extern int _pSLang_init_boseos (void);
-extern int _pSLcall_bos_handler (char *, int);
-extern int _pSLcall_eos_handler (void);
-extern int _pSLcall_debug_hook (char *file, int linenum);
-/* extern int _pSLcall_debug_hook (char *file, int linenum, char *funct); */
-#endif
-
-extern char *_pSLstring_dup_hashed_string (char *, unsigned long);
-extern unsigned long _pSLcompute_string_hash (char *);
-extern char *_pSLstring_make_hashed_string (char *, unsigned int, unsigned long *);
-extern void _pSLfree_hashed_string (char *, unsigned int, unsigned long);
-unsigned long _pSLstring_hash (unsigned char *, unsigned char *);
-extern int _pSLinit_slcomplex (void);
-
-extern int _pSLang_init_slstrops (void);
-extern int _pSLstrops_do_sprintf_n (int);
-extern int _pSLang_sscanf (void);
-extern double _pSLang_atof (char *);
-extern int _pSLang_init_bstring (void);
-extern int _pSLang_init_sltime (void);
-extern void _pSLpack (void);
-extern void _pSLunpack (char *, SLang_BString_Type *);
-extern void _pSLpack_pad_format (char *);
-extern unsigned int _pSLpack_compute_size (char *);
-extern int _pSLusleep (unsigned long);
-
-/* frees upon error.  NULL __NOT__ ok. */
-extern int _pSLang_push_slstring (char *);
-
-extern SLtype _pSLarith_promote_type (SLtype);
-extern int _pSLarith_get_precedence (SLtype);
-extern int _pSLarith_typecast (SLtype, VOID_STAR, unsigned int,
-			      SLtype, VOID_STAR);
-
-extern int SLang_push(SLang_Object_Type *);
-extern int SLadd_global_variable (char *);
-
-extern int _pSLdo_pop (void);
-extern unsigned int _pSLsys_getkey (void);
-extern int _pSLsys_input_pending (int);
-#ifdef IBMPC_SYSTEM
-extern unsigned int _pSLpc_convert_scancode (unsigned int, unsigned int, int);
-#define _pSLTT_KEY_SHIFT	1
-#define _pSLTT_KEY_CTRL		2
-#define _pSLTT_KEY_ALT		4
-#endif
-
-typedef struct _pSLterminfo_Type SLterminfo_Type;
-extern SLterminfo_Type *_pSLtt_tigetent (char *);
-extern char *_pSLtt_tigetstr (SLterminfo_Type *, char *);
-extern int _pSLtt_tigetnum (SLterminfo_Type *, char *);
-extern int _pSLtt_tigetflag (SLterminfo_Type *, char *);
-
-#if SLTT_HAS_NON_BCE_SUPPORT
-extern int _pSLtt_get_bce_color_offset (void);
-#endif
-extern void (*_pSLtt_color_changed_hook)(void);
-
-extern unsigned char SLang_Input_Buffer [SL_MAX_INPUT_BUFFER_LEN];
-
-typedef struct SL_OOBinary_Type
-{
-   SLtype data_type;	       /* partner type for binary op */
-
-    int (*binary_function)_PROTO((int,
-				 SLtype, VOID_STAR, unsigned int,
-				 SLtype, VOID_STAR, unsigned int,
-				 VOID_STAR));
-
-   int (*binary_result) _PROTO((int, SLtype, SLtype, SLtype *));
-   struct SL_OOBinary_Type *next;
-}
-SL_OOBinary_Type;
-
-typedef struct _pSL_Typecast_Type
-{
-   SLtype data_type;	       /* to_type */
-   int allow_implicit;
-
-   int (*typecast)_PROTO((SLtype, VOID_STAR, unsigned int,
-			  SLtype, VOID_STAR));
-   struct _pSL_Typecast_Type *next;
-}
-SL_Typecast_Type;
-
-struct _pSLang_Class_Type
-{
-   SLclass_Type cl_class_type;	       /* vector, scalar, mmt, pointer */
-
-   unsigned int cl_data_type;	       /* SLANG_INTEGER_TYPE, etc... */
-   char *cl_name;			       /* slstring type */
-
-   size_t cl_sizeof_type;
-   VOID_STAR cl_transfer_buf;	       /* cl_sizeof_type bytes*/
-
-   /* Methods */
-
-   /* Most of the method functions are prototyped:
-    * int method (SLtype type, VOID_STAR addr);
-    * Here, @type@ represents the type of object that the method is asked
-    * to deal with.  The second parameter @addr@ will contain the ADDRESS of
-    * the object.  For example, if type is SLANG_INT_TYPE, then @addr@ will
-    * actually be int *.  Similary, if type is SLANG_STRING_TYPE,
-    * then @addr@ will contain the address of the string, i.e., char **.
-    */
-
-   void (*cl_destroy)_PROTO((SLtype, VOID_STAR));
-   /* Prototype: void destroy(unsigned type, VOID_STAR val)
-    * Called to delete/free the object */
-
-   char *(*cl_string)_PROTO((SLtype, VOID_STAR));
-   /* Prototype: char *to_string (SLtype t, VOID_STAR p);
-    * Here p is a pointer to the object for which a string representation
-    * is to be returned.  The returned pointer is to be a MALLOCED string.
-    */
-
-   /* Prototype: void push(SLtype type, VOID_STAR v);
-    * Push a copy of the object of type @type@ at address @v@ onto the
-    * stack.
-    */
-   int (*cl_push)_PROTO((SLtype, VOID_STAR));
-
-   /* Prototype: int pop(SLtype type, VOID_STAR v);
-    * Pops value from stack and assign it to object, whose address is @v@.
-    */
-   int (*cl_pop)_PROTO((SLtype, VOID_STAR));
-
-   /* mul2, sign, etc... */
-   int (*cl_unary_op_result_type)_PROTO((int, SLtype, SLtype *));
-   int (*cl_unary_op)_PROTO((int, SLtype, VOID_STAR, unsigned int, VOID_STAR));
-
-#if 0
-   int (*cl_arith_unary_op_result_type)_PROTO((int, SLtype, SLtype *));
-   int (*cl_arith_unary_op)_PROTO((int, SLtype, VOID_STAR, unsigned int, VOID_STAR));
-#endif
-   int (*cl_app_unary_op_result_type)_PROTO((int, SLtype, SLtype *));
-   int (*cl_app_unary_op)_PROTO((int, SLtype, VOID_STAR, unsigned int, VOID_STAR));
-
-   /* If this function is non-NULL, it will be called for sin, cos, etc... */
-
-   int (*cl_math_op)_PROTO((int, SLtype, VOID_STAR, unsigned int, VOID_STAR));
-   int (*cl_math_op_result_type)_PROTO((int, SLtype, SLtype *));
-
-   SL_OOBinary_Type *cl_binary_ops;
-   SL_Typecast_Type *cl_typecast_funs;
-
-   void (*cl_byte_code_destroy)_PROTO((SLtype, VOID_STAR));
-   void (*cl_user_destroy_fun)_PROTO((SLtype, VOID_STAR));
-   int (*cl_init_array_object)_PROTO((SLtype, VOID_STAR));
-   int (*cl_datatype_deref)_PROTO((SLtype));
-   SLang_Struct_Type *cl_struct_def;
-   int (*cl_dereference) _PROTO((SLtype, VOID_STAR));
-   int (*cl_acopy) (SLtype, VOID_STAR, VOID_STAR);
-   int (*cl_apop) _PROTO((SLtype, VOID_STAR));
-   int (*cl_apush) _PROTO((SLtype, VOID_STAR));
-   int (*cl_push_literal) _PROTO((SLtype, VOID_STAR));
-   void (*cl_adestroy)_PROTO((SLtype, VOID_STAR));
-   int (*cl_push_intrinsic)_PROTO((SLtype, VOID_STAR));
-   int (*cl_void_typecast)_PROTO((SLtype, VOID_STAR, unsigned int, SLtype, VOID_STAR));
-
-   int (*cl_anytype_typecast)_PROTO((SLtype, VOID_STAR, unsigned int, SLtype, VOID_STAR));
-
-   /* Array access functions */
-   int (*cl_aput) (SLtype, unsigned int);
-   int (*cl_aget) (SLtype, unsigned int);
-   int (*cl_anew) (SLtype, unsigned int);
-
-   /* length method */
-   int (*cl_length) (SLtype, VOID_STAR, unsigned int *);
-
-   /* foreach */
-   SLang_Foreach_Context_Type *(*cl_foreach_open) (SLtype, unsigned int);
-   void (*cl_foreach_close) (SLtype, SLang_Foreach_Context_Type *);
-   int (*cl_foreach) (SLtype, SLang_Foreach_Context_Type *);
-
-   /* Structure access: get and put (assign to) fields */
-   int (*cl_sput) (SLtype, char *);
-   int (*cl_sget) (SLtype, char *);
-
-   /* File I/O */
-   int (*cl_fread) (SLtype, FILE *, VOID_STAR, unsigned int, unsigned int *);
-   int (*cl_fwrite) (SLtype, FILE *, VOID_STAR, unsigned int, unsigned int *);
-   int (*cl_fdread) (SLtype, int, VOID_STAR, unsigned int, unsigned int *);
-   int (*cl_fdwrite) (SLtype, int, VOID_STAR, unsigned int, unsigned int *);
-
-   int (*cl_to_bool) (SLtype, int *);
-   
-   int (*cl_cmp)(SLtype, VOID_STAR, VOID_STAR, int *);   
-   int (*cl_eqs)(SLtype, VOID_STAR, SLtype, VOID_STAR);
-   SL_OOBinary_Type *cl_void_binary_this;
-   SL_OOBinary_Type *cl_this_binary_void;
-   int is_container;
-};
-
-extern int _pSLregister_types (void);
-extern SLang_Class_Type *_pSLclass_get_class (SLtype);
-extern VOID_STAR _pSLclass_get_ptr_to_value (SLang_Class_Type *, SLang_Object_Type *);
-extern void _pSLclass_type_mismatch_error (SLtype, SLtype);
-extern int _pSLclass_init (void);
-extern int _pSLclass_copy_class (SLtype, SLtype);
-
-extern int (*_pSLclass_get_typecast (SLtype, SLtype, int))
-(SLtype, VOID_STAR, unsigned int,
- SLtype, VOID_STAR);
-
-extern int (*_pSLclass_get_binary_fun (int, SLang_Class_Type *, SLang_Class_Type *, SLang_Class_Type **, int))
-(int,
- SLtype, VOID_STAR, unsigned int,
- SLtype, VOID_STAR, unsigned int,
- VOID_STAR);
-
-extern int (*_pSLclass_get_unary_fun (int, SLang_Class_Type *, SLang_Class_Type **, int))
-(int, SLtype, VOID_STAR, unsigned int, VOID_STAR);
-
-#if 0
-extern int _pSLclass_add_arith_unary_op (SLtype type,
-					int (*f)(int,
-						 SLtype, VOID_STAR, unsigned int,
-						 VOID_STAR),
-					int (*r)(int, SLtype, SLtype *));
-#endif
-
-extern int _pSLclass_get_unary_opcode (char *name);
-extern int _pSLclass_get_binary_opcode (char *name);
-extern int _pSLclass_is_same_obj (SLang_Object_Type *a, SLang_Object_Type *b);
-extern int _pSLclass_obj_eqs (SLang_Object_Type *a, SLang_Object_Type *b);
-
-extern int _pSLarith_register_types (void);
-extern SLtype _pSLarith_Arith_Types [];
-
-extern int _pSLang_ref_is_callable (SLang_Ref_Type *);
-extern int _pSLang_is_arith_type (SLtype);
-extern void _pSLang_set_arith_type (SLtype, unsigned char);
-#if SLANG_OPTIMIZE_FOR_SPEED
-extern SLclass_Type _pSLang_get_class_type (SLtype);
-extern void _pSLang_set_class_info (SLtype, SLang_Class_Type *);
-#endif
-extern int _pSLarith_bin_op (SLang_Object_Type *, SLang_Object_Type *, int);
-
-extern int _pSLarray_add_bin_op (SLtype);
-
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-
-   int unary_op;
-}
-SLang_Arith_Unary_Type;
-extern int _pSLadd_arith_unary_table (SLang_Arith_Unary_Type *tbl, char *);
-
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-
-   int binary_op;
-}
-SLang_Arith_Binary_Type;
-extern int _pSLadd_arith_binary_table (SLang_Arith_Binary_Type *tbl, char *);
-
-extern int _pSLang_call_funptr (SLang_Name_Type *);
-extern void _pSLset_double_format (char *);
-extern SLang_Name_Type *_pSLlocate_global_name (char *);
-extern SLang_Name_Type *_pSLlocate_name (char *);
-
-extern char *_pSLdefines[];
-
-#define SL_ERRNO_NOT_IMPLEMENTED	0x7FFF
-extern int _pSLerrno_errno;
-extern int _pSLerrno_init (void);
-
-extern int _pSLstdio_fdopen (char *, int, char *);
-
-extern void _pSLstruct_pop_args (int *);
-extern void _pSLstruct_push_args (SLang_Array_Type *);
-
-extern int _pSLang_init_sllist (void);
-extern int _pSLlist_inline_list (void);
-
-extern int _pSLarray_aput1 (unsigned int);
-extern int _pSLarray_aput (void);
-extern int _pSLarray_aget (void);
-extern int _pSLarray_aget1 (unsigned int);
-extern int _pSLarray_inline_implicit_array (void);
-extern int _pSLarray_inline_array (void);
-extern int _pSLarray_wildcard_array (void);
-
-extern int
-_pSLarray_typecast (SLtype, VOID_STAR, unsigned int,
-		   SLtype, VOID_STAR, int);
-
-extern int _pSLarray_aput_transfer_elem (SLang_Array_Type *, SLindex_Type *,
-					VOID_STAR, size_t, int);
-extern int _pSLarray_aget_transfer_elem (SLang_Array_Type *, SLindex_Type *,
-					VOID_STAR, size_t, int);
-extern void _pSLarray_free_array_elements (SLang_Class_Type *, VOID_STAR, SLuindex_Type);
-
-extern SLang_Foreach_Context_Type *
-_pSLarray_cl_foreach_open (SLtype, unsigned int);
-extern void _pSLarray_cl_foreach_close (SLtype, SLang_Foreach_Context_Type *);
-extern int _pSLarray_cl_foreach (SLtype, SLang_Foreach_Context_Type *);
-
-extern int _pSLarray_matrix_multiply (void);
-extern void (*_pSLang_Matrix_Multiply)(void);
-
-extern int _pSLarray_next_index (SLindex_Type *, SLindex_Type *, unsigned int);
-
-extern int _pSLarray_init_slarray (void);
-extern SLang_Array_Type *
-SLang_create_array1 (SLtype, int, VOID_STAR, SLindex_Type *, unsigned int, int);
-
-extern int _pSLassoc_aput (SLtype, unsigned int);
-extern int _pSLassoc_aget (SLtype, unsigned int);
-
-extern int _pSLcompile_push_context (SLang_Load_Type *);
-extern int _pSLcompile_pop_context (void);
-extern int _pSLang_Auto_Declare_Globals;
-
-typedef struct _pSLang_Token_Type
-{
-   union
-     {
-	long long_val;
-	unsigned long ulong_val;
-#if HAVE_LONG_LONG
-	long long llong_val;
-	unsigned long long ullong_val;
-#endif
-	/* Note that it is not wise to put a double field in the union because
-	 * when reading a preparsed file, I want to keep the user-specified
-	 * form to preserve the precision.  Using a union member would mean
-	 * converting the double to a string when creating a preparsed file.
-	 * We can avoid the issues associated with this by just storing 
-	 * floating point values as strings.
-	 */
-	char *s_val;		       /* Used for IDENT_TOKEN, DOUBLE_TOKEN, etc...  */
-	
-	SLang_BString_Type *b_val;
-     } v;
-   int free_sval_flag;
-   unsigned int num_refs;
-   unsigned long hash;
-#if SLANG_HAS_DEBUG_CODE
-   int line_number;
-#endif
-   struct _pSLang_Token_Type *next;     /* used for token lists */
-   SLtype type;
-}
-_pSLang_Token_Type;
-
-extern void _pSLcompile (_pSLang_Token_Type *);
-extern void (*_pSLcompile_ptr)(_pSLang_Token_Type *);
-
-/* slmisc.c */
-extern char *_pSLskip_whitespace (char *s);
-
-/* slospath.c */
-extern char *_pSLpath_find_file (char *);   /* slstring returned */
-
-/* Read but do not set this variable. */
-extern volatile int _pSLang_Error;
-
-extern int _pSLutf8_mode;
-extern int _pSLinterp_UTF8_Mode;	       /* non-zero for interpreter */
-extern int _pSLtt_UTF8_Mode;
-
-extern SLuchar_Type *_pSLinterp_decode_wchar (SLuchar_Type *u, 
-					     SLuchar_Type *umax, 
-					     SLwchar_Type *chp);
-
-extern SLuchar_Type *_pSLinterp_encode_wchar (SLwchar_Type wch, 
-					     SLuchar_Type *buf,
-					     unsigned int *encoded_lenp);
-
-/* *** TOKENS *** */
-
-/* Note that that tokens corresponding to ^J, ^M, and ^Z should not be used.
- * This is because a file that contains any of these characters will
- * have an OS dependent interpretation, e.g., ^Z is EOF on MSDOS.
- */
-
-/* Special tokens */
-#define ILLEGAL_TOKEN	0x00	       /* no token has this value */
-#define EOF_TOKEN	0x01
-#define RPN_TOKEN	0x02
-#define NL_TOKEN	0x03
-#define NOP_TOKEN	0x05
-#define FARG_TOKEN	0x06
-#define TMP_TOKEN	0x07
-
-#define RESERVED1_TOKEN	0x0A	       /* \n */
-#define RESERVED2_TOKEN	0x0D	       /* \r */
-
-/* Literal tokens */
-#define CHAR_TOKEN	0x10
-#define UCHAR_TOKEN	0x11
-#define SHORT_TOKEN	0x12
-#define USHORT_TOKEN	0x13
-#define INT_TOKEN	0x14
-#define UINT_TOKEN	0x15
-#define LONG_TOKEN	0x16
-#define ULONG_TOKEN	0x17
-#define IS_INTEGER_TOKEN(x) ((x >= CHAR_TOKEN) && (x <= ULONG_TOKEN))
-#define FLOAT_TOKEN	0x18
-#define DOUBLE_TOKEN	0x19
-#define RESERVED3_TOKEN	0x1A	       /* ^Z */
-#define COMPLEX_TOKEN	0x1B
-#define STRING_TOKEN    0x1C
-#define BSTRING_TOKEN	0x1D
-#define _BSTRING_TOKEN	0x1E	       /* byte-compiled BSTRING */
-#define STRING_DOLLAR_TOKEN	0x1F
-
-/* Tokens that can be LVALUES */
-#define IDENT_TOKEN	0x20
-#define ARRAY_TOKEN	0x21
-#define DOT_TOKEN	0x22
-#define IS_LVALUE_TOKEN (((t) <= DOT_TOKEN) && ((t) >= IDENT_TOKEN))
-#define DOT_METHOD_CALL_TOKEN		0x23
-
-#define ESC_STRING_TOKEN	0x24
-#define ESC_BSTRING_TOKEN	0x25
-
-/* Flags for struct fields */
-#define STATIC_TOKEN	0x26
-#define READONLY_TOKEN	0x27
-#define PRIVATE_TOKEN	0x28
-#define PUBLIC_TOKEN	0x29
-
-/* Punctuation tokens */
-#define OBRACKET_TOKEN	0x2a
-#define CBRACKET_TOKEN	0x2b
-#define OPAREN_TOKEN	0x2c
-#define CPAREN_TOKEN	0x2d
-#define OBRACE_TOKEN	0x2e
-#define CBRACE_TOKEN	0x2f
-
-#define COMMA_TOKEN	0x31
-#define SEMICOLON_TOKEN	0x32
-#define COLON_TOKEN	0x33
-#define NAMESPACE_TOKEN	0x34
-
-/* Operators */
-#define POW_TOKEN	0x38
-
-/* The order here must match the order in the Binop_Level table in slparse.c */
-#define FIRST_BINARY_OP	0x39
-#define ADD_TOKEN	0x39
-#define SUB_TOKEN	0x3a
-#define TIMES_TOKEN	0x3b
-#define DIV_TOKEN	0x3c
-#define LT_TOKEN	0x3d
-#define LE_TOKEN	0x3e
-#define GT_TOKEN	0x3f
-#define GE_TOKEN	0x40
-#define EQ_TOKEN	0x41
-#define NE_TOKEN	0x42
-#define AND_TOKEN	0x43
-#define OR_TOKEN	0x44
-#define MOD_TOKEN	0x45
-#define BAND_TOKEN	0x46
-#define SHL_TOKEN	0x47
-#define SHR_TOKEN	0x48
-#define BXOR_TOKEN	0x49
-#define BOR_TOKEN	0x4a
-#define POUND_TOKEN	0x4b	       /* matrix multiplication */
-
-#define LAST_BINARY_OP	 0x4b
-#define IS_BINARY_OP(t)	 ((t >= FIRST_BINARY_OP) && (t <= LAST_BINARY_OP))
-
-/* unary tokens -- but not all of them (see grammar) */
-#define DEREF_TOKEN	 0x4d
-#define NOT_TOKEN	 0x4e
-#define BNOT_TOKEN	 0x4f
-
-#define IS_INTERNAL_FUNC(t)	((t >= 0x50) && (t <= 0x52))
-#define POP_TOKEN	 0x50
-#define CHS_TOKEN	 0x51
-#define EXCH_TOKEN	 0x52
-
-#define LLONG_TOKEN	0x53
-#define ULLONG_TOKEN	0x54
-#define LDOUBLE_TOKEN	0x55
-
-/* Assignment tokens.  Note: these must appear with sequential values.
- * The order here must match the specific lvalue assignments below.
- * These tokens are used by rpn routines in slang.c.  slparse.c maps them
- * onto the specific lvalue tokens while parsing infix.
- * Also the assignment SLANG_BCST_ assumes this order
- */
-#define ASSIGN_TOKEN		0x57
-#define PLUSEQS_TOKEN	 	0x58
-#define MINUSEQS_TOKEN		0x59
-#define TIMESEQS_TOKEN		0x5A
-#define DIVEQS_TOKEN		0x5B
-#define BOREQS_TOKEN		0x5C
-#define BANDEQS_TOKEN		0x5D
-#define PLUSPLUS_TOKEN		0x5E
-#define POST_PLUSPLUS_TOKEN	0x5F
-#define MINUSMINUS_TOKEN	0x60
-#define POST_MINUSMINUS_TOKEN	0x61
-
-/* Directives */
-#define FIRST_DIRECTIVE_TOKEN	0x62
-#define IFNOT_TOKEN	0x62
-#define IF_TOKEN	0x63
-#define ELSE_TOKEN	0x64
-#define FOREVER_TOKEN	0x65
-#define WHILE_TOKEN	0x66
-#define FOR_TOKEN	0x67
-#define _FOR_TOKEN	0x68
-#define LOOP_TOKEN	0x69
-#define SWITCH_TOKEN	0x6A
-#define DOWHILE_TOKEN	0x6B
-#define ANDELSE_TOKEN	0x6C
-#define ORELSE_TOKEN	0x6D
-#define ERRBLK_TOKEN	0x6E
-#define EXITBLK_TOKEN	0x6F
-/* These must be sequential */
-#define USRBLK0_TOKEN	0x70
-#define USRBLK1_TOKEN	0x71
-#define USRBLK2_TOKEN	0x72
-#define USRBLK3_TOKEN	0x73
-#define USRBLK4_TOKEN	0x74
-
-#define CONT_TOKEN	0x75
-#define BREAK_TOKEN	0x76
-#define RETURN_TOKEN	0x77
-
-#define CASE_TOKEN	0x78
-#define DEFINE_TOKEN	0x79
-#define DO_TOKEN	0x7a
-#define VARIABLE_TOKEN	0x7b
-#define GVARIABLE_TOKEN	0x7c
-#define _REF_TOKEN	0x7d
-#define PUSH_TOKEN	0x7e
-#define STRUCT_TOKEN	0x7f
-#define TYPEDEF_TOKEN	0x80
-#define NOTELSE_TOKEN	0x81
-#define DEFINE_STATIC_TOKEN	0x82
-#define FOREACH_TOKEN	0x83
-#define USING_TOKEN	0x84
-#define DEFINE_PRIVATE_TOKEN	0x85
-#define DEFINE_PUBLIC_TOKEN	0x86
-
-#define TRY_TOKEN	0x87
-#define CATCH_TOKEN	0x88
-#define THROW_TOKEN	0x89
-#define FINALLY_TOKEN	0x8a
-
-/* Note: the order here must match the order of the generic assignment tokens.
- * Also, the first token of each group must be the ?_ASSIGN_TOKEN.
- * slparse.c exploits this order, as well as slang.h.
- */
-#define FIRST_ASSIGN_TOKEN		0x90
-#define _STRUCT_ASSIGN_TOKEN		0x90
-#define _STRUCT_PLUSEQS_TOKEN		0x91
-#define _STRUCT_MINUSEQS_TOKEN		0x92
-#define _STRUCT_TIMESEQS_TOKEN		0x93
-#define _STRUCT_DIVEQS_TOKEN		0x94
-#define _STRUCT_BOREQS_TOKEN		0x95
-#define _STRUCT_BANDEQS_TOKEN		0x96
-#define _STRUCT_PLUSPLUS_TOKEN		0x97
-#define _STRUCT_POST_PLUSPLUS_TOKEN	0x98
-#define _STRUCT_MINUSMINUS_TOKEN	0x99
-#define _STRUCT_POST_MINUSMINUS_TOKEN	0x9A
-
-#define _ARRAY_ASSIGN_TOKEN		0xA0
-#define _ARRAY_PLUSEQS_TOKEN		0xA1
-#define _ARRAY_MINUSEQS_TOKEN		0xA2
-#define _ARRAY_TIMESEQS_TOKEN		0xA3
-#define _ARRAY_DIVEQS_TOKEN		0xA4
-#define _ARRAY_BOREQS_TOKEN		0xA5
-#define _ARRAY_BANDEQS_TOKEN		0xA6
-#define _ARRAY_PLUSPLUS_TOKEN		0xA7
-#define _ARRAY_POST_PLUSPLUS_TOKEN	0xA8
-#define _ARRAY_MINUSMINUS_TOKEN		0xA9
-#define _ARRAY_POST_MINUSMINUS_TOKEN	0xAA
-
-#define _SCALAR_ASSIGN_TOKEN		0xB0
-#define _SCALAR_PLUSEQS_TOKEN		0xB1
-#define _SCALAR_MINUSEQS_TOKEN		0xB2
-#define _SCALAR_TIMESEQS_TOKEN		0xB3
-#define _SCALAR_DIVEQS_TOKEN		0xB4
-#define _SCALAR_BOREQS_TOKEN		0xB5
-#define _SCALAR_BANDEQS_TOKEN		0xB6
-#define _SCALAR_PLUSPLUS_TOKEN		0xB7
-#define _SCALAR_POST_PLUSPLUS_TOKEN	0xB8
-#define _SCALAR_MINUSMINUS_TOKEN	0xB9
-#define _SCALAR_POST_MINUSMINUS_TOKEN	0xBA
-
-#define _DEREF_ASSIGN_TOKEN		0xC0
-#define _DEREF_PLUSEQS_TOKEN		0xC1
-#define _DEREF_MINUSEQS_TOKEN		0xC2
-#define _DEREF_TIMESEQS_TOKEN		0xC3
-#define _DEREF_DIVEQS_TOKEN		0xC4
-#define _DEREF_BOREQS_TOKEN		0xC5
-#define _DEREF_BANDEQS_TOKEN		0xC6
-#define _DEREF_PLUSPLUS_TOKEN		0xC7
-#define _DEREF_POST_PLUSPLUS_TOKEN	0xC8
-#define _DEREF_MINUSMINUS_TOKEN		0xC9
-#define _DEREF_POST_MINUSMINUS_TOKEN	0xCA
-
-#define LAST_ASSIGN_TOKEN		0xCA
-#define IS_ASSIGN_TOKEN(t) (((t)>=FIRST_ASSIGN_TOKEN)&&((t)<=LAST_ASSIGN_TOKEN))
-
-#define _INLINE_ARRAY_TOKEN		0xE0
-#define _INLINE_IMPLICIT_ARRAY_TOKEN	0xE1
-#define _NULL_TOKEN			0xE2
-#define _INLINE_WILDCARD_ARRAY_TOKEN	0xE3
-#define _INLINE_LIST_TOKEN		0xE4
-
-#define BOS_TOKEN			0xFA
-#define EOS_TOKEN			0xFB
-#define LINE_NUM_TOKEN			0xFC
-#define ARG_TOKEN	 		0xFD
-#define EARG_TOKEN	 		0xFE
-#define NO_OP_LITERAL			0xFF
-
-typedef struct
-{
-   /* sltoken.c */
-   /* SLang_eval_object */
-   SLang_Load_Type *llt;
-   SLprep_Type *this_slpp;
-   /* prep_get_char() */
-   char *input_line;
-   char cchar;
-   /* get_token() */
-   int want_nl_token;
-
-   /* slparse.c */
-   _pSLang_Token_Type ctok;
-   int block_depth;
-   int assignment_expression;
-
-   /* slang.c : SLcompile() */
-   _pSLang_Token_Type save_token;
-   _pSLang_Token_Type next_token;
-   void (*slcompile_ptr)(_pSLang_Token_Type *);
-}
-_pSLEval_Context;
-
-extern int _pSLget_token (_pSLang_Token_Type *);
-extern void _pSLparse_error (int, char *, _pSLang_Token_Type *, int);
-extern void _pSLparse_start (SLang_Load_Type *);
-extern int _pSLget_rpn_token (_pSLang_Token_Type *);
-extern void _pSLcompile_byte_compiled (void);
-
-extern int (*_pSLprep_eval_hook) (char *);
-
-extern int _pSLsecure_issetugid (void);
-extern char *_pSLsecure_getenv (char *);
-
-/* Error Handling */
-extern int _pSLang_init_exceptions (void);
-extern int _pSLerr_init (void);
-extern void _pSLerr_deinit (void);
-extern int _pSLerr_suspend_messages (void);
-extern int _pSLerr_resume_messages (void);
-extern int _pSLerr_traceback_msg (char *, ...) SLATTRIBUTE_PRINTF(1,2);
-extern void _pSLerr_dump_msg (char *, ...) SLATTRIBUTE_PRINTF(1,2);
-extern void _pSLerr_clear_error (void);
-extern void _pSLerr_print_message_queue (void);
-
-extern int _pSLerr_set_line_info (char *, int, char *);
-extern int _pSLang_pop_error_context (void);
-extern int _pSLang_push_error_context (void);
-extern void (*_pSLinterpreter_Error_Hook)(int);
-extern int _pSLerr_init_interp_exceptions (void);
-extern int _pSLerr_get_last_error (void);
-extern int _pSLerr_pop_exception (int *);
-extern void _pSLerr_free_queued_messages (void);
-extern char *_pSLerr_get_error_from_queue (void);
-extern int _pSLerr_throw (void);
-extern int (*_pSLerr_New_Exception_Hook)(char *name, char *desc, int error_code);
-
-#if SLANG_HAS_DEBUGGER_SUPPORT
-typedef struct
-{
-   char **locals;
-   unsigned int nlocals;
-   char *file;
-   unsigned int line;
-   char *function;
-   char *ns;
-}
-_pSLang_Frame_Info_Type;
-
-extern int _pSLang_get_frame_fun_info (int depth, _pSLang_Frame_Info_Type *info);
-extern int _pSLang_set_frame_variable (int depth, char *name);
-extern int _pSLang_get_frame_variable (int depth, char *name);
-extern void _pSLang_use_frame_namespace (int depth);
-extern int _pSLang_get_frame_depth (void);
-#endif
-
-#if SLANG_HAS_FLOAT
-extern int _pSLmath_isnan (double x);
-#endif
-
-#if SLANG_HAS_SIGNALS
-extern void _pSLang_signal_interrupt (void);
-extern int _pSLsig_block_and_call (int (*)(VOID_STAR), VOID_STAR);
-extern int _pSLsig_handle_signals (void);
-extern int _pSLang_check_signals_hook (VOID_STAR);
-#else
-#define _pSLsig_block_and_call(f,v) f(v)
-#endif
-
-#undef _INLINE_
-#if defined(__GNUC__) && SLANG_USE_INLINE_CODE
-# define _INLINE_ __inline__
-#else
-# define _INLINE_
-#endif
-
-/* This is a macro that permits:
- *
- *   extern fun (void **addr);
- *   double x;
- *   fun ((void **) &x);   <--- warning
- *   fun (VOID_STAR_STAR(&x)); 
- * 
- * Otherwise a type-punning warning could result due to strict-aliasing.
- */
-#define VOID_STAR_STAR(addr) (VOID_STAR *)(VOID_STAR)(addr)
-
-#endif				       /* PRIVATE_SLANG_H_ */
diff --git a/slang/include/jdmacros.h b/slang/include/jdmacros.h
deleted file mode 100644
index ee5cced..0000000
--- a/slang/include/jdmacros.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* Fully rewritten to use glib rather than S-Lang replacements */
-
-#ifndef _JD_MACROS_H_
-#define _JD_MACROS_H_
-
-#include <glib.h>
-
-#define SLMEMSET(x,y,z) memset(x,y,z)
-#define SLMEMCPY(x,y,z) memcpy(x,y,z)
-#define SLfree(x) g_free(x)
-#define SLmalloc(x) g_malloc(x)
-#define SLrealloc(x,y) g_realloc(x,y)
-#define SLvsnprintf g_vsnprintf
-
-#endif				/* _JD_MACROS_H_ */
diff --git a/slang/include/sl-feat.h b/slang/include/sl-feat.h
deleted file mode 100644
index d6cf4bb..0000000
--- a/slang/include/sl-feat.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* Setting this to one permits strings with embedded color changing commands.
- * This is experimental.
- */
-#define SLSMG_HAS_EMBEDDED_ESCAPE	1
-
-/* Setting this to 1 enables automatic support for associative arrays.
- * If this is set to 0, an application must explicitly enable associative
- * array support via SLang_init_slassoc.
- */
-#define SLANG_HAS_ASSOC_ARRAYS		1
-
-#define SLANG_HAS_COMPLEX		1
-#define SLANG_HAS_FLOAT			1
-
-/* This is the old space-speed trade off.  To reduce memory usage and code
- * size, set this to zero.
- */
-/* #define SLANG_OPTIMIZE_FOR_SPEED	0 */ 
-#define SLANG_OPTIMIZE_FOR_SPEED	2
-
-#define SLANG_USE_INLINE_CODE		1
-
-/* Add extra information for tracking down errors. */
-#define SLANG_HAS_DEBUG_CODE		1
-
-/* Experimental: Support for examining call frames */
-#define SLANG_HAS_DEBUGGER_SUPPORT	1
-
-/* Allow optimizations based upon the __tmp operator. */
-#define SLANG_USE_TMP_OPTIMIZATION	1
-
-/* Setting this to one will map 8 bit vtxxx terminals to 7 bit.  Terminals
- * such as the vt320 can be set up to output the two-character escape sequence
- * encoded as 'ESC [' as single character.  Setting this variable to 1 will
- * insert code to map such characters to the 7 bit equivalent.
- * This affects just input characters in the range 128-160 on non PC
- * systems.
- */
-#if defined(VMS) || defined(AMIGA)
-# define SLANG_MAP_VTXXX_8BIT	1
-#else
-# define SLANG_MAP_VTXXX_8BIT	0
-#endif
-
-/* Add support for color terminals that cannot do background color erases
- * Such terminals are poorly designed and are slowly disappearing but they
- * are still quite common.  For example, screen is one of them!
- * 
- * This is experimental.  In particular, it is not known to work if 
- * KANJI suupport is enabled.
- */
-#if !defined(IBMPC_SYSTEM)
-# define SLTT_HAS_NON_BCE_SUPPORT	1
-#else
-# define SLTT_HAS_NON_BCE_SUPPORT	0
-#endif
-
-/* If you want slang to assume that an xterm always has the background color
- * erase feature, then set this to 1.  Otherwise, it will check the terminfo
- * database.  This may or may not be a good idea since most good color xterms
- * support bce but many terminfo systems do not support it.
- */
-#define SLTT_XTERM_ALWAYS_BCE		0
-  
-/* Set this to 1 to enable Kanji support.  See above comment. */
-#define SLANG_HAS_KANJI_SUPPORT		0
-
-#define SLANG_HAS_SIGNALS		1
-
-/* Enable this if you want beginning-of-statement and end-of-statement 
- * callbacks.  This allows the creation of profilers, stack-checkers, etc.
- * SLANG_HAS_DEBUG_CODE must be enabled for this to work.
- */
-#define SLANG_HAS_BOSEOS	SLANG_HAS_DEBUG_CODE
diff --git a/slang/include/slang.h b/slang/include/slang.h
deleted file mode 100644
index e9b72e4..0000000
--- a/slang/include/slang.h
+++ /dev/null
@@ -1,2378 +0,0 @@
-#ifndef DAVIS_SLANG_H_
-#define DAVIS_SLANG_H_
-/* -*- mode: C; mode: fold; -*- */
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-#define SLANG_VERSION 20006
-#define SLANG_VERSION_STRING "2.0.6"
-/* #ifdef __DATE__ */
-/* # define SLANG_VERSION_STRING SLANG_VERSION_STRING0 " " __DATE__ */
-/* #else */
-/* # define SLANG_VERSION_STRING SLANG_VERSION_STRING0 */
-/* #endif */
-/*{{{ System Dependent Macros and Typedefs */
-
-#if defined(__WATCOMC__) && defined(DOS)
-# ifndef __MSDOS__
-#  define __MSDOS__
-# endif
-# ifndef  DOS386
-#  define  DOS386
-# endif
-# ifndef IBMPC_SYSTEM
-#  define IBMPC_SYSTEM
-# endif
-#endif /* __watcomc__ */
-
-#if defined(unix) || defined(__unix) || defined (_AIX) || defined(__NetBSD__) || defined(__MACH__)
-# ifndef __unix__
-#  define __unix__ 1
-# endif
-#endif
-
-#if !defined(__GO32__)
-# ifdef __unix__
-#  define REAL_UNIX_SYSTEM
-# endif
-#endif
-
-/* Set of the various defines for pc systems.  This includes OS/2 */
-#ifdef __GO32__
-# ifndef __DJGPP__
-#  define __DJGPP__ 1
-# endif
-# ifndef IBMPC_SYSTEM
-#   define IBMPC_SYSTEM
-# endif
-#endif
-
-#ifdef __BORLANDC__
-# ifndef IBMPC_SYSTEM
-#  define IBMPC_SYSTEM
-# endif
-#endif
-
-#ifdef __MSDOS__
-# ifndef IBMPC_SYSTEM
-#   define IBMPC_SYSTEM
-# endif
-#endif
-
-#if defined(OS2) || defined(__os2__)
-# ifndef IBMPC_SYSTEM
-#   define IBMPC_SYSTEM
-# endif
-# ifndef __os2__
-#  define __os2__
-# endif
-#endif
-
-#if defined(__NT__) || defined(__MINGW32__) /* || defined(__CYGWIN32__) */
-# ifndef IBMPC_SYSTEM
-#  define IBMPC_SYSTEM
-# endif
-#endif
-
-#if defined(WIN32) || defined(__WIN32__)
-# ifndef IBMPC_SYSTEM
-#  define IBMPC_SYSTEM
-# endif
-# ifndef __WIN32__
-#  define __WIN32__
-# endif
-#endif
-
-#if defined(IBMPC_SYSTEM) || defined(VMS)
-# ifdef REAL_UNIX_SYSTEM
-#  undef REAL_UNIX_SYSTEM
-# endif
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-#if 0
-}
-#endif
-
-#include <stdio.h>
-#include <stdarg.h>
-#if defined(__STDC__) || defined(__BORLANDC__) || defined(__cplusplus)
-# include <stddef.h>		       /* for offsetof */
-#endif
-
-#ifdef SIZEOF_SHORT
-# define SLANG_SIZEOF_SHORT SIZEOF_SHORT
-#endif
-#ifdef SIZEOF_INT
-# define SLANG_SIZEOF_INT SIZEOF_INT
-#endif
-#ifdef SIZEOF_FLOAT
-# define SLANG_SIZEOF_FLOAT SIZEOF_FLOAT
-#endif
-#ifdef SIZEOF_DOUBLE
-# define SLANG_SIZEOF_DOUBLE SIZEOF_DOUBLE
-#endif
-
-#if !defined(SIZEOF_SHORT) || !defined(SIZEOF_INT) || !defined(SIZEOF_LONG) || !defined(SIZEOF_FLOAT) || !defined(SIZEOF_DOUBLE)
-# include <limits.h>
-# if !defined(SIZEOF_SHORT) && defined(SHRT_MAX)
-#  if SHRT_MAX == 32767
-#   define SLANG_SIZEOF_SHORT 2
-#  else
-#   if SHRT_MAX == 2147483647L
-#    define SLANG_SIZEOF_SHORT 4
-#   endif
-#  endif
-# endif
-# if !defined(SIZEOF_INT) && defined(INT_MAX)
-#  if INT_MAX == 32767
-#   define SLANG_SIZEOF_INT 2
-#  else
-#   if INT_MAX == 2147483647L
-#    define SLANG_SIZEOF_INT 4
-#   endif
-#  endif
-# endif
-# if !defined(SIZEOF_LONG) && defined(LONG_MAX)
-#  if LONG_MAX == 32767
-#   define SLANG_SIZEOF_LONG 2
-#  else
-#   if LONG_MAX == 2147483647L
-#    define SLANG_SIZEOF_LONG 4
-#   else
-#    define SLANG_SIZEOF_LONG 8
-#   endif
-#  endif
-# endif
-#endif
-
-#ifndef SLANG_SIZEOF_SHORT
-# define SLANG_SIZEOF_SHORT 2
-#endif
-#ifndef SLANG_SIZEOF_INT
-# define SLANG_SIZEOF_INT 4
-#endif
-#ifndef SLANG_SIZEOF_LONG
-# define SLANG_SIZEOF_LONG 4
-#endif
-#ifndef SLANG_SIZEOF_FLOAT
-# define SLANG_SIZEOF_FLOAT 4
-#endif
-#ifndef SLANG_SIZEOF_DOUBLE
-# define SLANG_SIZEOF_DOUBLE 8
-#endif
-
-/* ---------------------------- Generic Macros ----------------------------- */
-
-/*  __SC__ is defined for Symantec C++
-   DOS386 is defined for -mx memory model, 32 bit DOS extender. */
-
-#if defined(__SC__) && !defined(DOS386)
-# include <dos.h>
-#endif
-
-#if defined(__BORLANDC__)
-# include <alloc.h>
-#endif
-
-#ifdef __GNUC__
-# define SLATTRIBUTE_(x) __attribute__ (x)
-#else
-# define SLATTRIBUTE_(x)
-#endif
-#define SLATTRIBUTE_PRINTF(a,b) SLATTRIBUTE_((format(printf,a,b)))
-  
-#if defined (__cplusplus) || defined(__STDC__) || defined(IBMPC_SYSTEM)
-typedef void *VOID_STAR;
-#define SLCONST const
-#else
-typedef unsigned char *VOID_STAR;
-#define SLCONST
-#endif
-
-typedef int (*FVOID_STAR)(void);
-
-#if defined(__MSDOS__) && defined(__BORLANDC__)
-# define SLFREE(buf)  farfree((void far *)(buf))
-# define SLMALLOC(x) farmalloc((unsigned long) (x))
-# define SLREALLOC(buf, n) farrealloc((void far *) (buf), (unsigned long) (n))
-# define SLCALLOC(n, m) farcalloc((unsigned long) (n), (unsigned long) (m))
-#else
-# if defined(VMS) && !defined(__DECC)
-#  define SLFREE VAXC$FREE_OPT
-#  define SLMALLOC VAXC$MALLOC_OPT
-#  define SLREALLOC VAXC$REALLOC_OPT
-#  define SLCALLOC VAXC$CALLOC_OPT
-# else
-#  define SLFREE(x) free((char *)(x))
-#  define SLMALLOC malloc
-#  define SLREALLOC realloc
-#  define SLCALLOC calloc
-# endif
-#endif
-
-#if defined(__WIN32__) && SLANG_DLL
-# define SL_EXPORT __declspec(dllexport)
-# define SL_IMPORT __declspec(dllimport)
-#else
-# define SL_EXPORT
-# define SL_IMPORT
-#endif
-#ifdef SLANG_SOURCE_
-# define SL_EXTERN extern SL_EXPORT
-#else
-# define SL_EXTERN extern SL_IMPORT
-#endif
-
-SL_EXTERN char *SLdebug_malloc (unsigned long);
-SL_EXTERN char *SLdebug_calloc (unsigned long, unsigned long);
-SL_EXTERN char *SLdebug_realloc (char *, unsigned long);
-SL_EXTERN void SLdebug_free (char *);
-SL_EXTERN void SLmalloc_dump_statistics (void);
-SL_EXTERN char *SLstrcpy(register char *, register char *);
-SL_EXTERN int SLstrcmp(register char *, register char *);
-SL_EXTERN char *SLstrncpy(char *, register char *, register  int);
-
-/* GNU Midnight Commander uses replacements from glib */
-#define MIDNIGHT_COMMANDER_CODE 1
-#ifndef MIDNIGHT_COMMANDER_CODE
-
-SL_EXTERN void SLmemset (char *, char, int);
-SL_EXTERN char *SLmemchr (register char *, register char, register int);
-SL_EXTERN char *SLmemcpy (char *, char *, int);
-SL_EXTERN int SLmemcmp (char *, char *, int);
-
-#endif                                /* !MIDNIGHT_COMMANDER_CODE */
-
-/*}}}*/
-
-/* SLstrings */
-typedef char SLstr_Type;
-/* An SLstr_Type object must be treated as a constant and may only be freed
- * by the SLang_free_slstring function and nothing else.
- */
-SL_EXTERN SLstr_Type *SLang_create_nslstring (char *, unsigned int);
-SL_EXTERN SLstr_Type *SLang_create_slstring (char *);
-SL_EXTERN void SLang_free_slstring (SLstr_Type *);    /* handles NULL */
-SL_EXTERN int SLang_pop_slstring (SLstr_Type **);   /* free with SLang_free_slstring */
-SL_EXTERN SLstr_Type *SLang_concat_slstrings (SLstr_Type *a, SLstr_Type *b);
-
-SL_EXTERN void SLstring_dump_stats (void);
-
-
-/*{{{ UTF-8 and Wide Char support */
-
-#if SLANG_SIZEOF_INT == 4
-typedef unsigned int SLwchar_Type;
-# define SLANG_WCHAR_TYPE SLANG_UINT_TYPE
-#else
-typedef unsigned long SLwchar_Type;
-# define SLANG_WCHAR_TYPE SLANG_ULONG_TYPE
-#endif
-typedef unsigned char SLuchar_Type;
-
-/* Maximum multi-byte len for a unicode wchar */
-#define SLUTF8_MAX_MBLEN	6
-
-/* If argument is 1, force UTF-8 mode on.  If argument is 0, force mode off.
- * If -1, determine mode from the locale.
- * Returns 1 if enabled, 0 if not.
- */
-SL_EXTERN int SLutf8_enable (int);
-SL_EXTERN int SLutf8_is_utf8_mode (void);
-SL_EXTERN int SLtt_utf8_enable (int);
-SL_EXTERN int SLtt_is_utf8_mode (void);
-SL_EXTERN int SLsmg_utf8_enable (int);
-SL_EXTERN int SLsmg_is_utf8_mode (void);
-SL_EXTERN int SLinterp_utf8_enable (int);
-SL_EXTERN int SLinterp_is_utf8_mode (void);
-  
-SL_EXTERN SLwchar_Type SLwchar_toupper (SLwchar_Type);
-SL_EXTERN SLwchar_Type SLwchar_tolower (SLwchar_Type);
-
-SL_EXTERN int SLwchar_wcwidth (SLwchar_Type);
-SL_EXTERN int SLwchar_isalnum (SLwchar_Type);
-SL_EXTERN int SLwchar_isalpha (SLwchar_Type);
-SL_EXTERN int SLwchar_isblank (SLwchar_Type);
-SL_EXTERN int SLwchar_iscntrl (SLwchar_Type);
-SL_EXTERN int SLwchar_isdigit (SLwchar_Type);
-SL_EXTERN int SLwchar_isgraph (SLwchar_Type);
-SL_EXTERN int SLwchar_islower (SLwchar_Type);
-SL_EXTERN int SLwchar_isprint (SLwchar_Type);
-SL_EXTERN int SLwchar_ispunct (SLwchar_Type);
-SL_EXTERN int SLwchar_isspace (SLwchar_Type);
-SL_EXTERN int SLwchar_isupper (SLwchar_Type);
-SL_EXTERN int SLwchar_isxdigit (SLwchar_Type);
-
-SL_EXTERN SLuchar_Type *SLutf8_skip_char (SLuchar_Type *u, SLuchar_Type *umax);
-SL_EXTERN SLuchar_Type *SLutf8_bskip_char (SLuchar_Type *umin, SLuchar_Type *u);
-
-/* The SLutf8_strup/lo functions return slstrings -- free with SLang_free_slstring */
-SL_EXTERN SLuchar_Type *SLutf8_strup (SLuchar_Type *u, SLuchar_Type *umax);
-SL_EXTERN SLuchar_Type *SLutf8_strlo (SLuchar_Type *u, SLuchar_Type *umax);
-
-SL_EXTERN SLuchar_Type *SLutf8_skip_chars (SLuchar_Type *u, SLuchar_Type *umax,
-					unsigned int num, unsigned int *dnum,
-					int ignore_combining );
-SL_EXTERN SLuchar_Type *SLutf8_bskip_chars (SLuchar_Type *umin, SLuchar_Type *u,
-					  unsigned int num, unsigned int *dnum,
-					 int ignore_combining);
-
-SL_EXTERN SLstr_Type *SLutf8_subst_wchar (SLuchar_Type *u, SLuchar_Type *umax,
-				       SLwchar_Type wch, unsigned int pos,
-				       int ignore_combining);
-
-
-SL_EXTERN unsigned int SLutf8_strlen (SLuchar_Type *s, int ignore_combining);
-SL_EXTERN SLuchar_Type *SLutf8_decode (SLuchar_Type *u, SLuchar_Type *umax,
-				     SLwchar_Type *w, unsigned int *nconsumedp);
-SL_EXTERN SLuchar_Type *SLutf8_encode (SLwchar_Type w, SLuchar_Type *u, unsigned int ulen);
-
-SL_EXTERN int SLutf8_compare (SLuchar_Type *a, SLuchar_Type *amax, 
-                           SLuchar_Type *b, SLuchar_Type *bmax,
-                           unsigned int nchars, int case_sensitive);
-
-/* In these functions, buf is assumed to contain at least SLUTF8_MAX_MBLEN+1 
- * bytes 
- */
-SL_EXTERN SLuchar_Type *SLutf8_extract_utf8_char (SLuchar_Type *u, SLuchar_Type *umax, SLuchar_Type *buf);
-SL_EXTERN SLuchar_Type *SLutf8_encode_null_terminate (SLwchar_Type w, SLuchar_Type *buf);
-
-
-typedef struct SLwchar_Lut_Type SLwchar_Lut_Type;
-SL_EXTERN SLwchar_Lut_Type *SLwchar_create_lut (unsigned int num_entries);
-SL_EXTERN int SLwchar_add_range_to_lut (SLwchar_Lut_Type *r, SLwchar_Type a, SLwchar_Type b);
-SL_EXTERN SLuchar_Type *SLwchar_skip_range (SLwchar_Lut_Type *r, SLuchar_Type *p,
-					 SLuchar_Type *pmax, int ignore_combining,
-					 int invert);
-SL_EXTERN SLwchar_Lut_Type *SLwchar_strtolut (SLuchar_Type *u, 
-					   int allow_range, int allow_charclass);
-SL_EXTERN void SLwchar_free_lut (SLwchar_Lut_Type *r);
-SL_EXTERN SLuchar_Type *SLwchar_bskip_range (SLwchar_Lut_Type *r, SLuchar_Type *pmin,
-					  SLuchar_Type *p,
-					  int ignore_combining,
-					  int invert);
-SL_EXTERN int SLwchar_in_lut (SLwchar_Lut_Type *r, SLwchar_Type wch);
-
-
-typedef struct SLwchar_Map_Type SLwchar_Map_Type;
-SL_EXTERN void SLwchar_free_char_map (SLwchar_Map_Type *map);
-SL_EXTERN SLwchar_Map_Type *SLwchar_allocate_char_map (SLuchar_Type *from, SLuchar_Type *to);
-SL_EXTERN int SLwchar_apply_char_map (SLwchar_Map_Type *map, SLwchar_Type *input, SLwchar_Type *output, unsigned int num);
-
-/* This function returns a malloced string */
-SLuchar_Type *SLuchar_apply_char_map (SLwchar_Map_Type *map, SLuchar_Type *str);
-
-
-/*}}}*/
-
-/*{{{ Interpreter Typedefs */
-
-typedef unsigned int SLtype;
-/* typedef unsigned short SLtype; */
-
-typedef struct _pSLang_Name_Type
-{
-   char *name;
-   struct _pSLang_Name_Type *next;
-   unsigned char name_type;
-   /* These values here map directly to byte codes.  See _slang.h.
-    */
-#define SLANG_LVARIABLE		0x01
-#define SLANG_GVARIABLE 	0x02
-#define SLANG_IVARIABLE 	0x03           /* intrinsic variables */
-   /* Note!!! For Macro MAKE_VARIABLE below to work, SLANG_IVARIABLE Must
-    be 1 less than SLANG_RVARIABLE!!! */
-#define SLANG_RVARIABLE		0x04	       /* read only variable */
-#define SLANG_INTRINSIC 	0x05
-#define SLANG_FUNCTION  	0x06
-#define SLANG_MATH_UNARY  	0x07
-#define SLANG_APP_UNARY  	0x08
-#define SLANG_ARITH_UNARY	0x09   /* private */
-#define SLANG_ARITH_BINARY	0x0A
-#define SLANG_ICONSTANT		0x0B
-#define SLANG_DCONSTANT		0x0C
-#define SLANG_FCONSTANT		0x0D
-#define SLANG_LLCONSTANT	0x0E
-#define SLANG_PVARIABLE		0x0F   /* private */
-#define SLANG_PFUNCTION		0x10   /* private */
-#define SLANG_HCONSTANT		0x11
-#define SLANG_LCONSTANT		0x12
-   /* Rest of fields depend on name type */
-}
-SLang_Name_Type;
-
-typedef struct
-{
-   char *name;
-   struct _pSLang_Name_Type *next;      /* this is for the hash table */
-   char name_type;
-
-   FVOID_STAR i_fun;		       /* address of object */
-
-   /* Do not change this without modifying slang.c:execute_intrinsic_fun */
-#define SLANG_MAX_INTRIN_ARGS	7
-   SLtype arg_types [SLANG_MAX_INTRIN_ARGS];
-   unsigned char num_args;
-   SLtype return_type;
-}
-SLang_Intrin_Fun_Type;
-
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-
-   VOID_STAR addr;
-   SLtype type;
-}
-SLang_Intrin_Var_Type;
-
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-
-   int unary_op;
-}
-SLang_App_Unary_Type;
-
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-
-   int unary_op;
-}
-SLang_Math_Unary_Type;
-
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-
-   SLtype data_type;
-   short value;
-}
-SLang_HConstant_Type;
-
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-
-   SLtype data_type;
-   int value;
-}
-SLang_IConstant_Type;
-
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-
-   SLtype data_type;
-   long value;
-}
-SLang_LConstant_Type;
-
-#ifdef HAVE_LONG_LONG
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-
-   long long ll;
-}
-SLang_LLConstant_Type;
-#endif
-
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-   double d;
-}
-SLang_DConstant_Type;
-
-typedef struct
-{
-   char *name;
-   SLang_Name_Type *next;
-   char name_type;
-   float f;
-}
-SLang_FConstant_Type;
-
-typedef struct
-{
-   char *field_name;		       /* gets replaced by slstring at run-time */
-   unsigned int offset;
-   SLtype type;
-   unsigned char read_only;
-}
-SLang_IStruct_Field_Type;
-
-typedef SLCONST struct _pSLang_CStruct_Field_Type   /* a g++ bug?? yuk*/
-{
-   char *field_name;
-   unsigned int offset;
-   SLtype type;
-   unsigned char read_only;
-}
-SLang_CStruct_Field_Type;
-
-SL_EXTERN int SLadd_intrin_fun_table (SLang_Intrin_Fun_Type *, char *);
-SL_EXTERN int SLadd_intrin_var_table (SLang_Intrin_Var_Type *, char *);
-SL_EXTERN int SLadd_app_unary_table (SLang_App_Unary_Type *, char *);
-SL_EXTERN int SLadd_math_unary_table (SLang_Math_Unary_Type *, char *);
-SL_EXTERN int SLadd_iconstant_table (SLang_IConstant_Type *, char *);
-SL_EXTERN int SLadd_dconstant_table (SLang_DConstant_Type *, char *);
-SL_EXTERN int SLadd_fconstant_table (SLang_FConstant_Type *, char *);
-#if HAVE_LONG_LONG
-SL_EXTERN int SLadd_llconstant_table (SLang_LLConstant_Type *, char *);
-#endif
-SL_EXTERN int SLadd_istruct_table (SLang_IStruct_Field_Type *, VOID_STAR, char *);
-
-
-typedef struct _pSLang_NameSpace_Type SLang_NameSpace_Type;
-
-SL_EXTERN int SLns_add_intrin_fun_table (SLang_NameSpace_Type *, SLang_Intrin_Fun_Type *, char *);
-SL_EXTERN int SLns_add_intrin_var_table (SLang_NameSpace_Type *, SLang_Intrin_Var_Type *, char *);
-SL_EXTERN int SLns_add_app_unary_table (SLang_NameSpace_Type *, SLang_App_Unary_Type *, char *);
-SL_EXTERN int SLns_add_math_unary_table (SLang_NameSpace_Type *, SLang_Math_Unary_Type *, char *);
-SL_EXTERN int SLns_add_hconstant_table (SLang_NameSpace_Type *, SLang_HConstant_Type *, char *);
-SL_EXTERN int SLns_add_iconstant_table (SLang_NameSpace_Type *, SLang_IConstant_Type *, char *);
-SL_EXTERN int SLns_add_lconstant_table (SLang_NameSpace_Type *, SLang_LConstant_Type *, char *);
-SL_EXTERN int SLns_add_fconstant_table (SLang_NameSpace_Type *, SLang_FConstant_Type *, char *);
-SL_EXTERN int SLns_add_dconstant_table (SLang_NameSpace_Type *, SLang_DConstant_Type *, char *);
-#ifdef HAVE_LONG_LONG
-SL_EXTERN int SLns_add_llconstant_table (SLang_NameSpace_Type *, SLang_LLConstant_Type *, char *);
-#endif
-SL_EXTERN int SLns_add_istruct_table (SLang_NameSpace_Type *, SLang_IStruct_Field_Type *, VOID_STAR, char *);
-
-SL_EXTERN int SLns_add_hconstant (SLang_NameSpace_Type *, char *, SLtype, short);
-SL_EXTERN int SLns_add_iconstant (SLang_NameSpace_Type *, char *, SLtype, int);
-SL_EXTERN int SLns_add_lconstant (SLang_NameSpace_Type *, char *, SLtype, long);
-SL_EXTERN int SLns_add_fconstant (SLang_NameSpace_Type *, char *, float);
-SL_EXTERN int SLns_add_dconstant (SLang_NameSpace_Type *, char *, double);
-#ifdef HAVE_LONG_LONG
-SL_EXTERN int SLns_add_llconstant (SLang_NameSpace_Type *, char *, long long);
-#endif
-SL_EXTERN SLang_NameSpace_Type *SLns_create_namespace (char *);
-SL_EXTERN void SLns_delete_namespace (SLang_NameSpace_Type *);
-
-SL_EXTERN int SLns_load_file (char *, char *);
-SL_EXTERN int SLns_load_string (char *, char *);
-SL_EXTERN int (*SLns_Load_File_Hook) (char *, char *);
-SL_EXTERN int SLang_load_file_verbose (int);    
-/* if non-zero, display file loading messages */
-
-typedef struct SLang_Load_Type
-{
-   int type;
-
-   VOID_STAR client_data;
-   /* Pointer to data that client needs for loading */
-
-   int auto_declare_globals;
-   /* if non-zero, undefined global variables are declared as static */
-
-   char *(*read)(struct SLang_Load_Type *);
-   /* function to call to read next line from obj. */
-
-   unsigned int line_num;
-   /* Number of lines read, used for error reporting */
-
-   int parse_level;
-   /* 0 if at top level of parsing */
-
-   char *name;
-   /* Name of this object, e.g., filename.  This name should be unique because
-    * it alone determines the name space for static objects associated with
-    * the compilable unit.
-    */
-
-   char *namespace_name;
-   unsigned long reserved[3];
-   /* For future expansion */
-} SLang_Load_Type;
-
-SL_EXTERN SLang_Load_Type *SLallocate_load_type (char *);
-SL_EXTERN void SLdeallocate_load_type (SLang_Load_Type *);
-SL_EXTERN SLang_Load_Type *SLns_allocate_load_type (char *, char *);
-  
-/* Returns SLang_Error upon failure */
-SL_EXTERN int SLang_load_object (SLang_Load_Type *);
-SL_EXTERN int (*SLang_Load_File_Hook)(char *);
-SL_EXTERN int (*SLang_Auto_Declare_Var_Hook) (char *);
-
-SL_EXTERN int SLang_generate_debug_info (int);
-
-
-#if defined(ultrix) && !defined(__GNUC__)
-# ifndef NO_PROTOTYPES
-#  define NO_PROTOTYPES
-# endif
-#endif
-
-#ifndef NO_PROTOTYPES
-# define _PROTO(x) x
-#else
-# define _PROTO(x) ()
-#endif
-
-typedef struct _pSLang_Struct_Type SLang_Struct_Type;
-SL_EXTERN void SLang_free_struct (SLang_Struct_Type *);
-SL_EXTERN int SLang_push_struct (SLang_Struct_Type *);
-SL_EXTERN int SLang_pop_struct (SLang_Struct_Type **);
-
-typedef struct _pSLang_Foreach_Context_Type SLang_Foreach_Context_Type;
-
-typedef struct _pSLang_Class_Type SLang_Class_Type;
-
-/* These are the low-level functions for building push/pop methods.  They
- * know nothing about memory management.  For SLANG_CLASS_TYPE_MMT, use the
- * MMT push/pop functions instead.
- */
-SL_EXTERN int SLclass_push_double_obj (SLtype, double);
-SL_EXTERN int SLclass_push_float_obj (SLtype, float);
-SL_EXTERN int SLclass_push_long_obj (SLtype, long);
-SL_EXTERN int SLclass_push_int_obj (SLtype, int);
-SL_EXTERN int SLclass_push_short_obj (SLtype, short);
-SL_EXTERN int SLclass_push_char_obj (SLtype, char);
-SL_EXTERN int SLclass_push_ptr_obj (SLtype, VOID_STAR);
-SL_EXTERN int SLclass_pop_double_obj (SLtype, double *);
-SL_EXTERN int SLclass_pop_float_obj (SLtype, float *);
-SL_EXTERN int SLclass_pop_long_obj (SLtype, long *);
-SL_EXTERN int SLclass_pop_int_obj (SLtype, int *);
-SL_EXTERN int SLclass_pop_short_obj (SLtype, short *);
-SL_EXTERN int SLclass_pop_char_obj (SLtype, char *);
-SL_EXTERN int SLclass_pop_ptr_obj (SLtype, VOID_STAR *);
-
-#ifdef HAVE_LONG_LONG
-SL_EXTERN int SLang_pop_long_long (long long *);
-SL_EXTERN int SLang_push_long_long (long long);
-SL_EXTERN int SLang_pop_ulong_long (unsigned long long *);
-SL_EXTERN int SLang_push_ulong_long (unsigned long long);
-SL_EXTERN int SLclass_pop_llong_obj (SLtype, long long *);
-SL_EXTERN int SLclass_push_llong_obj (SLtype, long long);
-#endif
-
-SL_EXTERN SLang_Class_Type *SLclass_allocate_class (char *);
-SL_EXTERN int SLclass_get_class_id (SLang_Class_Type *cl);
-SL_EXTERN int SLclass_create_synonym (char *, SLtype);
-SL_EXTERN int SLclass_is_class_defined (SLtype);
-SL_EXTERN int SLclass_dup_object (SLtype type, VOID_STAR from, VOID_STAR to);
-
-typedef int SLclass_Type;
-#define SLANG_CLASS_TYPE_MMT		0
-#define SLANG_CLASS_TYPE_SCALAR		1
-#define SLANG_CLASS_TYPE_VECTOR		2
-#define SLANG_CLASS_TYPE_PTR		3
-SL_EXTERN int SLclass_register_class (SLang_Class_Type *, SLtype, unsigned int, SLclass_Type);
-
-SL_EXTERN int SLclass_set_string_function (SLang_Class_Type *, char *(*)(SLtype, VOID_STAR));
-SL_EXTERN int SLclass_set_destroy_function (SLang_Class_Type *, void (*)(SLtype, VOID_STAR));
-SL_EXTERN int SLclass_set_push_function (SLang_Class_Type *, int (*)(SLtype, VOID_STAR));
-SL_EXTERN int SLclass_set_apush_function (SLang_Class_Type *, int (*)(SLtype, VOID_STAR));
-SL_EXTERN int SLclass_set_pop_function (SLang_Class_Type *, int (*)(SLtype, VOID_STAR));
-
-SL_EXTERN int SLclass_set_aget_function (SLang_Class_Type *, int (*)(SLtype, unsigned int));
-SL_EXTERN int SLclass_set_aput_function (SLang_Class_Type *, int (*)(SLtype, unsigned int));
-SL_EXTERN int SLclass_set_anew_function (SLang_Class_Type *, int (*)(SLtype, unsigned int));
-
-SL_EXTERN int SLclass_set_sget_function (SLang_Class_Type *, int (*)(SLtype, char *));
-SL_EXTERN int SLclass_set_sput_function (SLang_Class_Type *, int (*)(SLtype, char *));
-
-SL_EXTERN int SLclass_set_acopy_function (SLang_Class_Type *, int (*)(SLtype, VOID_STAR, VOID_STAR));
-SL_EXTERN int SLclass_set_deref_function (SLang_Class_Type *, int (*)(SLtype, VOID_STAR));
-SL_EXTERN int SLclass_set_eqs_function (SLang_Class_Type *, int (*)(SLtype, VOID_STAR, SLtype, VOID_STAR));
-
-SL_EXTERN int SLclass_set_length_function (SLang_Class_Type *, int(*)(SLtype, VOID_STAR, unsigned int *));
-
-SL_EXTERN int SLclass_set_is_container (SLang_Class_Type *, int);
-SL_EXTERN int SLclass_set_foreach_functions (
-  SLang_Class_Type *,
-  SLang_Foreach_Context_Type *(*)(SLtype, unsigned int),   /* open method */
-  int (*)(SLtype, SLang_Foreach_Context_Type *),   /* foreach method */
-  void (*)(SLtype, SLang_Foreach_Context_Type *));/* close method */
-
-   
-/* Typecast object on the stack to type p1.  p2 and p3 should be set to 1 */
-SL_EXTERN int SLclass_typecast (SLtype, int, int);
-
-#define SLMATH_SIN	1
-#define SLMATH_COS	2
-#define SLMATH_TAN	3
-#define SLMATH_ATAN	4
-#define SLMATH_ASIN	5
-#define SLMATH_ACOS	6
-#define SLMATH_EXP	7
-#define SLMATH_LOG	8
-#define SLMATH_SQRT	9
-#define SLMATH_LOG10	10
-#define SLMATH_REAL	11
-#define SLMATH_IMAG	12
-#define SLMATH_SINH	13
-#define SLMATH_COSH	14
-#define SLMATH_TANH	15
-#define SLMATH_ATANH	16
-#define SLMATH_ASINH	17
-#define SLMATH_ACOSH	18
-#define SLMATH_TODOUBLE	19
-#define SLMATH_CONJ	20
-#define SLMATH_ISINF	21
-#define SLMATH_ISNAN	22
-#define SLMATH_FLOOR	23
-#define SLMATH_CEIL	24
-#define SLMATH_ROUND	25
-
-SL_EXTERN int SLclass_add_unary_op (SLtype,
-				 int (*) (int,
-					  SLtype, VOID_STAR, unsigned int,
-					  VOID_STAR),
-				 int (*) (int, SLtype, SLtype *));
-
-SL_EXTERN int
-SLclass_add_app_unary_op (SLtype,
-			  int (*) (int,
-				   SLtype, VOID_STAR, unsigned int,
-				   VOID_STAR),
-			  int (*) (int, SLtype, SLtype *));
-
-SL_EXTERN int
-SLclass_add_binary_op (SLtype, SLtype,
-		       int (*) (int,
-				SLtype, VOID_STAR, unsigned int,
-				SLtype, VOID_STAR, unsigned int,
-				VOID_STAR),
-		       int (*) (int, SLtype, SLtype, SLtype *));
-
-SL_EXTERN int
-SLclass_add_math_op (SLtype,
-		     int (*)(int,
-			     SLtype, VOID_STAR, unsigned int,
-			     VOID_STAR),
-		     int (*)(int, SLtype, SLtype *));
-
-SL_EXTERN int
-SLclass_add_typecast (SLtype /* from */, SLtype /* to */,
-		      int (*)_PROTO((SLtype, VOID_STAR, unsigned int,
-				     SLtype, VOID_STAR)),
-		      int	       /* allow implicit typecasts */
-		      );
-
-SL_EXTERN char *SLclass_get_datatype_name (SLtype);
-
-SL_EXTERN double SLcomplex_abs (double *);
-SL_EXTERN double *SLcomplex_times (double *, double *, double *);
-SL_EXTERN double *SLcomplex_divide (double *, double *, double *);
-SL_EXTERN double *SLcomplex_sin (double *, double *);
-SL_EXTERN double *SLcomplex_cos (double *, double *);
-SL_EXTERN double *SLcomplex_tan (double *, double *);
-SL_EXTERN double *SLcomplex_asin (double *, double *);
-SL_EXTERN double *SLcomplex_acos (double *, double *);
-SL_EXTERN double *SLcomplex_atan (double *, double *);
-SL_EXTERN double *SLcomplex_exp (double *, double *);
-SL_EXTERN double *SLcomplex_log (double *, double *);
-SL_EXTERN double *SLcomplex_log10 (double *, double *);
-SL_EXTERN double *SLcomplex_sqrt (double *, double *);
-SL_EXTERN double *SLcomplex_sinh (double *, double *);
-SL_EXTERN double *SLcomplex_cosh (double *, double *);
-SL_EXTERN double *SLcomplex_tanh (double *, double *);
-SL_EXTERN double *SLcomplex_pow (double *, double *, double *);
-SL_EXTERN double SLmath_hypot (double x, double y);
-
-/* Not implemented yet */
-SL_EXTERN double *SLcomplex_asinh (double *, double *);
-SL_EXTERN double *SLcomplex_acosh (double *, double *);
-SL_EXTERN double *SLcomplex_atanh (double *, double *);
-
-#ifdef SLANG_SOURCE_
-typedef struct _pSLang_MMT_Type SLang_MMT_Type;
-#else
-typedef int SLang_MMT_Type;
-#endif
-
-SL_EXTERN void SLang_free_mmt (SLang_MMT_Type *);
-SL_EXTERN VOID_STAR SLang_object_from_mmt (SLang_MMT_Type *);
-SL_EXTERN SLang_MMT_Type *SLang_create_mmt (SLtype, VOID_STAR);
-SL_EXTERN int SLang_push_mmt (SLang_MMT_Type *);
-SL_EXTERN SLang_MMT_Type *SLang_pop_mmt (SLtype);
-SL_EXTERN void SLang_inc_mmt (SLang_MMT_Type *);
-
-/* Maximum number of dimensions of an array. */
-#define SLARRAY_MAX_DIMS		7
-typedef int SLindex_Type;
-typedef unsigned int SLuindex_Type;
-#define SLANG_ARRAY_INDEX_TYPE SLANG_INT_TYPE
-typedef struct _pSLang_Array_Type
-{
-   SLtype data_type;
-   unsigned int sizeof_type;
-   VOID_STAR data;
-   SLuindex_Type num_elements;
-   unsigned int num_dims;
-   SLindex_Type dims [SLARRAY_MAX_DIMS];
-   VOID_STAR (*index_fun)_PROTO((struct _pSLang_Array_Type *, SLindex_Type *));
-   /* This function is designed to allow a type to store an array in
-    * any manner it chooses.  This function returns the address of the data
-    * value at the specified index location.
-    */
-   unsigned int flags;
-#define SLARR_DATA_VALUE_IS_READ_ONLY		1
-#define SLARR_DATA_VALUE_IS_POINTER		2
-#define SLARR_DATA_VALUE_IS_RANGE		4
-#define SLARR_DATA_VALUE_IS_INTRINSIC		8
-   SLang_Class_Type *cl;
-   unsigned int num_refs;
-   void (*free_fun)_PROTO((struct _pSLang_Array_Type *));
-   VOID_STAR client_data;
-}
-SLang_Array_Type;
-
-SL_EXTERN int SLang_pop_array_of_type (SLang_Array_Type **, SLtype);
-SL_EXTERN int SLang_pop_array (SLang_Array_Type **, int);
-SL_EXTERN int SLang_push_array (SLang_Array_Type *, int);
-SL_EXTERN void SLang_free_array (SLang_Array_Type *);
-SL_EXTERN SLang_Array_Type *SLang_create_array (SLtype, int, VOID_STAR, SLindex_Type *, unsigned int);
-SL_EXTERN SLang_Array_Type *SLang_duplicate_array (SLang_Array_Type *);
-SL_EXTERN int SLang_get_array_element (SLang_Array_Type *, SLindex_Type *, VOID_STAR);
-SL_EXTERN int SLang_set_array_element (SLang_Array_Type *, SLindex_Type *, VOID_STAR);
-
-typedef int SLarray_Contract_Fun_Type (VOID_STAR xp, unsigned int increment, unsigned int num, VOID_STAR yp);
-typedef struct
-{
-   SLtype from_type;		       /* if array is this type */
-   SLtype typecast_to_type;	       /* typecast it to this */
-   SLtype result_type;		       /* to produce this */
-   SLarray_Contract_Fun_Type *f;       /* via this function */
-}
-SLarray_Contract_Type;
-SL_EXTERN int SLarray_contract_array (SLCONST SLarray_Contract_Type *);
-
-typedef int SLarray_Map_Fun_Type (SLtype xtype, VOID_STAR xp, 
-				  unsigned int increment, unsigned int num,
-				  SLtype ytype, VOID_STAR yp, VOID_STAR clientdata);
-typedef struct
-{
-   SLtype from_type;		       /* if array is this type */
-   SLtype typecast_to_type;	       /* typecast it to this */
-   SLtype result_type;		       /* to produce this */
-   SLarray_Map_Fun_Type *f;	       /* via this function */
-}
-SLarray_Map_Type;
-
-SL_EXTERN int SLarray_map_array_1 (SLCONST SLarray_Map_Type *, 
-				int *use_this_dim, 
-				VOID_STAR clientdata);
-SL_EXTERN int SLarray_map_array (SLCONST SLarray_Map_Type *);
-
-
-/*}}}*/
-
-/*{{{ Interpreter Function Prototypes */
-
-SL_EXTERN void SLang_verror (int, char *, ...) SLATTRIBUTE_PRINTF(2,3);
-SL_EXTERN int SLang_get_error (void);
-SL_EXTERN int SLang_set_error (int);
-SL_EXTERN char *SLerr_strerror (int errcode);
-SL_EXTERN int SLerr_new_exception (int baseclass, char *name, char *descript);
-SL_EXTERN int SLerr_exception_eqs (int, int);
-
-SL_EXTERN int SL_Any_Error;
-SL_EXTERN int SL_OS_Error;
-SL_EXTERN int   SL_Malloc_Error;
-SL_EXTERN int   SL_IO_Error;
-SL_EXTERN int     SL_Write_Error;
-SL_EXTERN int     SL_Read_Error;
-SL_EXTERN int     SL_Open_Error;
-SL_EXTERN int SL_RunTime_Error;
-SL_EXTERN int   SL_InvalidParm_Error;
-SL_EXTERN int   SL_TypeMismatch_Error;
-SL_EXTERN int   SL_UserBreak_Error;
-SL_EXTERN int   SL_Stack_Error;
-SL_EXTERN int     SL_StackOverflow_Error;
-SL_EXTERN int     SL_StackUnderflow_Error;
-SL_EXTERN int   SL_ReadOnly_Error;
-SL_EXTERN int   SL_VariableUninitialized_Error;
-SL_EXTERN int   SL_NumArgs_Error;
-SL_EXTERN int   SL_Index_Error;
-SL_EXTERN int SL_Parse_Error;
-SL_EXTERN int   SL_Syntax_Error;
-SL_EXTERN int   SL_DuplicateDefinition_Error;
-SL_EXTERN int   SL_UndefinedName_Error;
-SL_EXTERN int SL_Usage_Error;
-SL_EXTERN int SL_Application_Error;
-SL_EXTERN int SL_Internal_Error;
-SL_EXTERN int SL_NotImplemented_Error;
-SL_EXTERN int SL_LimitExceeded_Error;
-SL_EXTERN int SL_Forbidden_Error;
-SL_EXTERN int SL_Math_Error;
-SL_EXTERN int   SL_DivideByZero_Error;
-SL_EXTERN int   SL_ArithOverflow_Error;
-SL_EXTERN int   SL_ArithUnderflow_Error;
-SL_EXTERN int   SL_Domain_Error;
-SL_EXTERN int SL_Data_Error;
-SL_EXTERN int SL_Unicode_Error;
-SL_EXTERN int   SL_InvalidUTF8_Error;
-SL_EXTERN int SL_Namespace_Error;
-SL_EXTERN int SL_Unknown_Error;
-SL_EXTERN int SL_Import_Error;
-
-/* Non zero if error occurs.  Must be reset to zero to continue. */
-
-/* Compatibility */
-#define USER_BREAK			SL_UserBreak_Error
-#define INTRINSIC_ERROR			SL_RunTime_Error
-#define SL_OBJ_NOPEN			SL_Open_Error
-
-#define SL_UNKNOWN_ERROR	SL_Unknown_Error
-#define SL_APPLICATION_ERROR	SL_Application_Error
-#define SL_INTERNAL_ERROR	SL_Internal_Error
-#define SL_INTRINSIC_ERROR	SL_RunTime_Error
-#define SL_NOT_IMPLEMENTED	SL_NotImplemented_Error
-#define SL_BUILTIN_LIMIT_EXCEEDED	SL_LimitExceeded_Error
-#define SL_MALLOC_ERROR		SL_Malloc_Error
-#define SL_USER_BREAK		SL_UserBreak_Error
-#define SL_IO_WRITE_ERROR	SL_Write_Error
-#define SL_IO_READ_ERROR	SL_Read_Error
-#define SL_IO_OPEN_ERROR	SL_Open_Error
-#define SL_SYNTAX_ERROR		SL_Syntax_Error
-#define SL_STACK_OVERFLOW	SL_StackOverflow_Error
-#define SL_STACK_UNDERFLOW	SL_StackUnderflow_Error
-#define SL_TYPE_MISMATCH	SL_TypeMismatch_Error
-#define SL_READONLY_ERROR	SL_ReadOnly_Error
-#define SL_VARIABLE_UNINITIALIZED	SL_VariableUninitialized_Error
-#define SL_DUPLICATE_DEFINITION		SL_DuplicateDefinition_Error
-#define SL_INVALID_PARM			SL_InvalidParm_Error
-#define SL_UNDEFINED_NAME		SL_UndefinedName_Error
-#define SL_NUM_ARGS_ERROR		SL_NumArgs_Error
-#define SL_INDEX_ERROR			SL_Index_Error
-#define SL_DIVIDE_ERROR			SL_DivideByZero_Error
-#define SL_MATH_ERROR			SL_Math_Error
-#define SL_ARITH_OVERFLOW_ERROR		SL_ArithOverflow_Error
-#define SL_ARITH_UNDERFLOW_ERROR	SL_ArithUnderflow_Error
-#define SL_USAGE_ERROR			SL_Usage_Error
-#define SL_INVALID_DATA_ERROR		SL_Data_Error
-#define SL_UNICODE_ERROR		SL_Unicode_Error
-#define SL_INVALID_UTF8			SL_InvalidUTF8_Error
-
-  SL_EXTERN int SLang_Traceback;
-  /* If non-zero, dump an S-Lang traceback upon error.  Available as
-     _traceback in S-Lang. */
-
-  SL_EXTERN char *SLang_User_Prompt;
-  /* Prompt to use when reading from stdin */
-  SL_EXTERN int SLang_Version;
-  SL_EXTERN char *SLang_Version_String;
-SL_EXTERN char *SLang_Doc_Dir;
-
-SL_EXTERN void (*SLang_VMessage_Hook) (char *, va_list);
-SL_EXTERN void SLang_vmessage (char *, ...) SLATTRIBUTE_PRINTF(1,2);
-
-  SL_EXTERN void (*SLang_Error_Hook)(char *);
-  /* Pointer to application dependent error messaging routine.  By default,
-     messages are displayed on stderr. */
-
-  SL_EXTERN void (*SLang_Exit_Error_Hook)(char *, va_list);
-SL_EXTERN void SLang_exit_error (char *, ...) SLATTRIBUTE_((format (printf, 1, 2), noreturn));
-  SL_EXTERN void (*SLang_Dump_Routine)(char *);
-  /* Called if S-Lang traceback is enabled as well as other debugging
-     routines (e.g., trace).  By default, these messages go to stderr. */
-
-  SL_EXTERN void (*SLang_Interrupt)(void);
-  /* function to call whenever inner interpreter is entered.  This is
-     a good place to set SLang_Error to USER_BREAK. */
-
-  SL_EXTERN void (*SLang_User_Clear_Error)(void);
-  /* function that gets called when '_clear_error' is called. */
-
-  /* If non null, these call C functions before and after a slang function. */
-  SL_EXTERN void (*SLang_Enter_Function)(char *);
-SL_EXTERN void (*SLang_Exit_Function)(char *);
-
-SL_EXTERN int SLang_Num_Function_Args;
-
-/* This function should be called when a system call is interrupted.  It
- * runs a set of hooks.  If any of the hooks returns -1, then the system call
- * should not be restarted.
- */
-SL_EXTERN int SLang_handle_interrupt (void);
-SL_EXTERN int SLang_add_interrupt_hook (int (*)(VOID_STAR), VOID_STAR);
-SL_EXTERN void SLang_remove_interrupt_hook (int (*)(VOID_STAR), VOID_STAR);
-
-/* Functions: */
-
-SL_EXTERN int SLang_init_all (void);
-/* Initializes interpreter and all modules */
-
-SL_EXTERN int SLang_init_slang (void);
-/* This function is mandatory and must be called by all applications that
- * use the interpreter
- */
-SL_EXTERN int SLang_init_posix_process (void);   /* process specific intrinsics */
-SL_EXTERN int SLang_init_stdio (void);    /* fgets, etc. stdio functions  */
-SL_EXTERN int SLang_init_posix_dir (void);
-SL_EXTERN int SLang_init_ospath (void);
-
-SL_EXTERN int SLang_init_slmath (void);
-/* called if math functions sin, cos, etc... are needed. */
-
-/* These functions are obsolete.  Use init_stdio, posix_process, etc. */
-SL_EXTERN int SLang_init_slfile (void);
-SL_EXTERN int SLang_init_slunix (void);
-  
-SL_EXTERN int SLang_init_slassoc (void);
-/* Assoc Arrays (Hashes) */
-
-SL_EXTERN int SLang_init_array (void);
-/* Additional arrays functions: transpose, etc... */
-
-SL_EXTERN int SLang_init_array_extra (void);
-/* Additional arrays functions, if any */
-
-SL_EXTERN int SLang_init_signal (void);
-/* signal handling within the interpreter */
-
-/* Dynamic linking facility */
-SL_EXTERN int SLang_init_import (void);
-
-   SL_EXTERN int SLang_load_file (char *);
-   /* Load a file of S-Lang code for interpreting.  If the parameter is
-    * NULL, input comes from stdin. */
-
-   SL_EXTERN void SLang_restart(int);
-   /* should be called if an error occurs.  If the passed integer is
-    * non-zero, items are popped off the stack; otherwise, the stack is
-    * left intact.  Any time the stack is believed to be trashed, this routine
-    * should be called with a non-zero argument (e.g., if setjmp/longjmp is
-    * called). */
-
-   SL_EXTERN int SLang_byte_compile_file(char *, int);
-   /* takes a file of S-Lang code and ``byte-compiles'' it for faster
-    * loading.  The new filename is equivalent to the old except that a `c' is
-    * appended to the name.  (e.g., init.sl --> init.slc).  The second
-    * specified the method; currently, it is not used.
-    */
-
-   SL_EXTERN int SLang_autoload(char *, char *);
-   /* Automatically load S-Lang function p1 from file p2.  This function
-      is also available via S-Lang */
-
-   SL_EXTERN int SLang_load_string(char *);
-   /* Like SLang_load_file except input is from a null terminated string. */
-
-SL_EXTERN int SLstack_depth(void);
-
-SL_EXTERN int SLdo_pop(void);
-SL_EXTERN int SLdo_pop_n(unsigned int);
-
-SL_EXTERN int SLang_push_char (char);
-SL_EXTERN int SLang_push_uchar (unsigned char);
-SL_EXTERN int SLang_pop_char (char *);
-SL_EXTERN int SLang_pop_uchar (unsigned char *);
-
-#define SLang_push_integer SLang_push_int
-#define SLang_push_uinteger SLang_push_uint
-#define SLang_pop_integer SLang_pop_int
-#define SLang_pop_uinteger SLang_pop_uint
-SL_EXTERN int SLang_push_int(int);
-SL_EXTERN int SLang_push_uint(unsigned int);
-SL_EXTERN int SLang_pop_int(int *);
-SL_EXTERN int SLang_pop_uint(unsigned int *);
-
-SL_EXTERN int SLang_pop_short(short *);
-SL_EXTERN int SLang_pop_ushort(unsigned short *);
-SL_EXTERN int SLang_push_short(short);
-SL_EXTERN int SLang_push_ushort(unsigned short);
-
-SL_EXTERN int SLang_pop_long(long *);
-SL_EXTERN int SLang_pop_ulong(unsigned long *);
-SL_EXTERN int SLang_push_long(long);
-SL_EXTERN int SLang_push_ulong(unsigned long);
-
-SL_EXTERN int SLang_pop_float(float *);
-SL_EXTERN int SLang_push_float(float);
-
-SL_EXTERN int SLang_pop_double(double *);
-SL_EXTERN int SLang_push_double(double);
-
-SL_EXTERN int SLang_push_complex (double, double);
-SL_EXTERN int SLang_pop_complex (double *, double *);
-
-SL_EXTERN int SLang_push_datatype (SLtype);
-SL_EXTERN int SLang_pop_datatype (SLtype *);
-
-SL_EXTERN int SLang_push_malloced_string(char *);
-/* The normal SLang_push_string pushes an slstring.  This one converts
- * a normally malloced string to an slstring, and then frees the 
- * malloced string.  So, do NOT use the malloced string after calling
- * this routine because it will be freed!  The routine returns -1 upon 
- * error, but the string will be freed.
- */
-
-SL_EXTERN int SLang_push_string(char *);
-SL_EXTERN int SLpop_string (char **);
-
-SL_EXTERN int SLang_push_null (void);
-SL_EXTERN int SLang_pop_null (void);
-
-SL_EXTERN int SLang_push_value (SLtype type, VOID_STAR);
-SL_EXTERN int SLang_pop_value (SLtype type, VOID_STAR);
-SL_EXTERN void SLang_free_value (SLtype type, VOID_STAR);
-
-typedef struct _pSLang_Object_Type SLang_Any_Type;
-
-SL_EXTERN int SLang_pop_anytype (SLang_Any_Type **);
-SL_EXTERN int SLang_push_anytype (SLang_Any_Type *);
-SL_EXTERN void SLang_free_anytype (SLang_Any_Type *);
-
-#ifdef SLANG_SOURCE_
-typedef struct _pSLang_Ref_Type SLang_Ref_Type;
-#else
-typedef int SLang_Ref_Type;
-#endif
-
-SL_EXTERN int SLang_pop_ref (SLang_Ref_Type **);
-SL_EXTERN void SLang_free_ref (SLang_Ref_Type *);
-SL_EXTERN int SLang_assign_to_ref (SLang_Ref_Type *, SLtype, VOID_STAR);
-SL_EXTERN int SLang_assign_nametype_to_ref (SLang_Ref_Type *, SLang_Name_Type *);
-SL_EXTERN SLang_Name_Type *SLang_pop_function (void);
-SL_EXTERN int SLang_push_function (SLang_Name_Type *);
-SL_EXTERN SLang_Name_Type *SLang_get_fun_from_ref (SLang_Ref_Type *);
-SL_EXTERN void SLang_free_function (SLang_Name_Type *f);
-SL_EXTERN SLang_Name_Type *SLang_copy_function (SLang_Name_Type *);
-
-/* C structure interface */
-SL_EXTERN int SLang_push_cstruct (VOID_STAR, SLang_CStruct_Field_Type *);
-SL_EXTERN int SLang_pop_cstruct (VOID_STAR, SLang_CStruct_Field_Type *);
-SL_EXTERN void SLang_free_cstruct (VOID_STAR, SLang_CStruct_Field_Type *);
-SL_EXTERN int SLang_assign_cstruct_to_ref (SLang_Ref_Type *, VOID_STAR, SLang_CStruct_Field_Type *);
-
-   SL_EXTERN int SLang_is_defined(char *);
-   /* Return non-zero is p1 is defined otherwise returns 0. */
-
-   SL_EXTERN int SLang_run_hooks(char *, unsigned int, ...);
-   /* calls S-Lang function p1 pushing p2 strings in the variable argument
-    * list onto the stack first.
-    * Returns -1 upon error, 1 if hooks exists and it ran,
-    * or 0 if hook does not exist.  Thus it returns non-zero is hook was called.
-    */
-
-/* These functions return 1 if the indicated function exists and the function
- * runs without error.  If the function does not exist, the function returns
- * 0.  Otherwise -1 is returned with SLang_Error set appropriately.
- */
-SL_EXTERN int SLexecute_function (SLang_Name_Type *);
-SL_EXTERN int SLang_execute_function(char *);
-
-
-SL_EXTERN int SLang_end_arg_list (void);
-SL_EXTERN int SLang_start_arg_list (void);
-
-
-SL_EXTERN int SLang_add_intrinsic_array (char *,   /* name */
-				      SLtype,   /* type */
-				      int,   /* readonly */
-				      VOID_STAR,   /* data */
-				      unsigned int, ...);   /* num dims */
-
-SL_EXTERN int SLextract_list_element (char *, unsigned int, char,
-				   char *, unsigned int);
-
-/* If utf8_encode is >1, then byte values > 127 will be utf8-encoded. 
- * If the string is already in utf8 form, and utf8 is desired, then use with
- * utf8_encode set to 0.  A value of -1 implies use the value appropriate for
- * the current state of the interpreter.
- */
-SL_EXTERN int SLexpand_escaped_string (char *dest, char *src, char *src_max, 
-				    int utf8_encode);
-
-SL_EXTERN SLang_Name_Type *SLang_get_function (char *);
-SL_EXTERN void SLang_release_function (SLang_Name_Type *);
-
-SL_EXTERN int SLreverse_stack (int);
-SL_EXTERN int SLroll_stack (int);
-/* If argument p is positive, the top p objects on the stack are rolled
- * up.  If negative, the stack is rolled down.
- */
-SL_EXTERN int SLdup_n (int n);
-/* Duplicate top n elements of stack */
-
-SL_EXTERN int SLang_peek_at_stack1 (void);
-SL_EXTERN int SLang_peek_at_stack (void);
-SL_EXTERN int SLang_peek_at_stack_n (unsigned int n);
-SL_EXTERN int SLang_peek_at_stack1_n (unsigned int n);
-
-/* Returns type of next object on stack-- -1 upon stack underflow. */
-SL_EXTERN void SLmake_lut (unsigned char *, unsigned char *, unsigned char);
-
-   SL_EXTERN int SLang_guess_type (char *);
-
-SL_EXTERN int SLstruct_create_struct (unsigned int,
-				   char **,
-				   SLtype *,
-				   VOID_STAR *);
-
-/*}}}*/
-
-/*{{{ Misc Functions */
-
-/* This is an interface to atexit */
-SL_EXTERN int SLang_add_cleanup_function (void (*)(void));
-
-SL_EXTERN char *SLmake_string (char *);
-SL_EXTERN char *SLmake_nstring (char *, unsigned int);
-/* Returns a null terminated string made from the first n characters of the
- * string.
- */
-
-/* Binary strings */
-/* The binary string is an opaque type.  Use the SLbstring_get_pointer function
- * to get a pointer and length.
- */
-typedef struct _pSLang_BString_Type SLang_BString_Type;
-SL_EXTERN unsigned char *SLbstring_get_pointer (SLang_BString_Type *, unsigned int *);
-
-SL_EXTERN SLang_BString_Type *SLbstring_dup (SLang_BString_Type *);
-SL_EXTERN SLang_BString_Type *SLbstring_create (unsigned char *, unsigned int);
-
-/* The create_malloced function used the first argument which is assumed
- * to be a pointer to a len + 1 malloced string.  The extra byte is for
- * \0 termination.
- */
-SL_EXTERN SLang_BString_Type *SLbstring_create_malloced (unsigned char *, unsigned int, int);
-
-/* Create a bstring from an slstring */
-SL_EXTERN SLang_BString_Type *SLbstring_create_slstring (char *);
-
-SL_EXTERN void SLbstring_free (SLang_BString_Type *);
-SL_EXTERN int SLang_pop_bstring (SLang_BString_Type **);
-SL_EXTERN int SLang_push_bstring (SLang_BString_Type *);
-
-/* GNU Midnight Commander uses replacements from glib */
-#ifndef MIDNIGHT_COMMANDER_CODE
-
-SL_EXTERN char *SLmalloc (unsigned int);
-
-#endif                                /* !MIDNIGHT_COMMANDER_CODE */
-
-SL_EXTERN char *SLcalloc (unsigned int, unsigned int);
-
-#ifndef MIDNIGHT_COMMANDER_CODE
-
-SL_EXTERN void SLfree(char *);	       /* This function handles NULL */
-SL_EXTERN char *SLrealloc (char *, unsigned int);
-
-#endif                                /* !MIDNIGHT_COMMANDER_CODE */
-
-
-SL_EXTERN char *SLcurrent_time_string (void);
-
-SL_EXTERN int SLatoi(unsigned char *);
-SL_EXTERN long SLatol (unsigned char *);
-SL_EXTERN unsigned long SLatoul (unsigned char *);
-
-#if HAVE_LONG_LONG
-SL_EXTERN long long SLatoll (unsigned char *s);
-SL_EXTERN unsigned long long SLatoull (unsigned char *s);
-#endif
-SL_EXTERN int SLang_pop_fileptr (SLang_MMT_Type **, FILE **);
-SL_EXTERN char *SLang_get_name_from_fileptr (SLang_MMT_Type *);
-
-SL_EXTERN int SLang_get_fileptr (SLang_MMT_Type *, FILE **);
-/* This function may be used to obtain the FILE* object associated with an MMT.
- * It returns 0 if no-errors were encountered, and -1 otherwise.  
- * If FILE* object has been closed, this function will return 0 and set the FILE* 
- * parameter to NULL.
- */
-
-typedef struct _pSLFile_FD_Type SLFile_FD_Type;
-SL_EXTERN SLFile_FD_Type *SLfile_create_fd (char *, int);
-SL_EXTERN void SLfile_free_fd (SLFile_FD_Type *);
-SL_EXTERN int SLfile_push_fd (SLFile_FD_Type *);
-SL_EXTERN int SLfile_pop_fd (SLFile_FD_Type **);
-SL_EXTERN int SLfile_get_fd (SLFile_FD_Type *, int *);
-SL_EXTERN SLFile_FD_Type *SLfile_dup_fd (SLFile_FD_Type *f0);
-SL_EXTERN int SLang_init_posix_io (void);
-
-typedef double (*SLang_To_Double_Fun_Type)(VOID_STAR);
-SL_EXTERN SLang_To_Double_Fun_Type SLarith_get_to_double_fun (SLtype, unsigned int *);
-
-SL_EXTERN int SLang_set_argc_argv (int, char **);
-
-/*}}}*/
-
-/*{{{ SLang getkey interface Functions */
-
-#ifdef REAL_UNIX_SYSTEM
-SL_EXTERN int SLang_TT_Baud_Rate;
-SL_EXTERN int SLang_TT_Read_FD;
-#else
-# if defined(__WIN32__)
-/* I do not want to include windows.h just to get the typedef for HANDLE.
- * Make this conditional upon the inclusion of windows.h.
- */
-#  ifdef WINVER
-SL_EXTERN HANDLE SLw32_Hstdin;
-#  endif
-# endif
-#endif
-
-SL_EXTERN int SLang_init_tty (int, int, int);
-/* Initializes the tty for single character input.  If the first parameter *p1
- * is in the range 0-255, it will be used for the abort character;
- * otherwise, (unix only) if it is -1, the abort character will be the one
- * used by the terminal.  If the second parameter p2 is non-zero, flow
- * control is enabled.  If the last parmeter p3 is zero, output processing
- * is NOT turned on.  A value of zero is required for the screen management
- * routines. Returns 0 upon success. In addition, if SLang_TT_Baud_Rate ==
- * 0 when this function is called, SLang will attempt to determine the
- * terminals baud rate.  As far as the SLang library is concerned, if
- * SLang_TT_Baud_Rate is less than or equal to zero, the baud rate is
- * effectively infinite.
- */
-
-SL_EXTERN void SLang_reset_tty (void);
-/* Resets tty to what it was prior to a call to SLang_init_tty */
-#ifdef REAL_UNIX_SYSTEM
-SL_EXTERN void SLtty_set_suspend_state (int);
-   /* If non-zero argument, terminal driver will be told to react to the
-    * suspend character.  If 0, it will not.
-    */
-SL_EXTERN int (*SLang_getkey_intr_hook) (void);
-#endif
-
-#define SLANG_GETKEY_ERROR 0xFFFF
-SL_EXTERN unsigned int SLang_getkey (void);
-/* reads a single key from the tty.  If the read fails,  0xFFFF is returned. */
-
-#ifdef IBMPC_SYSTEM
-SL_EXTERN int SLgetkey_map_to_ansi (int);
-#endif
-
-SL_EXTERN int SLang_ungetkey_string (unsigned char *, unsigned int);
-SL_EXTERN int SLang_buffer_keystring (unsigned char *, unsigned int);
-SL_EXTERN int SLang_ungetkey (unsigned char);
-SL_EXTERN void SLang_flush_input (void);
-SL_EXTERN int SLang_input_pending (int);
-SL_EXTERN int SLang_Abort_Char;
-/* The value of the character (0-255) used to trigger SIGINT */
-SL_EXTERN int SLang_Ignore_User_Abort;
-/* If non-zero, pressing the abort character will not result in USER_BREAK
- * SLang_Error. */
-
-SL_EXTERN int SLang_set_abort_signal (void (*)(int));
-/* If SIGINT is generated, the function p1 will be called.  If p1 is NULL
- * the SLang_default signal handler is called.  This sets SLang_Error to
- * USER_BREAK.  I suspect most users will simply want to pass NULL.
- */
-SL_EXTERN unsigned int SLang_Input_Buffer_Len;
-
-SL_EXTERN volatile int SLKeyBoard_Quit;
-
-#ifdef VMS
-/* If this function returns -1, ^Y will be added to input buffer. */
-SL_EXTERN int (*SLtty_VMS_Ctrl_Y_Hook) (void);
-#endif
-/*}}}*/
-
-/*{{{ SLang Keymap routines */
-
-typedef struct SLKeymap_Function_Type
-{
-   char *name;
-   int (*f)(void);
-}
-SLKeymap_Function_Type;
-
-#define SLANG_MAX_KEYMAP_KEY_SEQ	14
-typedef struct SLang_Key_Type
-{
-   struct SLang_Key_Type *next;
-   union
-     {
-	char *s;
-	FVOID_STAR f;
-	unsigned int keysym;
-	SLang_Name_Type *slang_fun;
-     }
-     f;
-   unsigned char type;	       /* type of function */
-#define SLKEY_F_INTERPRET	0x01
-#define SLKEY_F_INTRINSIC	0x02
-#define SLKEY_F_KEYSYM		0x03
-#define SLKEY_F_SLANG		0x04
-   unsigned char str[SLANG_MAX_KEYMAP_KEY_SEQ + 1];/* key sequence */
-}
-SLang_Key_Type;
-
-int SLkm_set_free_method (int, void (*)(int, VOID_STAR));
-
-typedef struct _pSLkeymap_Type
-{
-   char *name;			       /* hashed string */
-   SLang_Key_Type *keymap;
-   SLKeymap_Function_Type *functions;  /* intrinsic functions */
-   struct _pSLkeymap_Type *next;
-} SLkeymap_Type;
-
-SL_EXTERN SLkeymap_Type *SLKeyMap_List_Root;   /* linked list of keymaps */
-
-/* backward compat */
-typedef SLkeymap_Type SLKeyMap_List_Type;
-
-
-SL_EXTERN char *SLang_process_keystring(char *);
-
-SL_EXTERN int SLkm_define_key (char *, FVOID_STAR, SLkeymap_Type *);
-
-SL_EXTERN int SLang_define_key(char *, char *, SLkeymap_Type *);
-/* Like define_key1 except that p2 is a string that is to be associated with
- * a function in the functions field of p3.
- */
-
-SL_EXTERN int SLkm_define_keysym (char *, unsigned int, SLkeymap_Type *);
-SL_EXTERN int SLkm_define_slkey (char *keysequence, SLang_Name_Type *func, SLkeymap_Type *);
-SL_EXTERN void SLang_undefine_key(char *, SLkeymap_Type *);
-
-SL_EXTERN SLkeymap_Type *SLang_create_keymap(char *, SLkeymap_Type *);
-/* create and returns a pointer to a new keymap named p1 created by copying
- * keymap p2.  If p2 is NULL, it is up to the calling routine to initialize
- * the keymap.
- */
-
-SL_EXTERN char *SLang_make_keystring(unsigned char *);
-
-SL_EXTERN SLang_Key_Type *SLang_do_key(SLkeymap_Type *, int (*)(void));
-/* read a key using keymap p1 with getkey function p2 */
-
-SL_EXTERN FVOID_STAR SLang_find_key_function(char *, SLkeymap_Type *);
-
-SL_EXTERN SLkeymap_Type *SLang_find_keymap(char *);
-
-SL_EXTERN int SLang_Last_Key_Char;
-SL_EXTERN int SLang_Key_TimeOut_Flag;
-
-/*}}}*/
-
-/*{{{ SLang Readline Interface */
-
-typedef struct _pSLrline_Type SLrline_Type;
-SL_EXTERN SLrline_Type *SLrline_open (unsigned int width, unsigned int flags);
-#define SL_RLINE_NO_ECHO	1
-#define SL_RLINE_USE_ANSI	2
-#define SL_RLINE_BLINK_MATCH	4
-#define SL_RLINE_UTF8_MODE	8
-SL_EXTERN void SLrline_close (SLrline_Type *);
-
-/* This returns a malloced string */
-SL_EXTERN char *SLrline_read_line (SLrline_Type *, char *prompt, unsigned int *lenp);
-
-SL_EXTERN int SLrline_bol (SLrline_Type *);
-SL_EXTERN int SLrline_eol (SLrline_Type *);
-SL_EXTERN int SLrline_del (SLrline_Type *, unsigned int len);
-SL_EXTERN int SLrline_ins (SLrline_Type *, char *s, unsigned int len);
-
-SL_EXTERN int SLrline_set_echo (SLrline_Type *, int);
-SL_EXTERN int SLrline_set_tab (SLrline_Type *, unsigned int tabwidth);
-SL_EXTERN int SLrline_set_point (SLrline_Type *, unsigned int);
-SL_EXTERN int SLrline_set_line (SLrline_Type *, char *);
-SL_EXTERN int SLrline_set_hscroll (SLrline_Type *, unsigned int);
-SL_EXTERN int SLrline_set_display_width (SLrline_Type *, unsigned int);
-
-SL_EXTERN int SLrline_get_echo (SLrline_Type *, int *);
-SL_EXTERN int SLrline_get_tab (SLrline_Type *, unsigned int *);
-SL_EXTERN int SLrline_get_point (SLrline_Type *, unsigned int *);
-SL_EXTERN char *SLrline_get_line (SLrline_Type *);
-SL_EXTERN int SLrline_get_hscroll (SLrline_Type *, unsigned int *);
-SL_EXTERN int SLrline_get_display_width (SLrline_Type *, unsigned int *);
-
-SL_EXTERN int SLrline_set_update_hook (SLrline_Type *,
-				    void (*)(SLrline_Type *rli,
-					     char *prompt,
-					     char *buf, unsigned int len,
-					     unsigned int point, VOID_STAR client_data),
-				    VOID_STAR client_data);
-
-SL_EXTERN SLkeymap_Type *SLrline_get_keymap (SLrline_Type *);
-
-SL_EXTERN void SLrline_redraw (SLrline_Type *);
-SL_EXTERN int SLrline_save_line (SLrline_Type *);
-SL_EXTERN int SLrline_add_to_history (SLrline_Type *, char *);
-
-/* Compatibility */
-typedef SLrline_Type SLang_RLine_Info_Type;
-
-/*}}}*/
-
-/*{{{ Low Level Screen Output Interface */
-
-SL_EXTERN unsigned long SLtt_Num_Chars_Output;
-SL_EXTERN int SLtt_Baud_Rate;
-
-typedef unsigned long SLtt_Char_Type;
-
-#define SLTT_BOLD_MASK	0x01000000UL
-#define SLTT_BLINK_MASK	0x02000000UL
-#define SLTT_ULINE_MASK	0x04000000UL
-#define SLTT_REV_MASK	0x08000000UL
-#define SLTT_ALTC_MASK  0x10000000UL
-
-SL_EXTERN int SLtt_Screen_Rows;
-SL_EXTERN int SLtt_Screen_Cols;
-SL_EXTERN int SLtt_Term_Cannot_Insert;
-SL_EXTERN int SLtt_Term_Cannot_Scroll;
-SL_EXTERN int SLtt_Use_Ansi_Colors;
-SL_EXTERN int SLtt_Ignore_Beep;
-#if defined(REAL_UNIX_SYSTEM)
-SL_EXTERN int SLtt_Force_Keypad_Init;
-SL_EXTERN int SLang_TT_Write_FD;
-#endif
-
-#ifndef IBMPC_SYSTEM
-SL_EXTERN char *SLtt_Graphics_Char_Pairs;
-#endif
-
-#ifndef __GO32__
-#if defined(VMS) || defined(REAL_UNIX_SYSTEM)
-SL_EXTERN int SLtt_Blink_Mode;
-SL_EXTERN int SLtt_Use_Blink_For_ACS;
-SL_EXTERN int SLtt_Newline_Ok;
-SL_EXTERN int SLtt_Has_Alt_Charset;
-SL_EXTERN int SLtt_Has_Status_Line;       /* if 0, NO.  If > 0, YES, IF -1, ?? */
-# ifndef VMS
-SL_EXTERN int SLtt_Try_Termcap;
-# endif
-#endif
-#endif
-
-#if defined(IBMPC_SYSTEM)
-SL_EXTERN int SLtt_Msdos_Cheap_Video;
-#endif
-
-typedef unsigned short SLsmg_Color_Type;
-#define SLSMG_MAX_COLORS	0x7FFE /* keep one for BCE */
-#define SLSMG_COLOR_MASK	0x7FFF
-#define SLSMG_ACS_MASK		0x8000
-
-#define SLSMG_MAX_CHARS_PER_CELL 5
-typedef struct
-{
-   unsigned int nchars;
-   SLwchar_Type wchars[SLSMG_MAX_CHARS_PER_CELL];
-   SLsmg_Color_Type color;
-}
-SLsmg_Char_Type;
-
-#define SLSMG_EXTRACT_COLOR(x) ((x).color)
-#define SLSMG_EXTRACT_CHAR(x) ((x).wchars[0])
-
-SL_EXTERN int SLtt_flush_output (void);
-SL_EXTERN void SLtt_set_scroll_region(int, int);
-SL_EXTERN void SLtt_reset_scroll_region(void);
-SL_EXTERN void SLtt_reverse_video (int);
-SL_EXTERN void SLtt_bold_video (void);
-SL_EXTERN void SLtt_begin_insert(void);
-SL_EXTERN void SLtt_end_insert(void);
-SL_EXTERN void SLtt_del_eol(void);
-SL_EXTERN void SLtt_goto_rc (int, int);
-SL_EXTERN void SLtt_delete_nlines(int);
-SL_EXTERN void SLtt_delete_char(void);
-SL_EXTERN void SLtt_erase_line(void);
-SL_EXTERN void SLtt_normal_video(void);
-SL_EXTERN void SLtt_cls(void);
-SL_EXTERN void SLtt_beep(void);
-SL_EXTERN void SLtt_reverse_index(int);
-SL_EXTERN void SLtt_smart_puts(SLsmg_Char_Type *, SLsmg_Char_Type *, int, int);
-SL_EXTERN void SLtt_write_string (char *);
-SL_EXTERN void SLtt_putchar(char);
-SL_EXTERN int SLtt_init_video (void);
-SL_EXTERN int SLtt_reset_video (void);
-SL_EXTERN void SLtt_get_terminfo(void);
-SL_EXTERN void SLtt_get_screen_size (void);
-SL_EXTERN int SLtt_set_cursor_visibility (int);
-
-SL_EXTERN int SLtt_set_mouse_mode (int, int);
-
-#if defined(VMS) || defined(REAL_UNIX_SYSTEM)
-SL_EXTERN int SLtt_initialize (char *);
-SL_EXTERN void SLtt_enable_cursor_keys(void);
-SL_EXTERN void SLtt_set_term_vtxxx(int *);
-SL_EXTERN void SLtt_wide_width(void);
-SL_EXTERN void SLtt_narrow_width(void);
-SL_EXTERN void SLtt_set_alt_char_set (int);
-SL_EXTERN int SLtt_write_to_status_line (char *, int);
-SL_EXTERN void SLtt_disable_status_line (void);
-# ifdef REAL_UNIX_SYSTEM
-/* These are termcap/terminfo routines that assume SLtt_initialize has
- * been called.
- */
-SL_EXTERN char *SLtt_tgetstr (char *);
-SL_EXTERN int SLtt_tgetnum (char *);
-SL_EXTERN int SLtt_tgetflag (char *);
-
-/* The following are terminfo-only routines -- these prototypes will change
- * in V2.x.
- */
-SL_EXTERN char *SLtt_tigetent (char *);
-SL_EXTERN char *SLtt_tigetstr (char *, char **);
-SL_EXTERN int SLtt_tigetnum (char *, char **);
-# endif
-#endif
-
-SL_EXTERN SLtt_Char_Type SLtt_get_color_object (int);
-SL_EXTERN int SLtt_set_color_object (int, SLtt_Char_Type);
-SL_EXTERN int SLtt_set_color (int, char *, char *, char *);
-SL_EXTERN int SLtt_set_mono (int, char *, SLtt_Char_Type);
-SL_EXTERN int SLtt_add_color_attribute (int, SLtt_Char_Type);
-SL_EXTERN int SLtt_set_color_fgbg (int, SLtt_Char_Type, SLtt_Char_Type);
-
-/*}}}*/
-
-/*{{{ SLang Preprocessor Interface */
-
-/* #define SLPreprocess_Type SLprep_Type; */
-typedef struct _pSLprep_Type SLprep_Type;
-
-SL_EXTERN SLprep_Type *SLprep_new (void);
-SL_EXTERN void SLprep_delete (SLprep_Type *);
-SL_EXTERN int SLprep_line_ok (char *, SLprep_Type *);
-SL_EXTERN int SLprep_set_flags (SLprep_Type *, unsigned int flags);
-#define SLPREP_BLANK_LINES_OK	0x1
-#define SLPREP_COMMENT_LINES_OK	0x2
-
-SL_EXTERN int SLprep_set_comment (SLprep_Type *, char *, char *);
-SL_EXTERN int SLprep_set_prefix (SLprep_Type *, char *);
-SL_EXTERN int SLprep_set_exists_hook (SLprep_Type *, 
-				   int (*)(SLprep_Type *, char *));
-SL_EXTERN int SLprep_set_eval_hook (SLprep_Type *, 
-				 int (*)(SLprep_Type *, char *));
-
-SL_EXTERN int SLdefine_for_ifdef (char *);
-   /* Adds a string to the SLang #ifdef preparsing defines. SLang already
-      defines MSDOS, UNIX, and VMS on the appropriate system. */
-
-/*}}}*/
-
-/*{{{ SLsmg Screen Management Functions */
-
-SL_EXTERN void SLsmg_fill_region (int, int, unsigned int, unsigned int, 
-			       SLwchar_Type);
-SL_EXTERN void SLsmg_set_char_set (int);
-#ifndef IBMPC_SYSTEM
-SL_EXTERN int SLsmg_Scroll_Hash_Border;
-#endif
-SL_EXTERN int SLsmg_suspend_smg (void);
-SL_EXTERN int SLsmg_resume_smg (void);
-SL_EXTERN void SLsmg_erase_eol (void);
-SL_EXTERN void SLsmg_gotorc (int, int);
-SL_EXTERN void SLsmg_erase_eos (void);
-SL_EXTERN void SLsmg_reverse_video (void);
-SL_EXTERN void SLsmg_set_color (SLsmg_Color_Type);
-SL_EXTERN void SLsmg_normal_video (void);
-SL_EXTERN void SLsmg_printf (char *, ...) SLATTRIBUTE_PRINTF(1,2);
-/* SL_EXTERN void SLsmg_printf (char *, ...) SLATTRIBUTE_PRINTF(1,2); */
-SL_EXTERN void SLsmg_vprintf (char *, va_list);
-SL_EXTERN void SLsmg_write_string (char *);
-SL_EXTERN void SLsmg_write_nstring (char *, unsigned int);
-SL_EXTERN void SLsmg_write_chars (SLuchar_Type *u, SLuchar_Type *umax);
-SL_EXTERN void SLsmg_write_nchars (char *str, unsigned int len);
-SL_EXTERN void SLsmg_write_char (SLwchar_Type ch);
-SL_EXTERN void SLsmg_write_wrapped_string (SLuchar_Type *, int, int, unsigned int, unsigned int, int);
-SL_EXTERN void SLsmg_cls (void);
-SL_EXTERN void SLsmg_refresh (void);
-SL_EXTERN void SLsmg_touch_lines (int, unsigned int);
-SL_EXTERN void SLsmg_touch_screen (void);
-SL_EXTERN int SLsmg_init_smg (void);
-SL_EXTERN int SLsmg_reinit_smg (void);
-SL_EXTERN void SLsmg_reset_smg (void);
-SL_EXTERN int SLsmg_char_at (SLsmg_Char_Type *);
-SL_EXTERN void SLsmg_set_screen_start (int *, int *);
-SL_EXTERN void SLsmg_draw_hline (unsigned int);
-SL_EXTERN void SLsmg_draw_vline (int);
-SL_EXTERN void SLsmg_draw_object (int, int, SLwchar_Type);
-SL_EXTERN void SLsmg_draw_box (int, int, unsigned int, unsigned int);
-SL_EXTERN int SLsmg_get_column(void);
-SL_EXTERN int SLsmg_get_row(void);
-SL_EXTERN void SLsmg_forward (int);
-SL_EXTERN void SLsmg_write_color_chars (SLsmg_Char_Type *, unsigned int);
-SL_EXTERN unsigned int SLsmg_read_raw (SLsmg_Char_Type *, unsigned int);
-SL_EXTERN unsigned int SLsmg_write_raw (SLsmg_Char_Type *, unsigned int);
-SL_EXTERN void SLsmg_set_color_in_region (int, int, int, unsigned int, unsigned int);
-
-SL_EXTERN unsigned int SLsmg_strwidth (SLuchar_Type *u, SLuchar_Type *max);
-SL_EXTERN unsigned int SLsmg_strbytes (SLuchar_Type *u, SLuchar_Type *max, unsigned int width);
-SL_EXTERN int SLsmg_embedded_escape_mode (int on_or_off);
-SL_EXTERN int SLsmg_Display_Eight_Bit;
-SL_EXTERN int SLsmg_Tab_Width;
-
-#define SLSMG_NEWLINE_IGNORED	0      /* default */
-#define SLSMG_NEWLINE_MOVES	1      /* moves to next line, column 0 */
-#define SLSMG_NEWLINE_SCROLLS	2      /* moves but scrolls at bottom of screen */
-#define SLSMG_NEWLINE_PRINTABLE	3      /* prints as ^J */
-SL_EXTERN int SLsmg_Newline_Behavior;
-
-SL_EXTERN int SLsmg_Backspace_Moves;
-
-#ifdef IBMPC_SYSTEM
-# define SLSMG_HLINE_CHAR	0xC4
-# define SLSMG_VLINE_CHAR	0xB3
-# define SLSMG_ULCORN_CHAR	0xDA
-# define SLSMG_URCORN_CHAR	0xBF
-# define SLSMG_LLCORN_CHAR	0xC0
-# define SLSMG_LRCORN_CHAR	0xD9
-# define SLSMG_RTEE_CHAR	0xB4
-# define SLSMG_LTEE_CHAR	0xC3
-# define SLSMG_UTEE_CHAR	0xC2
-# define SLSMG_DTEE_CHAR	0xC1
-# define SLSMG_PLUS_CHAR	0xC5
-/* There are several to choose from: 0xB0, 0xB1, and 0xB2 */
-# define SLSMG_CKBRD_CHAR	0xB0
-# define SLSMG_DIAMOND_CHAR	0x04
-# define SLSMG_DEGREE_CHAR	0xF8
-# define SLSMG_PLMINUS_CHAR	0xF1
-# define SLSMG_BULLET_CHAR	0xF9
-# define SLSMG_LARROW_CHAR	0x1B
-# define SLSMG_RARROW_CHAR	0x1A
-# define SLSMG_DARROW_CHAR	0x19
-# define SLSMG_UARROW_CHAR	0x18
-# define SLSMG_BOARD_CHAR	0xB2
-# define SLSMG_BLOCK_CHAR	0xDB
-#else
-# if defined(AMIGA)
-#  define SLSMG_HLINE_CHAR	((unsigned char)'-')
-#  define SLSMG_VLINE_CHAR	((unsigned char)'|')
-#  define SLSMG_ULCORN_CHAR	((unsigned char)'+')
-#  define SLSMG_URCORN_CHAR	((unsigned char)'+')
-#  define SLSMG_LLCORN_CHAR	((unsigned char)'+')
-#  define SLSMG_LRCORN_CHAR	((unsigned char)'+')
-#  define SLSMG_CKBRD_CHAR	((unsigned char)'#')
-#  define SLSMG_RTEE_CHAR	((unsigned char)'+')
-#  define SLSMG_LTEE_CHAR	((unsigned char)'+')
-#  define SLSMG_UTEE_CHAR	((unsigned char)'+')
-#  define SLSMG_DTEE_CHAR	((unsigned char)'+')
-#  define SLSMG_PLUS_CHAR	((unsigned char)'+')
-#  define SLSMG_DIAMOND_CHAR	((unsigned char)'+')
-#  define SLSMG_DEGREE_CHAR	((unsigned char)'\\')
-#  define SLSMG_PLMINUS_CHAR	((unsigned char)'#')
-#  define SLSMG_BULLET_CHAR	((unsigned char)'o')
-#  define SLSMG_LARROW_CHAR	((unsigned char)'<')
-#  define SLSMG_RARROW_CHAR	((unsigned char)'>')
-#  define SLSMG_DARROW_CHAR	((unsigned char)'v')
-#  define SLSMG_UARROW_CHAR	((unsigned char)'^')
-#  define SLSMG_BOARD_CHAR	((unsigned char)'#')
-#  define SLSMG_BLOCK_CHAR	((unsigned char)'#')
-# else
-#  define SLSMG_HLINE_CHAR	((unsigned char)'q')
-#  define SLSMG_VLINE_CHAR	((unsigned char)'x')
-#  define SLSMG_ULCORN_CHAR	((unsigned char)'l')
-#  define SLSMG_URCORN_CHAR	((unsigned char)'k')
-#  define SLSMG_LLCORN_CHAR	((unsigned char)'m')
-#  define SLSMG_LRCORN_CHAR	((unsigned char)'j')
-#  define SLSMG_CKBRD_CHAR	((unsigned char)'a')
-#  define SLSMG_RTEE_CHAR	((unsigned char)'u')
-#  define SLSMG_LTEE_CHAR	((unsigned char)'t')
-#  define SLSMG_UTEE_CHAR	((unsigned char)'w')
-#  define SLSMG_DTEE_CHAR	((unsigned char)'v')
-#  define SLSMG_PLUS_CHAR	((unsigned char)'n')
-#  define SLSMG_DIAMOND_CHAR	((unsigned char)'`')
-#  define SLSMG_DEGREE_CHAR	((unsigned char)'f')
-#  define SLSMG_PLMINUS_CHAR	((unsigned char)'g')
-#  define SLSMG_BULLET_CHAR	((unsigned char)'~')
-#  define SLSMG_LARROW_CHAR	((unsigned char)',')
-#  define SLSMG_RARROW_CHAR	((unsigned char)'+')
-#  define SLSMG_DARROW_CHAR	((unsigned char)'.')
-#  define SLSMG_UARROW_CHAR	((unsigned char)'-')
-#  define SLSMG_BOARD_CHAR	((unsigned char)'h')
-#  define SLSMG_BLOCK_CHAR	((unsigned char)'0')
-# endif				       /* AMIGA */
-#endif				       /* IBMPC_SYSTEM */
-
-#ifndef IBMPC_SYSTEM
-# define SLSMG_COLOR_BLACK		0x000000
-# define SLSMG_COLOR_RED		0x000001
-# define SLSMG_COLOR_GREEN		0x000002
-# define SLSMG_COLOR_BROWN		0x000003
-# define SLSMG_COLOR_BLUE		0x000004
-# define SLSMG_COLOR_MAGENTA		0x000005
-# define SLSMG_COLOR_CYAN		0x000006
-# define SLSMG_COLOR_LGRAY		0x000007
-# define SLSMG_COLOR_GRAY		0x000008
-# define SLSMG_COLOR_BRIGHT_RED		0x000009
-# define SLSMG_COLOR_BRIGHT_GREEN	0x00000A
-# define SLSMG_COLOR_BRIGHT_BROWN	0x00000B
-# define SLSMG_COLOR_BRIGHT_BLUE	0x00000C
-# define SLSMG_COLOR_BRIGHT_CYAN	0x00000D
-# define SLSMG_COLOR_BRIGHT_MAGENTA	0x00000E
-# define SLSMG_COLOR_BRIGHT_WHITE	0x00000F
-#endif
-
-typedef struct
-{
-   void (*tt_normal_video)(void);
-   void (*tt_set_scroll_region)(int, int);
-   void (*tt_goto_rc)(int, int);
-   void (*tt_reverse_index)(int);
-   void (*tt_reset_scroll_region)(void);
-   void (*tt_delete_nlines)(int);
-   void (*tt_cls) (void);
-   void (*tt_del_eol) (void);
-   void (*tt_smart_puts) (SLsmg_Char_Type *, SLsmg_Char_Type *, int, int);
-   int (*tt_flush_output) (void);
-   int (*tt_reset_video) (void);
-   int (*tt_init_video) (void);
-
-   int *tt_screen_rows;
-   int *tt_screen_cols;
-
-   int *tt_term_cannot_scroll;
-#if 0
-   int *tt_use_blink_for_acs;
-#endif
-   int *tt_has_alt_charset;
-   char **tt_graphic_char_pairs;
-   int *unicode_ok;
-
-   long reserved[4];
-}
-SLsmg_Term_Type;
-SL_EXTERN void SLsmg_set_terminal_info (SLsmg_Term_Type *);
-
-/*}}}*/
-
-/*{{{ SLang Keypad Interface */
-
-#define SL_KEY_ERR		0xFFFF
-
-#define SL_KEY_UP		0x101
-#define SL_KEY_DOWN		0x102
-#define SL_KEY_LEFT		0x103
-#define SL_KEY_RIGHT		0x104
-#define SL_KEY_PPAGE		0x105
-#define SL_KEY_NPAGE		0x106
-#define SL_KEY_HOME		0x107
-#define SL_KEY_END		0x108
-#define SL_KEY_A1		0x109
-#define SL_KEY_A3		0x10A
-#define SL_KEY_B2		0x10B
-#define SL_KEY_C1		0x10C
-#define SL_KEY_C3		0x10D
-#define SL_KEY_REDO		0x10E
-#define SL_KEY_UNDO		0x10F
-#define SL_KEY_BACKSPACE	0x110
-#define SL_KEY_ENTER		0x111
-#define SL_KEY_IC		0x112
-#define SL_KEY_DELETE		0x113
-
-#define SL_KEY_F0		0x200
-#define SL_KEY_F(X)		(SL_KEY_F0 + X)
-
-/* I do not intend to use keysymps > 0x1000.  Applications can use those. */
-/* Returns 0 upon success or -1 upon error. */
-SL_EXTERN int SLkp_define_keysym (char *, unsigned int);
-
-/* This function must be called AFTER SLtt_get_terminfo and not before. */
-SL_EXTERN int SLkp_init (void);
-
-/* By default, SLang_getkey is used as the low-level function.  This hook
- * allows you to specify something else.
- */
-SL_EXTERN void SLkp_set_getkey_function (int (*)(void));
-
-/* This function uses SLang_getkey and assumes that what ever initialization
- * is required for SLang_getkey has been performed.  If you do not want 
- * SLang_getkey to be used, then specify another function via
- * SLkp_set_getkey_function.
- */
-SL_EXTERN int SLkp_getkey (void);
-
-/*}}}*/
-
-/*{{{ SLang Scroll Interface */
-
-typedef struct _pSLscroll_Type
-{
-   struct _pSLscroll_Type *next;
-   struct _pSLscroll_Type *prev;
-   unsigned int flags;
-}
-SLscroll_Type;
-
-typedef struct
-{
-   unsigned int flags;
-   SLscroll_Type *top_window_line;   /* list element at top of window */
-   SLscroll_Type *bot_window_line;   /* list element at bottom of window */
-   SLscroll_Type *current_line;    /* current list element */
-   SLscroll_Type *lines;	       /* first list element */
-   unsigned int nrows;		       /* number of rows in window */
-   unsigned int hidden_mask;	       /* applied to flags in SLscroll_Type */
-   unsigned int line_num;	       /* current line number (visible) */
-   unsigned int num_lines;	       /* total number of lines (visible) */
-   unsigned int window_row;	       /* row of current_line in window */
-   unsigned int border;		       /* number of rows that form scroll border */
-   int cannot_scroll;		       /* should window scroll or recenter */
-}
-SLscroll_Window_Type;
-
-SL_EXTERN int SLscroll_find_top (SLscroll_Window_Type *);
-SL_EXTERN int SLscroll_find_line_num (SLscroll_Window_Type *);
-SL_EXTERN unsigned int SLscroll_next_n (SLscroll_Window_Type *, unsigned int);
-SL_EXTERN unsigned int SLscroll_prev_n (SLscroll_Window_Type *, unsigned int);
-SL_EXTERN int SLscroll_pageup (SLscroll_Window_Type *);
-SL_EXTERN int SLscroll_pagedown (SLscroll_Window_Type *);
-
-/*}}}*/
-
-/*{{{ Signal Routines */
-
-typedef void SLSig_Fun_Type (int);
-SL_EXTERN SLSig_Fun_Type *SLsignal (int, SLSig_Fun_Type *);
-SL_EXTERN SLSig_Fun_Type *SLsignal_intr (int, SLSig_Fun_Type *);
-SL_EXTERN int SLsig_block_signals (void);
-SL_EXTERN int SLsig_unblock_signals (void);
-SL_EXTERN int SLsystem (char *);
-
-/* Make a signal off-limits to the interpreter */
-SL_EXTERN int SLsig_forbid_signal (int);
-
-SL_EXTERN char *SLerrno_strerror (int);
-SL_EXTERN int SLerrno_set_errno (int);
-
-/*}}}*/
-
-/* Functions for dealing with the FPU */
-SL_EXTERN void SLfpu_clear_except_bits (void);
-SL_EXTERN unsigned int SLfpu_test_except_bits (unsigned int bits);
-#define SL_FE_DIVBYZERO		0x01
-#define SL_FE_INVALID		0x02
-#define SL_FE_OVERFLOW		0x04
-#define SL_FE_UNDERFLOW		0x08
-#define SL_FE_INEXACT		0x10
-#define SL_FE_ALLEXCEPT		0x1F
-
-SL_EXTERN SLtype SLang_get_int_type (int nbits);
-/* if nbits is negative it gets the signed int type, else unsigned int type */
-SL_EXTERN int SLang_get_int_size (SLtype);
-/* Opposite of SLang_get_int_type */
-
-/*{{{ Interpreter Macro Definitions */
-
-/* The definitions here are for objects that may be on the run-time stack.
- * They are actually sub_types of literal and data main_types.  The actual
- * numbers are historical.
- */
-#define SLANG_UNDEFINED_TYPE	0x00   /* MUST be 0 */
-#define SLANG_VOID_TYPE		0x01   /* also matches ANY type */
-#define SLANG_NULL_TYPE		(0x02)
-#define SLANG_ANY_TYPE		(0x03)
-#define SLANG_DATATYPE_TYPE	(0x04)
-/* SLANG_REF_TYPE refers to an object on the stack that is a pointer (reference)
- * to some other object.
- */
-#define SLANG_REF_TYPE		(0x05)
-#define SLANG_STRING_TYPE	(0x06)
-#define SLANG_BSTRING_TYPE	(0x07)
-#define SLANG_FILE_PTR_TYPE	(0x08)
-#define SLANG_FILE_FD_TYPE	(0x09)
-#define SLANG_MD5_TYPE		(0x0A)
-#define SLANG_INTP_TYPE		(0x0F)
-
-/* Integer types */
-/* The integer and floating point types are arranged in order of arithmetic
- * precedence.
- */
-#define SLANG_CHAR_TYPE		(0x10)
-#define SLANG_UCHAR_TYPE	(0x11)
-#define SLANG_SHORT_TYPE	(0x12)
-#define SLANG_USHORT_TYPE	(0x13)
-#define SLANG_INT_TYPE 		(0x14)
-#define SLANG_UINT_TYPE		(0x15)
-#define SLANG_LONG_TYPE		(0x16)
-#define SLANG_ULONG_TYPE	(0x17)
-#define SLANG_LLONG_TYPE	(0x18)
-#define SLANG_ULLONG_TYPE	(0x19)
-/* floating point types */
-#define SLANG_FLOAT_TYPE	(0x1A)
-#define SLANG_DOUBLE_TYPE	(0x1B)
-#define SLANG_LDOUBLE_TYPE	(0x1C)
-
-#define SLANG_COMPLEX_TYPE	(0x20)
-
-/* An object of SLANG_INTP_TYPE should never really occur on the stack.  Rather,
- * the integer to which it refers will be there instead.  It is defined here
- * because it is a valid type for MAKE_VARIABLE.
- */
-
-/* Container types */
-#define SLANG_ISTRUCT_TYPE 	(0x2A)
-#define SLANG_STRUCT_TYPE	(0x2B)
-#define SLANG_ASSOC_TYPE	(0x2C)
-#define SLANG_ARRAY_TYPE	(0x2D)
-#define SLANG_LIST_TYPE		(0x2E)
-
-
-#define SLANG_MIN_UNUSED_TYPE	(0x30)
-
-/* Compatibility */
-#ifdef FLOAT_TYPE
-# undef FLOAT_TYPE
-#endif
-#define VOID_TYPE SLANG_VOID_TYPE
-#define INT_TYPE SLANG_INT_TYPE
-#define INTP_TYPE SLANG_INTP_TYPE
-#define FLOAT_TYPE SLANG_DOUBLE_TYPE
-#define ARRAY_TYPE SLANG_ARRAY_TYPE
-#define CHAR_TYPE SLANG_CHAR_TYPE
-#define STRING_TYPE SLANG_STRING_TYPE
-
-/* I am reserving values greater than or equal to 128 for user applications.
- * The first 127 are reserved for S-Lang.
- */
-
-/* Binary and Unary Subtypes */
-/* Since the application can define new types and can overload the binary
- * and unary operators, these definitions must be present in this file.
- * The current implementation assumes both unary and binary are distinct.
- */
-#define SLANG_BINARY_OP_MIN	0x01
-#define SLANG_PLUS		0x01
-#define SLANG_MINUS		0x02
-#define SLANG_TIMES		0x03
-#define SLANG_DIVIDE		0x04
-#define SLANG_EQ		0x05
-#define SLANG_NE		0x06
-#define SLANG_GT		0x07
-#define SLANG_GE		0x08
-#define SLANG_LT		0x09
-#define SLANG_LE		0x0A
-#define SLANG_POW		0x0B
-#define SLANG_OR		0x0C
-#define SLANG_AND		0x0D
-#define SLANG_BAND		0x0E
-#define SLANG_BOR		0x0F
-#define SLANG_BXOR		0x10
-#define SLANG_SHL		0x11
-#define SLANG_SHR		0x12
-#define SLANG_MOD		0x13
-#define SLANG_BINARY_OP_MAX	0x13
-
-/* UNARY subtypes  (may be overloaded) */
-#define SLANG_UNARY_OP_MIN	0x20
-
-#define SLANG_PLUSPLUS		0x20
-#define SLANG_MINUSMINUS	0x21
-#define SLANG_CHS		0x22
-#define SLANG_NOT		0x23
-#define SLANG_BNOT		0x24
-/* These are implemented as unary function calls */
-#define SLANG_ABS		0x25
-#define SLANG_SIGN		0x26
-#define SLANG_SQR		0x27
-#define SLANG_MUL2		0x28
-#define SLANG_ISPOS		0x29
-#define SLANG_ISNEG		0x2A
-#define SLANG_ISNONNEG		0x2B
-
-#define SLANG_UNARY_OP_MAX	0x2B
-
-SL_EXTERN char *SLang_Error_Message;
-
-SL_EXTERN int SLadd_intrinsic_variable (char *, VOID_STAR, SLtype, int);
-SL_EXTERN int SLadd_intrinsic_function (char *, FVOID_STAR, SLtype, unsigned int,...);
-
-SL_EXTERN int SLns_add_intrinsic_variable (SLang_NameSpace_Type *, char *, VOID_STAR, SLtype, int);
-SL_EXTERN int SLns_add_intrinsic_function (SLang_NameSpace_Type *, char *, FVOID_STAR, SLtype, unsigned int,...);
-
-#define MAKE_INTRINSIC_N(n,f,out,in,a1,a2,a3,a4,a5,a6,a7) \
-    {(n), NULL, SLANG_INTRINSIC, (FVOID_STAR) (f), \
-      {a1,a2,a3,a4,a5,a6,a7}, (in), (out)}
-
-#define MAKE_INTRINSIC_7(n,f,out,a1,a2,a3,a4,a5,a6,a7) \
-    MAKE_INTRINSIC_N(n,f,out,7,a1,a2,a3,a4,a5,a6,a7)
-#define MAKE_INTRINSIC_6(n,f,out,a1,a2,a3,a4,a5,a6) \
-    MAKE_INTRINSIC_N(n,f,out,6,a1,a2,a3,a4,a5,a6,0)
-#define MAKE_INTRINSIC_5(n,f,out,a1,a2,a3,a4,a5) \
-    MAKE_INTRINSIC_N(n,f,out,5,a1,a2,a3,a4,a5,0,0)
-#define MAKE_INTRINSIC_4(n,f,out,a1,a2,a3,a4) \
-    MAKE_INTRINSIC_N(n,f,out,4,a1,a2,a3,a4,0,0,0)
-#define MAKE_INTRINSIC_3(n,f,out,a1,a2,a3) \
-    MAKE_INTRINSIC_N(n,f,out,3,a1,a2,a3,0,0,0,0)
-#define MAKE_INTRINSIC_2(n,f,out,a1,a2) \
-    MAKE_INTRINSIC_N(n,f,out,2,a1,a2,0,0,0,0,0)
-#define MAKE_INTRINSIC_1(n,f,out,a1) \
-    MAKE_INTRINSIC_N(n,f,out,1,a1,0,0,0,0,0,0)
-#define MAKE_INTRINSIC_0(n,f,out) \
-    MAKE_INTRINSIC_N(n,f,out,0,0,0,0,0,0,0,0)
-
-#define MAKE_INTRINSIC_S(n,f,r) \
-   MAKE_INTRINSIC_1(n,f,r,SLANG_STRING_TYPE)
-#define MAKE_INTRINSIC_I(n,f,r) \
-   MAKE_INTRINSIC_1(n,f,r,SLANG_INT_TYPE)
-
-#define MAKE_INTRINSIC_SS(n,f,r) \
-   MAKE_INTRINSIC_2(n,f,r,SLANG_STRING_TYPE,SLANG_STRING_TYPE)
-#define MAKE_INTRINSIC_SI(n,f,r) \
-   MAKE_INTRINSIC_2(n,f,r,SLANG_STRING_TYPE,SLANG_INT_TYPE)
-#define MAKE_INTRINSIC_IS(n,f,r) \
-   MAKE_INTRINSIC_2(n,f,r,SLANG_INT_TYPE,SLANG_STRING_TYPE)
-#define MAKE_INTRINSIC_II(n,f,r) \
-   MAKE_INTRINSIC_2(n,f,r,SLANG_INT_TYPE,SLANG_INT_TYPE)
-
-#define MAKE_INTRINSIC_SSS(n,f,r) \
-   MAKE_INTRINSIC_3(n,f,r,SLANG_STRING_TYPE,SLANG_STRING_TYPE,SLANG_STRING_TYPE)
-#define MAKE_INTRINSIC_SSI(n,f,r) \
-   MAKE_INTRINSIC_3(n,f,r,SLANG_STRING_TYPE,SLANG_STRING_TYPE,SLANG_INT_TYPE)
-#define MAKE_INTRINSIC_SIS(n,f,r) \
-   MAKE_INTRINSIC_3(n,f,r,SLANG_STRING_TYPE,SLANG_INT_TYPE,SLANG_STRING_TYPE)
-#define MAKE_INTRINSIC_SII(n,f,r) \
-   MAKE_INTRINSIC_3(n,f,r,SLANG_STRING_TYPE,SLANG_INT_TYPE,SLANG_INT_TYPE)
-#define MAKE_INTRINSIC_ISS(n,f,r) \
-   MAKE_INTRINSIC_3(n,f,r,SLANG_INT_TYPE,SLANG_STRING_TYPE,SLANG_STRING_TYPE)
-#define MAKE_INTRINSIC_ISI(n,f,r) \
-   MAKE_INTRINSIC_3(n,f,r,SLANG_INT_TYPE,SLANG_STRING_TYPE,SLANG_INT_TYPE)
-#define MAKE_INTRINSIC_IIS(n,f,r) \
-   MAKE_INTRINSIC_3(n,f,r,SLANG_INT_TYPE,SLANG_INT_TYPE,SLANG_STRING_TYPE)
-#define MAKE_INTRINSIC_III(n,f,r) \
-   MAKE_INTRINSIC_3(n,f,r,SLANG_INT_TYPE,SLANG_INT_TYPE,SLANG_INT_TYPE)
-
-#define MAKE_INTRINSIC(n, f, out, in) \
-    MAKE_INTRINSIC_N(n,f,out,in,0,0,0,0,0,0,0)
-
-#define MAKE_VARIABLE(n, v, t, r)     \
-    {n, NULL, SLANG_IVARIABLE + (r), (VOID_STAR)(v), (t)}
-
-#define MAKE_APP_UNARY(n,op) \
-    {(n), NULL, SLANG_APP_UNARY, (op)}
-
-#define MAKE_ARITH_UNARY(n,op) \
-    {(n), NULL, SLANG_ARITH_UNARY, (op)}
-
-#define MAKE_ARITH_BINARY(n,op) \
-    {(n), NULL, SLANG_ARITH_BINARY, (op)}
-
-#define MAKE_MATH_UNARY(n,op) \
-    {(n), NULL, SLANG_MATH_UNARY, (op)}
-
-#define MAKE_HCONSTANT_T(n,val,T) \
-    {(n),NULL, SLANG_HCONSTANT, T, (short)(val)}
-#define MAKE_HCONSTANT(n,val) MAKE_HCONSTANT_T(n,val,SLANG_SHORT_TYPE)
-
-#define MAKE_ICONSTANT_T(n,val,T) \
-    {(n),NULL, SLANG_ICONSTANT, T, (int)(val)}
-#define MAKE_ICONSTANT(n,val) MAKE_ICONSTANT_T(n,val,SLANG_INT_TYPE)
-
-#define MAKE_LCONSTANT_T(n,val,T) \
-    {(n),NULL, SLANG_LCONSTANT, T, (int)(val)}
-#define MAKE_LCONSTANT(n,val) MAKE_LCONSTANT_T(n,val,SLANG_LONG_TYPE)
-
-#ifdef HAVE_LONG_LONG
-# define MAKE_LLCONSTANT_T(n,val,T) \
-    {(n),NULL, T, (long long)(val)}
-# define MAKE_LLCONSTANT(n,val) MAKE_LLCONSTANT_T(n,val,SLANG_LLONG_TYPE)
-#endif
-
-#define MAKE_FCONSTANT(n,val) \
-    {(n),NULL, SLANG_FCONSTANT, (val)}
-
-#define MAKE_DCONSTANT(n,val) \
-    {(n),NULL, SLANG_DCONSTANT, (val)}
-
-#ifndef offsetof
-# define offsetof(T,F) ((unsigned int)((char *)&((T *)0L)->F - (char *)0L))
-#endif
-
-#define MAKE_ISTRUCT_FIELD(s,f,n,t,r) {(n), offsetof(s,f), (t), (r)}
-#define MAKE_CSTRUCT_FIELD(s,f,n,t,r) {(n), offsetof(s,f), (t), (r)}
-
-#define MAKE_CSTRUCT_INT_FIELD(s,f,n,r) {(n), offsetof(s,f),\
-   (sizeof(((s*)0L)->f)==sizeof(int))?(SLANG_INT_TYPE): \
-   (sizeof(((s*)0L)->f)==sizeof(short))?(SLANG_SHORT_TYPE): \
-   (sizeof(((s*)0L)->f)==sizeof(char))?(SLANG_CHAR_TYPE): \
-   (sizeof(((s*)0L)->f)==sizeof(long))?(SLANG_LONG_TYPE): \
-   SLANG_LLONG_TYPE, (r)\
-}
-#define MAKE_CSTRUCT_UINT_FIELD(s,f,n,r) {(n), offsetof(s,f),\
-   (sizeof(((s*)0L)->f)==sizeof(int))?(SLANG_UINT_TYPE): \
-   (sizeof(((s*)0L)->f)==sizeof(short))?(SLANG_USHORT_TYPE): \
-   (sizeof(((s*)0L)->f)==sizeof(char))?(SLANG_UCHAR_TYPE): \
-   (sizeof(((s*)0L)->f)==sizeof(long))?(SLANG_ULONG_TYPE): \
-   SLANG_ULLONG_TYPE, (r)\
-}
-
-#define SLANG_END_TABLE {NULL}
-#define SLANG_END_INTRIN_FUN_TABLE MAKE_INTRINSIC_0(NULL,NULL,0)
-#define SLANG_END_FCONST_TABLE MAKE_DCONSTANT(NULL,0)
-#define SLANG_END_DCONST_TABLE MAKE_DCONSTANT(NULL,0)
-#define SLANG_END_MATH_UNARY_TABLE MAKE_MATH_UNARY(NULL,0)
-#define SLANG_END_ARITH_UNARY_TABLE MAKE_ARITH_UNARY(NULL,0)
-#define SLANG_END_ARITH_BINARY_TABLE MAKE_ARITH_BINARY(NULL,0)
-#define SLANG_END_APP_UNARY_TABLE MAKE_APP_UNARY(NULL,0)
-#define SLANG_END_INTRIN_VAR_TABLE MAKE_VARIABLE(NULL,NULL,0,0)
-#define SLANG_END_ICONST_TABLE MAKE_ICONSTANT(NULL,0)
-#define SLANG_END_LLCONST_TABLE MAKE_LLCONSTANT(NULL,0)
-#define SLANG_END_ISTRUCT_TABLE {NULL, 0, 0, 0}
-#define SLANG_END_CSTRUCT_TABLE {NULL, 0, 0, 0}
-   
-
-/*}}}*/
-
-/*{{{ Upper/Lowercase Functions */
-
-SL_EXTERN void SLang_define_case(int *, int *);
-SL_EXTERN void SLang_init_case_tables (void);
-
-SL_EXTERN unsigned char _pSLChg_UCase_Lut[256];
-SL_EXTERN unsigned char _pSLChg_LCase_Lut[256];
-#define UPPER_CASE(x) (_pSLChg_UCase_Lut[(unsigned char) (x)])
-#define LOWER_CASE(x) (_pSLChg_LCase_Lut[(unsigned char) (x)])
-#define CHANGE_CASE(x) (((x) == _pSLChg_LCase_Lut[(unsigned char) (x)]) ?\
-			_pSLChg_UCase_Lut[(unsigned char) (x)] : _pSLChg_LCase_Lut[(unsigned char) (x)])
-
-/*}}}*/
-
-/*{{{ Regular Expression Interface */
-typedef struct _pSLRegexp_Type SLRegexp_Type;
-SL_EXTERN SLRegexp_Type *SLregexp_compile (char *pattern, unsigned int flags);
-#define SLREGEXP_CASELESS	0x01
-#define SLREGEXP_UTF8		0x10
-
-SL_EXTERN void SLregexp_free (SLRegexp_Type *);
-SL_EXTERN char *SLregexp_match (SLRegexp_Type *compiled_regexp, char *str, unsigned int len);
-SL_EXTERN int SLregexp_nth_match (SLRegexp_Type *, unsigned int nth, unsigned int *ofsp, unsigned int *lenp);
-
-SL_EXTERN int SLregexp_get_hints (SLRegexp_Type *, unsigned int *flagsp);
-#define SLREGEXP_HINT_BOL		0x01   /* pattern must match bol */
-#define SLREGEXP_HINT_OSEARCH		0x02   /* ordinary search will do */
-
-SL_EXTERN char *SLregexp_quote_string (char *, char *, unsigned int);
-
-/*}}}*/
-
-/*{{{ SLang Command Interface */
-
-struct _pSLcmd_Cmd_Type; /* Pre-declaration is needed below */
-typedef struct
-{
-   struct _pSLcmd_Cmd_Type *table;
-   int argc;
-   /* Version 2.0 needs to use a union!! */
-   char **string_args;
-   int *int_args;
-   double *double_args;
-   SLtype *arg_type;
-   unsigned long reserved[4];
-} SLcmd_Cmd_Table_Type;
-
-typedef struct _pSLcmd_Cmd_Type
-{
-   int (*cmdfun)(int, SLcmd_Cmd_Table_Type *);
-   char *cmd;
-   char *arg_type;
-} SLcmd_Cmd_Type;
-
-SL_EXTERN int SLcmd_execute_string (char *, SLcmd_Cmd_Table_Type *);
-
-/*}}}*/
-
-/*{{{ SLang Search Interface */
-
-typedef struct _pSLsearch_Type SLsearch_Type;
-SL_EXTERN SLsearch_Type *SLsearch_new (SLuchar_Type *u, int search_flags);
-#define SLSEARCH_CASELESS	0x1
-#define SLSEARCH_UTF8		0x2
-
-SL_EXTERN void SLsearch_delete (SLsearch_Type *);
-
-
-SL_EXTERN SLuchar_Type *SLsearch_forward (SLsearch_Type *st,
-                                        SLuchar_Type *pmin, SLuchar_Type *pmax);
-SL_EXTERN SLuchar_Type *SLsearch_backward (SLsearch_Type *st,
-                                         SLuchar_Type *pmin, SLuchar_Type *pstart, SLuchar_Type *pmax);
-SL_EXTERN unsigned int SLsearch_match_len (SLsearch_Type *);
-
-/*}}}*/
-
-/*{{{ SLang Pathname Interface */
-
-/* These function return pointers to the original space */
-SL_EXTERN char *SLpath_basename (char *);
-SL_EXTERN char *SLpath_extname (char *);
-
-SL_EXTERN int SLpath_is_absolute_path (char *);
-
-/* Get and set the character delimiter for search paths */
-SL_EXTERN int SLpath_get_delimiter (void);
-SL_EXTERN int SLpath_set_delimiter (int);
-
-/* search path for loading .sl files */
-SL_EXTERN int SLpath_set_load_path (char *);   
-/* search path for loading .sl files --- returns slstring */
-SL_EXTERN char *SLpath_get_load_path (void);   
-
-/* These return malloced strings--- NOT slstrings */
-SL_EXTERN char *SLpath_dircat (char *, char *);
-SL_EXTERN char *SLpath_find_file_in_path (char *, char *);
-SL_EXTERN char *SLpath_dirname (char *);
-SL_EXTERN int SLpath_file_exists (char *);
-SL_EXTERN char *SLpath_pathname_sans_extname (char *);
-
-/*}}}*/
-
-SL_EXTERN int SLang_set_module_load_path (char *);
-
-#ifdef __cplusplus
-# define SLANG_MODULE(name) \
-   extern SL_EXPORT "C" int init_##name##_module_ns (char *); \
-   extern SL_EXPORT "C" void deinit_##name##_module (void); \
-   extern SL_EXPORT "C" int SLmodule_##name##_api_version; \
-   SL_EXPORT int SLmodule_##name##_api_version = SLANG_VERSION
-#else
-# define SLANG_MODULE(name) \
-   extern SL_EXPORT int init_##name##_module_ns (char *); \
-   extern SL_EXPORT void deinit_##name##_module (void); \
-   SL_EXPORT int SLmodule_##name##_api_version = SLANG_VERSION
-#endif
-
-SL_EXTERN int SLvsnprintf (char *, unsigned int, char *, va_list);
-SL_EXTERN int SLsnprintf (char *, unsigned int, char *, ...);
-
-#if 0
-{
-#endif
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* DAVIS_SLANG_H_ */
diff --git a/slang/include/slinclud.h b/slang/include/slinclud.h
deleted file mode 100644
index 5367bef..0000000
--- a/slang/include/slinclud.h
+++ /dev/null
@@ -1,31 +0,0 @@
-#ifndef _SLANG_INCLUDE_H_
-#define _SLANG_INCLUDE_H_
-
-#define SLANG_SOURCE_	1
-#include "config.h"
-#include "sl-feat.h"
-
-#include <stdio.h>
-#include <string.h>
-
-#if defined(__QNX__) && defined(__WATCOMC__)
-# include <unix.h>
-#endif
-  
-#ifdef HAVE_STDLIB_H
-# include <stdlib.h>
-#endif
-
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-
-#ifdef HAVE_MALLOC_H
-# include <malloc.h>
-#endif
-
-#ifdef HAVE_MEMORY_H
-# include <memory.h>
-#endif
-
-#endif				       /* _SLANG_INCLUDE_H_ */
diff --git a/slang/include/sllimits.h b/slang/include/sllimits.h
deleted file mode 100644
index e4e819d..0000000
--- a/slang/include/sllimits.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/* sllimits.h */
-/*
-Copyright (C) 2004, 2005 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-#define USE_NEW_HASH_CODE	1
-
-#define SLSTRING_HASH_TABLE_SIZE	10007
-#if 0
-/* slstring.c: Size of the hash table used for strings (prime numbers) */
-#ifdef __MSDOS_16BIT__
-# define SLSTRING_HASH_TABLE_SIZE	601
-#else
-# define SLSTRING_HASH_TABLE_SIZE	6007 /* 2909 */
-#endif
-#endif
-
-/* slang.c: maximum size of run time stack */
-#ifdef __MSDOS_16BIT__
-# define SLANG_MAX_STACK_LEN		500
-#else
-# define SLANG_MAX_STACK_LEN		2500
-#endif
-
-/* slang.c: This sets the size on the depth of function calls */
-#ifdef __MSDOS_16BIT__
-# define SLANG_MAX_RECURSIVE_DEPTH	50
-#else
-# define SLANG_MAX_RECURSIVE_DEPTH	2500
-#endif
-
-/* slang.c: Size of the stack used for local variables */
-#ifdef __MSDOS_16BIT__
-# define SLANG_MAX_LOCAL_STACK		200
-#else
-# define SLANG_MAX_LOCAL_STACK		4096
-#endif
-
-/* slang.c: The size of the hash table used for local and global objects.
- * These should be prime numbers.
- */
-#if USE_NEW_HASH_CODE
-# define SLGLOBALS_HASH_TABLE_SIZE	2048
-# define SLLOCALS_HASH_TABLE_SIZE	64
-# define SLSTATIC_HASH_TABLE_SIZE	64
-#else
-# define SLGLOBALS_HASH_TABLE_SIZE	2909
-# define SLLOCALS_HASH_TABLE_SIZE	73
-# define SLSTATIC_HASH_TABLE_SIZE	73
-#endif
-
-/* Size of the keyboard buffer use by the ungetkey routines */
-#ifdef __MSDOS_16BIT__
-# define SL_MAX_INPUT_BUFFER_LEN	40
-#else
-# define SL_MAX_INPUT_BUFFER_LEN	1024
-#endif
-
-/* Maximum number of nested switch statements */
-#define SLANG_MAX_NESTED_SWITCH		10
-
-/* Size of the block stack (used in byte-compiling) */
-#define SLANG_MAX_BLOCK_STACK_LEN	50
-
-/* slfile.c: Max number of open file pointers */
-#ifdef __MSDOS_16BIT__
-# define SL_MAX_FILES			32
-#else
-# define SL_MAX_FILES			256
-#endif
-
-#if !defined(__MSDOS_16BIT__)
-# define SLTT_MAX_SCREEN_COLS 512
-# define SLTT_MAX_SCREEN_ROWS 512
-#else
-# define SLTT_MAX_SCREEN_ROWS 64
-# define SLTT_MAX_SCREEN_COLS 75
-#endif
-
diff --git a/slang/include/sllower.h b/slang/include/sllower.h
deleted file mode 100644
index 65cbc15..0000000
--- a/slang/include/sllower.h
+++ /dev/null
@@ -1,460 +0,0 @@
-/* This file was automatically created by ./mktables */
-#define SL_TOLOWER_MAX_CHAR 0x10480ul
-
-#define SL_TOLOWER_LOOKUP(x) \
-  (((unsigned)(x)>=SL_TOLOWER_MAX_CHAR)?0:(_pSLwc_Tolower_Table[(unsigned)(x)>>7][(unsigned)(x)&0x7F]))
-
-extern const short *_pSLwc_Tolower_Table[521];
-
-#ifdef DEFINE_PSLWC_TOLOWER_TABLE
-static const short Table_00[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_01[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,    32,    32,    32,    32,    32,    32,    32,
-  /*0x48-0x4F*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x50-0x57*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x58-0x5F*/    32,    32,    32,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_02[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x48-0x4F*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x50-0x57*/    32,    32,    32,    32,    32,    32,    32,     0,
-  /*0x58-0x5F*/    32,    32,    32,    32,    32,    32,    32,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_03[128] =
-{
-  /*0x00-0x07*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x08-0x0F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x10-0x17*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x18-0x1F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x20-0x27*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x28-0x2F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x30-0x37*/  -199,     0,     1,     0,     1,     0,     1,     0,
-  /*0x38-0x3F*/     0,     1,     0,     1,     0,     1,     0,     1,
-  /*0x40-0x47*/     0,     1,     0,     1,     0,     1,     0,     1,
-  /*0x48-0x4F*/     0,     0,     1,     0,     1,     0,     1,     0,
-  /*0x50-0x57*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x58-0x5F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x60-0x67*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x68-0x6F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x70-0x77*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x78-0x7F*/  -121,     1,     0,     1,     0,     1,     0,     0
-};
-
-static const short Table_04[128] =
-{
-  /*0x00-0x07*/     0,   210,     1,     0,     1,     0,   206,     1,
-  /*0x08-0x0F*/     0,   205,   205,     1,     0,     0,    79,   202,
-  /*0x10-0x17*/   203,     1,     0,   205,   207,     0,   211,   209,
-  /*0x18-0x1F*/     1,     0,     0,     0,   211,   213,     0,   214,
-  /*0x20-0x27*/     1,     0,     1,     0,     1,     0,   218,     1,
-  /*0x28-0x2F*/     0,   218,     0,     0,     1,     0,   218,     1,
-  /*0x30-0x37*/     0,   217,   217,     1,     0,     1,     0,   219,
-  /*0x38-0x3F*/     1,     0,     0,     0,     1,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     2,     1,     0,     2,
-  /*0x48-0x4F*/     1,     0,     2,     1,     0,     1,     0,     1,
-  /*0x50-0x57*/     0,     1,     0,     1,     0,     1,     0,     1,
-  /*0x58-0x5F*/     0,     1,     0,     1,     0,     0,     1,     0,
-  /*0x60-0x67*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x68-0x6F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x70-0x77*/     0,     2,     1,     0,     1,     0,   -97,   -56,
-  /*0x78-0x7F*/     1,     0,     1,     0,     1,     0,     1,     0
-};
-
-static const short Table_05[128] =
-{
-  /*0x00-0x07*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x08-0x0F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x10-0x17*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x18-0x1F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x20-0x27*/  -130,     0,     1,     0,     1,     0,     1,     0,
-  /*0x28-0x2F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x30-0x37*/     1,     0,     1,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_06[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,    38,     0,
-  /*0x08-0x0F*/    37,    37,    37,     0,    64,     0,    63,    63,
-  /*0x10-0x17*/     0,    32,    32,    32,    32,    32,    32,    32,
-  /*0x18-0x1F*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x20-0x27*/    32,    32,     0,    32,    32,    32,    32,    32,
-  /*0x28-0x2F*/    32,    32,    32,    32,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x60-0x67*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x68-0x6F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,   -60,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_07[128] =
-{
-  /*0x00-0x07*/    80,    80,    80,    80,    80,    80,    80,    80,
-  /*0x08-0x0F*/    80,    80,    80,    80,    80,    80,    80,    80,
-  /*0x10-0x17*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x18-0x1F*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x20-0x27*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x28-0x2F*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x68-0x6F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x70-0x77*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x78-0x7F*/     1,     0,     1,     0,     1,     0,     1,     0
-};
-
-static const short Table_08[128] =
-{
-  /*0x00-0x07*/     1,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     1,     0,     1,     0,     1,     0,
-  /*0x10-0x17*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x18-0x1F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x20-0x27*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x28-0x2F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x30-0x37*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x38-0x3F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x40-0x47*/     0,     1,     0,     1,     0,     1,     0,     1,
-  /*0x48-0x4F*/     0,     1,     0,     1,     0,     1,     0,     0,
-  /*0x50-0x57*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x58-0x5F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x60-0x67*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x68-0x6F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x70-0x77*/     1,     0,     1,     0,     1,     0,     0,     0,
-  /*0x78-0x7F*/     1,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_09[128] =
-{
-  /*0x00-0x07*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x08-0x0F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,    48,    48,    48,    48,    48,    48,    48,
-  /*0x38-0x3F*/    48,    48,    48,    48,    48,    48,    48,    48,
-  /*0x40-0x47*/    48,    48,    48,    48,    48,    48,    48,    48,
-  /*0x48-0x4F*/    48,    48,    48,    48,    48,    48,    48,    48,
-  /*0x50-0x57*/    48,    48,    48,    48,    48,    48,    48,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_10[128] =
-{
-  /*0x00-0x07*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x08-0x0F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x10-0x17*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x18-0x1F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x20-0x27*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x28-0x2F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x30-0x37*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x38-0x3F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x40-0x47*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x48-0x4F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x50-0x57*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x58-0x5F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x60-0x67*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x68-0x6F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x70-0x77*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x78-0x7F*/     1,     0,     1,     0,     1,     0,     1,     0
-};
-
-static const short Table_11[128] =
-{
-  /*0x00-0x07*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x08-0x0F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x10-0x17*/     1,     0,     1,     0,     1,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x28-0x2F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x30-0x37*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x38-0x3F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x40-0x47*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x48-0x4F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x50-0x57*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x58-0x5F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x60-0x67*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x68-0x6F*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x70-0x77*/     1,     0,     1,     0,     1,     0,     1,     0,
-  /*0x78-0x7F*/     1,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_12[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/    -8,    -8,    -8,    -8,    -8,    -8,    -8,    -8,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/    -8,    -8,    -8,    -8,    -8,    -8,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/    -8,    -8,    -8,    -8,    -8,    -8,    -8,    -8,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/    -8,    -8,    -8,    -8,    -8,    -8,    -8,    -8,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/    -8,    -8,    -8,    -8,    -8,    -8,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,    -8,     0,    -8,     0,    -8,     0,    -8,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/    -8,    -8,    -8,    -8,    -8,    -8,    -8,    -8,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_13[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/    -8,    -8,    -8,    -8,    -8,    -8,    -8,    -8,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/    -8,    -8,    -8,    -8,    -8,    -8,    -8,    -8,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/    -8,    -8,    -8,    -8,    -8,    -8,    -8,    -8,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/    -8,    -8,   -74,   -74,    -9,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/   -86,   -86,   -86,   -86,    -9,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/    -8,    -8,  -100,  -100,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/    -8,    -8,  -112,  -112,    -7,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/  -128,  -128,  -126,  -126,    -9,     0,     0,     0
-};
-
-static const short Table_14[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0, -7517,     0,
-  /*0x28-0x2F*/     0,     0, -8383, -8262,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/    16,    16,    16,    16,    16,    16,    16,    16,
-  /*0x68-0x6F*/    16,    16,    16,    16,    16,    16,    16,    16,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_15[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,    26,    26,
-  /*0x38-0x3F*/    26,    26,    26,    26,    26,    26,    26,    26,
-  /*0x40-0x47*/    26,    26,    26,    26,    26,    26,    26,    26,
-  /*0x48-0x4F*/    26,    26,    26,    26,    26,    26,    26,    26,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_16[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,    32,    32,    32,    32,    32,    32,    32,
-  /*0x28-0x2F*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x30-0x37*/    32,    32,    32,    32,    32,    32,    32,    32,
-  /*0x38-0x3F*/    32,    32,    32,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_17[128] =
-{
-  /*0x00-0x07*/    40,    40,    40,    40,    40,    40,    40,    40,
-  /*0x08-0x0F*/    40,    40,    40,    40,    40,    40,    40,    40,
-  /*0x10-0x17*/    40,    40,    40,    40,    40,    40,    40,    40,
-  /*0x18-0x1F*/    40,    40,    40,    40,    40,    40,    40,    40,
-  /*0x20-0x27*/    40,    40,    40,    40,    40,    40,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-const short *_pSLwc_Tolower_Table[521] =
-{
-  Table_01,  Table_02,  Table_03,  Table_04,  Table_05,  Table_00,
-  Table_00,  Table_06,  Table_07,  Table_08,  Table_09,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_10,  Table_11,  Table_12,  Table_13,  Table_00,  Table_00,
-  Table_14,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_15,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_16,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_17
-};
-#endif /* DEFINE_PSLWC_TOLOWER_TABLE */
diff --git a/slang/include/slupper.h b/slang/include/slupper.h
deleted file mode 100644
index 57dfd79..0000000
--- a/slang/include/slupper.h
+++ /dev/null
@@ -1,520 +0,0 @@
-/* This file was automatically created by ./mktables */
-#define SL_TOUPPER_MAX_CHAR 0x10480ul
-
-#define SL_TOUPPER_LOOKUP(x) \
-  (((unsigned)(x)>=SL_TOUPPER_MAX_CHAR)?0:(_pSLwc_Toupper_Table[(unsigned)(x)>>7][(unsigned)(x)&0x7F]))
-
-extern const short *_pSLwc_Toupper_Table[521];
-
-#ifdef DEFINE_PSLWC_TOUPPER_TABLE
-static const short Table_00[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_01[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x68-0x6F*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x70-0x77*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x78-0x7F*/   -32,   -32,   -32,     0,     0,     0,     0,     0
-};
-
-static const short Table_02[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,   743,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x68-0x6F*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x70-0x77*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,     0,
-  /*0x78-0x7F*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   121
-};
-
-static const short Table_03[128] =
-{
-  /*0x00-0x07*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x08-0x0F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x10-0x17*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x18-0x1F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x20-0x27*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x28-0x2F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x30-0x37*/     0,  -232,     0,    -1,     0,    -1,     0,    -1,
-  /*0x38-0x3F*/     0,     0,    -1,     0,    -1,     0,    -1,     0,
-  /*0x40-0x47*/    -1,     0,    -1,     0,    -1,     0,    -1,     0,
-  /*0x48-0x4F*/    -1,     0,     0,    -1,     0,    -1,     0,    -1,
-  /*0x50-0x57*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x58-0x5F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x60-0x67*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x68-0x6F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x70-0x77*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x78-0x7F*/     0,     0,    -1,     0,    -1,     0,    -1,  -300
-};
-
-static const short Table_04[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,    -1,     0,    -1,     0,     0,
-  /*0x08-0x0F*/    -1,     0,     0,     0,    -1,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,    -1,     0,     0,    97,     0,     0,
-  /*0x18-0x1F*/     0,    -1,     0,     0,     0,     0,   130,     0,
-  /*0x20-0x27*/     0,    -1,     0,    -1,     0,    -1,     0,     0,
-  /*0x28-0x2F*/    -1,     0,     0,     0,     0,    -1,     0,     0,
-  /*0x30-0x37*/    -1,     0,     0,     0,    -1,     0,    -1,     0,
-  /*0x38-0x3F*/     0,    -1,     0,     0,     0,    -1,     0,    56,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,    -1,    -2,     0,
-  /*0x48-0x4F*/    -1,    -2,     0,    -1,    -2,     0,    -1,     0,
-  /*0x50-0x57*/    -1,     0,    -1,     0,    -1,     0,    -1,     0,
-  /*0x58-0x5F*/    -1,     0,    -1,     0,    -1,   -79,     0,    -1,
-  /*0x60-0x67*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x68-0x6F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x70-0x77*/     0,     0,    -1,    -2,     0,    -1,     0,     0,
-  /*0x78-0x7F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1
-};
-
-static const short Table_05[128] =
-{
-  /*0x00-0x07*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x08-0x0F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x10-0x17*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x18-0x1F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x20-0x27*/     0,     0,     0,    -1,     0,    -1,     0,    -1,
-  /*0x28-0x2F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x30-0x37*/     0,    -1,     0,    -1,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,  -210,  -206,     0,  -205,  -205,
-  /*0x58-0x5F*/     0,  -202,     0,  -203,     0,     0,     0,     0,
-  /*0x60-0x67*/  -205,     0,     0,  -207,     0,     0,     0,     0,
-  /*0x68-0x6F*/  -209,  -211,     0,     0,     0,     0,     0,  -211,
-  /*0x70-0x77*/     0,     0,  -213,     0,     0,  -214,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_06[128] =
-{
-  /*0x00-0x07*/  -218,     0,     0,  -218,     0,     0,     0,     0,
-  /*0x08-0x0F*/  -218,     0,  -217,  -217,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,  -219,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_07[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,    84,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_08[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,   -38,   -37,   -37,   -37,
-  /*0x30-0x37*/     0,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x38-0x3F*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x40-0x47*/   -32,   -32,   -31,   -32,   -32,   -32,   -32,   -32,
-  /*0x48-0x4F*/   -32,   -32,   -32,   -32,   -64,   -63,   -63,     0,
-  /*0x50-0x57*/   -62,   -57,     0,     0,     0,   -47,   -54,     0,
-  /*0x58-0x5F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x60-0x67*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x68-0x6F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x70-0x77*/   -86,   -80,   -79,     0,     0,   -96,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_09[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x38-0x3F*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x40-0x47*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x48-0x4F*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x50-0x57*/   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
-  /*0x58-0x5F*/   -80,   -80,   -80,   -80,   -80,   -80,   -80,   -80,
-  /*0x60-0x67*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x68-0x6F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x70-0x77*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x78-0x7F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1
-};
-
-static const short Table_10[128] =
-{
-  /*0x00-0x07*/     0,    -1,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,    -1,     0,    -1,     0,    -1,
-  /*0x10-0x17*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x18-0x1F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x20-0x27*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x28-0x2F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x30-0x37*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x38-0x3F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x40-0x47*/     0,     0,    -1,     0,    -1,     0,    -1,     0,
-  /*0x48-0x4F*/    -1,     0,    -1,     0,    -1,     0,    -1,     0,
-  /*0x50-0x57*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x58-0x5F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x60-0x67*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x68-0x6F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x70-0x77*/     0,    -1,     0,    -1,     0,    -1,     0,     0,
-  /*0x78-0x7F*/     0,    -1,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_11[128] =
-{
-  /*0x00-0x07*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x08-0x0F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,   -48,   -48,   -48,   -48,   -48,   -48,   -48,
-  /*0x68-0x6F*/   -48,   -48,   -48,   -48,   -48,   -48,   -48,   -48,
-  /*0x70-0x77*/   -48,   -48,   -48,   -48,   -48,   -48,   -48,   -48,
-  /*0x78-0x7F*/   -48,   -48,   -48,   -48,   -48,   -48,   -48,   -48
-};
-
-static const short Table_12[128] =
-{
-  /*0x00-0x07*/   -48,   -48,   -48,   -48,   -48,   -48,   -48,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_13[128] =
-{
-  /*0x00-0x07*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x08-0x0F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x10-0x17*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x18-0x1F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x20-0x27*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x28-0x2F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x30-0x37*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x38-0x3F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x40-0x47*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x48-0x4F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x50-0x57*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x58-0x5F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x60-0x67*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x68-0x6F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x70-0x77*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x78-0x7F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1
-};
-
-static const short Table_14[128] =
-{
-  /*0x00-0x07*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x08-0x0F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x10-0x17*/     0,    -1,     0,    -1,     0,    -1,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,   -59,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x28-0x2F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x30-0x37*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x38-0x3F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x40-0x47*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x48-0x4F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x50-0x57*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x58-0x5F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x60-0x67*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x68-0x6F*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x70-0x77*/     0,    -1,     0,    -1,     0,    -1,     0,    -1,
-  /*0x78-0x7F*/     0,    -1,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_15[128] =
-{
-  /*0x00-0x07*/     8,     8,     8,     8,     8,     8,     8,     8,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     8,     8,     8,     8,     8,     8,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     8,     8,     8,     8,     8,     8,     8,     8,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     8,     8,     8,     8,     8,     8,     8,     8,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     8,     8,     8,     8,     8,     8,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     8,     0,     8,     0,     8,     0,     8,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     8,     8,     8,     8,     8,     8,     8,     8,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/    74,    74,    86,    86,    86,    86,   100,   100,
-  /*0x78-0x7F*/   128,   128,   112,   112,   126,   126,     0,     0
-};
-
-static const short Table_16[128] =
-{
-  /*0x00-0x07*/     8,     8,     8,     8,     8,     8,     8,     8,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     8,     8,     8,     8,     8,     8,     8,     8,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     8,     8,     8,     8,     8,     8,     8,     8,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     8,     8,     0,     9,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0, -7205,     0,
-  /*0x40-0x47*/     0,     0,     0,     9,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     8,     8,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     8,     8,     0,     0,     0,     7,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     9,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_17[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/   -16,   -16,   -16,   -16,   -16,   -16,   -16,   -16,
-  /*0x78-0x7F*/   -16,   -16,   -16,   -16,   -16,   -16,   -16,   -16
-};
-
-static const short Table_18[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x48-0x4F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x50-0x57*/   -26,   -26,   -26,   -26,   -26,   -26,   -26,   -26,
-  /*0x58-0x5F*/   -26,   -26,   -26,   -26,   -26,   -26,   -26,   -26,
-  /*0x60-0x67*/   -26,   -26,   -26,   -26,   -26,   -26,   -26,   -26,
-  /*0x68-0x6F*/   -26,   -26,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_19[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x30-0x37*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x38-0x3F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x40-0x47*/     0,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x48-0x4F*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x50-0x57*/   -32,   -32,   -32,   -32,   -32,   -32,   -32,   -32,
-  /*0x58-0x5F*/   -32,   -32,   -32,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-static const short Table_20[128] =
-{
-  /*0x00-0x07*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x08-0x0F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x10-0x17*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x18-0x1F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x20-0x27*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x28-0x2F*/   -40,   -40,   -40,   -40,   -40,   -40,   -40,   -40,
-  /*0x30-0x37*/   -40,   -40,   -40,   -40,   -40,   -40,   -40,   -40,
-  /*0x38-0x3F*/   -40,   -40,   -40,   -40,   -40,   -40,   -40,   -40,
-  /*0x40-0x47*/   -40,   -40,   -40,   -40,   -40,   -40,   -40,   -40,
-  /*0x48-0x4F*/   -40,   -40,   -40,   -40,   -40,   -40,     0,     0,
-  /*0x50-0x57*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x58-0x5F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x60-0x67*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x68-0x6F*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x70-0x77*/     0,     0,     0,     0,     0,     0,     0,     0,
-  /*0x78-0x7F*/     0,     0,     0,     0,     0,     0,     0,     0
-};
-
-const short *_pSLwc_Toupper_Table[521] =
-{
-  Table_01,  Table_02,  Table_03,  Table_04,  Table_05,  Table_06,
-  Table_07,  Table_08,  Table_09,  Table_10,  Table_11,  Table_12,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_13,  Table_14,  Table_15,  Table_16,  Table_00,  Table_00,
-  Table_17,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_18,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_19,  Table_00,  Table_00,  Table_00,  Table_00,  Table_00,
-  Table_00,  Table_00,  Table_00,  Table_00,  Table_20
-};
-#endif /* DEFINE_PSLWC_TOUPPER_TABLE */
diff --git a/slang/include/slwcwidth.h b/slang/include/slwcwidth.h
deleted file mode 100644
index af9fd8e..0000000
--- a/slang/include/slwcwidth.h
+++ /dev/null
@@ -1,1460 +0,0 @@
-/* This file was automatically created by ./mktables */
-#define SL_WIDTH_MAX_CHAR 0x110000ul
-
-#define SL_WIDTH_ALOOKUP(y,x) \
-{ \
-   const unsigned char *_t; \
-   (y) = (((unsigned)(x) < SL_WIDTH_MAX_CHAR) \
-	  && (NULL != (_t = _pSLwc_Width_Table[(unsigned)(x)>>9])) \
-	  ? ((_t[(unsigned)((x)>>1)&0xFF]>>(4*((x)&1)))&15) : 1); \
-}
-extern const unsigned char *_pSLwc_Width_Table[2176];
-
-#ifdef DEFINE_PSLWC_WIDTH_TABLE
-static const unsigned char Table_01[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
-  /*0x48-0x4F*/ 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_02[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x88-0x8F*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x90-0x97*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x98-0x9F*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xA0-0xA7*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_03[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x01, 0x00, 0x10, 0x00, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xD0-0xD7*/ 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xD8-0xDF*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
-  /*0xE0-0xE7*/ 0x01, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_04[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x01, 0x00, 0x00,
-  /*0x28-0x2F*/ 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x70-0x77*/ 0x00, 0x00, 0x10, 0x01, 0x10, 0x00, 0x00, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x01,
-  /*0x88-0x8F*/ 0x01, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xA0-0xA7*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xD8-0xDF*/ 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_05[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x01, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x00,
-  /*0xA0-0xA7*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,
-  /*0xA8-0xAF*/ 0x01, 0x00, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x01, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x00,
-  /*0xE0-0xE7*/ 0x00, 0x00, 0x10, 0x01, 0x10, 0x01, 0x00, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x01, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_06[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x00,
-  /*0x20-0x27*/ 0x00, 0x10, 0x11, 0x01, 0x10, 0x01, 0x00, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x01, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x00,
-  /*0x60-0x67*/ 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x01, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x00,
-  /*0xA0-0xA7*/ 0x00, 0x00, 0x11, 0x01, 0x10, 0x01, 0x00, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x00, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00,
-  /*0xE0-0xE7*/ 0x00, 0x10, 0x11, 0x00, 0x10, 0x00, 0x00, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x01, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_07[256] =
-{
-  /*0x00-0x07*/ 0x01, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00,
-  /*0x20-0x27*/ 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x01, 0x10, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00,
-  /*0x60-0x67*/ 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x01, 0x10, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00,
-  /*0xA0-0xA7*/ 0x00, 0x00, 0x11, 0x00, 0x10, 0x00, 0x00, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x01, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x11, 0x01,
-  /*0xE8-0xEF*/ 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_08[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x01, 0x11, 0x00, 0x00, 0x00, 0x10, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x01, 0x00, 0x00, 0x00, 0x10,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x01, 0x11, 0x00, 0x00, 0x00, 0x01, 0x10, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x00, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x01, 0x01, 0x01, 0x11, 0x11, 0x00,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xC0-0xC7*/ 0x00, 0x00, 0x10, 0x00, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
-  /*0xD0-0xD7*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xD8-0xDF*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x10, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_09[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00,
-  /*0x18-0x1F*/ 0x00, 0x10, 0x11, 0x00, 0x00, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x00, 0x00, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x88-0x8F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x90-0x97*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x98-0x9F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA0-0xA7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA8-0xAF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x11, 0x11, 0x21,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_10[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_11[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x00, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x00, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xE0-0xE7*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xE8-0xEF*/ 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_12[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x01, 0x00, 0x10,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x01, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_13[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x01, 0x00, 0x00,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x10,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x00, 0x00, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x70-0x77*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_14[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x21, 0x12, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_15[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x48-0x4F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x21, 0x22, 0x22,
-  /*0x50-0x57*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x58-0x5F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x60-0x67*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x68-0x6F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x70-0x77*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x78-0x7F*/ 0x22, 0x22, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x88-0x8F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x90-0x97*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x98-0x9F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA0-0xA7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA8-0xAF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB0-0xB7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB8-0xBF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC0-0xC7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC8-0xCF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD0-0xD7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD8-0xDF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xE0-0xE7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xE8-0xEF*/ 0x22, 0x22, 0x22, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x11, 0x11
-};
-
-static const unsigned char Table_16[256] =
-{
-  /*0x00-0x07*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x08-0x0F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x10-0x17*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00,
-  /*0x18-0x1F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x12,
-  /*0x20-0x27*/ 0x21, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x28-0x2F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x30-0x37*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x38-0x3F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x40-0x47*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x48-0x4F*/ 0x22, 0x22, 0x22, 0x12, 0x01, 0x20, 0x22, 0x22,
-  /*0x50-0x57*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x58-0x5F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x60-0x67*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x68-0x6F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x70-0x77*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x78-0x7F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x80-0x87*/ 0x11, 0x11, 0x21, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x88-0x8F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x90-0x97*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x12, 0x11,
-  /*0x98-0x9F*/ 0x21, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA0-0xA7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA8-0xAF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB0-0xB7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB8-0xBF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC0-0xC7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x12,
-  /*0xC8-0xCF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD0-0xD7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD8-0xDF*/ 0x22, 0x22, 0x22, 0x22, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22
-};
-
-static const unsigned char Table_17[256] =
-{
-  /*0x00-0x07*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x08-0x0F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x12, 0x11,
-  /*0x10-0x17*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x18-0x1F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x20-0x27*/ 0x22, 0x22, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x21, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x30-0x37*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x38-0x3F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x11, 0x21,
-  /*0x40-0x47*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x48-0x4F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x50-0x57*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x58-0x5F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x60-0x67*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x70-0x77*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x78-0x7F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x12,
-  /*0x80-0x87*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x88-0x8F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x90-0x97*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x98-0x9F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA0-0xA7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA8-0xAF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB0-0xB7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB8-0xBF*/ 0x22, 0x22, 0x22, 0x12, 0x11, 0x21, 0x22, 0x22,
-  /*0xC0-0xC7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC8-0xCF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD0-0xD7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD8-0xDF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xE0-0xE7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xE8-0xEF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x11,
-  /*0xF0-0xF7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xF8-0xFF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x12
-};
-
-static const unsigned char Table_18[256] =
-{
-  /*0x00-0x07*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x08-0x0F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x10-0x17*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x18-0x1F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x20-0x27*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x28-0x2F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x30-0x37*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x38-0x3F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x40-0x47*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x48-0x4F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x50-0x57*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x58-0x5F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x60-0x67*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x68-0x6F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x70-0x77*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x78-0x7F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x80-0x87*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x88-0x8F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x90-0x97*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x98-0x9F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA0-0xA7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA8-0xAF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB0-0xB7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB8-0xBF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC0-0xC7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC8-0xCF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD0-0xD7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD8-0xDF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xE0-0xE7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xE8-0xEF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xF0-0xF7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xF8-0xFF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22
-};
-
-static const unsigned char Table_19[256] =
-{
-  /*0x00-0x07*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x08-0x0F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x10-0x17*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x18-0x1F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x20-0x27*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x28-0x2F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x30-0x37*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x38-0x3F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x40-0x47*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x48-0x4F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x50-0x57*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x58-0x5F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x60-0x67*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x68-0x6F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x70-0x77*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x78-0x7F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x80-0x87*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x88-0x8F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x90-0x97*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x98-0x9F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA0-0xA7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA8-0xAF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB0-0xB7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB8-0xBF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC0-0xC7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC8-0xCF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD0-0xD7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD8-0xDF*/ 0x22, 0x22, 0x22, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_20[256] =
-{
-  /*0x00-0x07*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x08-0x0F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x10-0x17*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x18-0x1F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x20-0x27*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x28-0x2F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x30-0x37*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x38-0x3F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x40-0x47*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x48-0x4F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x50-0x57*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x58-0x5F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x60-0x67*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x68-0x6F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x70-0x77*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x78-0x7F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x80-0x87*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x88-0x8F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x90-0x97*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x98-0x9F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA0-0xA7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA8-0xAF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB0-0xB7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB8-0xBF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC0-0xC7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC8-0xCF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD0-0xD7*/ 0x22, 0x22, 0x22, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_21[256] =
-{
-  /*0x00-0x07*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x08-0x0F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x10-0x17*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x18-0x1F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x20-0x27*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x28-0x2F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x30-0x37*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x38-0x3F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x40-0x47*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x12, 0x11,
-  /*0x48-0x4F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x50-0x57*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x58-0x5F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x60-0x67*/ 0x22, 0x22, 0x22, 0x12, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_22[256] =
-{
-  /*0x00-0x07*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x08-0x0F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x10-0x17*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x18-0x1F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x20-0x27*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x28-0x2F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x30-0x37*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x38-0x3F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x40-0x47*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x48-0x4F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x50-0x57*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x58-0x5F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x60-0x67*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x68-0x6F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x70-0x77*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x78-0x7F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x80-0x87*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x88-0x8F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x90-0x97*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x98-0x9F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA0-0xA7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA8-0xAF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB0-0xB7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB8-0xBF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC0-0xC7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC8-0xCF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD0-0xD7*/ 0x22, 0x22, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_23[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x88-0x8F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x90-0x97*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x98-0x9F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA0-0xA7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA8-0xAF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB0-0xB7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB8-0xBF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC0-0xC7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xC8-0xCF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD0-0xD7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xD8-0xDF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xE0-0xE7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xE8-0xEF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xF0-0xF7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xF8-0xFF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22
-};
-
-static const unsigned char Table_24[256] =
-{
-  /*0x00-0x07*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x08-0x0F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x10-0x17*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x11,
-  /*0x18-0x1F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x20-0x27*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x28-0x2F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x30-0x37*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x12, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_25[256] =
-{
-  /*0x00-0x07*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x20-0x27*/ 0x22, 0x22, 0x22, 0x12, 0x21, 0x22, 0x22, 0x22,
-  /*0x28-0x2F*/ 0x22, 0x12, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x30-0x37*/ 0x22, 0x22, 0x22, 0x12, 0x22, 0x22, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x01,
-  /*0x80-0x87*/ 0x21, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x88-0x8F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x90-0x97*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x98-0x9F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA0-0xA7*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xA8-0xAF*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0xB0-0xB7*/ 0x12, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x22, 0x22, 0x22, 0x12, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x01, 0x00, 0x11, 0x11
-};
-
-static const unsigned char Table_26[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x01, 0x00, 0x00, 0x11, 0x01, 0x00,
-  /*0xB8-0xBF*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0xC0-0xC7*/ 0x00, 0x10, 0x01, 0x00, 0x00, 0x00, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_27[256] =
-{
-  /*0x00-0x07*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x08-0x0F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x10-0x17*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x18-0x1F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x20-0x27*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x28-0x2F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x30-0x37*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x38-0x3F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x40-0x47*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x48-0x4F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x50-0x57*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x58-0x5F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x60-0x67*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x68-0x6F*/ 0x22, 0x22, 0x22, 0x12, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_28[256] =
-{
-  /*0x00-0x07*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
-  /*0x08-0x0F*/ 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_29[256] =
-{
-  /*0x00-0x07*/ 0x01, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x18-0x1F*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x20-0x27*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x28-0x2F*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x30-0x37*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x38-0x3F*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
-};
-
-static const unsigned char Table_30[256] =
-{
-  /*0x00-0x07*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x08-0x0F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x10-0x17*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x18-0x1F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x20-0x27*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x28-0x2F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x30-0x37*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x38-0x3F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x40-0x47*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x48-0x4F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x50-0x57*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x58-0x5F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x60-0x67*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x68-0x6F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x70-0x77*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x78-0x7F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x80-0x87*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x88-0x8F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x90-0x97*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0x98-0x9F*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA0-0xA7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xA8-0xAF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB0-0xB7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xB8-0xBF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC0-0xC7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xC8-0xCF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD0-0xD7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xD8-0xDF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE0-0xE7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xE8-0xEF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF0-0xF7*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
-  /*0xF8-0xFF*/ 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00
-};
-
-const unsigned char *_pSLwc_Width_Table[2176] =
-{
-  Table_01,  Table_02,  Table_03,  Table_04,  Table_05,  Table_06,
-  Table_07,  Table_08,  Table_09,  Table_10,  Table_10,  Table_11,
-  Table_12,  Table_10,  Table_10,  Table_10,  Table_13,  Table_14,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_15,
-  Table_16,  Table_17,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_19,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_20,  Table_18,  Table_18,  Table_21,  Table_10,
-  Table_10,  Table_10,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_22,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_23,  Table_24,
-  Table_10,  Table_25,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_26,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,  Table_18,
-  Table_18,  Table_18,  Table_18,  Table_27,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_18,  Table_28,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_29,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,  Table_10,
-  Table_10,  Table_10,  Table_10,  Table_30
-};
-#endif /* DEFINE_PSLWC_WIDTH_TABLE */
diff --git a/slang/slcommon.c b/slang/slcommon.c
deleted file mode 100644
index 2ccd613..0000000
--- a/slang/slcommon.c
+++ /dev/null
@@ -1,322 +0,0 @@
-/* This file contains library-wide symbols that are always needed when one
- * links to the library.
- */
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-#define _GNU_SOURCE
-#include "slinclud.h"
-
-#include "slang.h"
-#include "_slang.h"
-
-#ifdef HAVE_LOCALE_H
-# include <locale.h>
-#endif
-
-#ifdef HAVE_LANGINFO_H
-# include <langinfo.h>
-#endif
-
-#define DEBUG_MALLOC 0
-
-#if DEBUG_MALLOC
-# define SLREALLOC_FUN	SLdebug_realloc
-# define SLMALLOC_FUN	SLdebug_malloc
-# define SLFREE_FUN	SLdebug_free
-#else
-# define SLREALLOC_FUN	SLREALLOC
-# define SLMALLOC_FUN	SLMALLOC
-# define SLFREE_FUN	SLFREE
-#endif
-
-
-int SLang_Version = SLANG_VERSION;
-char *SLang_Version_String = SLANG_VERSION_STRING;
-
-int _pSLinterp_UTF8_Mode = 0;
-int _pSLtt_UTF8_Mode = 0;
-int _pSLutf8_mode = 0;
-
-#ifndef HAVE_LOCALE_H
-# define setlocale(x,y) (NULL)
-# define LC_ALL 0
-#endif
-
-int SLutf8_is_utf8_mode (void)
-{
-   return _pSLutf8_mode;
-}
-
-int SLinterp_utf8_enable (int mode)
-{
-   if (mode == -1)
-     mode = _pSLutf8_mode;
-
-   return _pSLinterp_UTF8_Mode = mode;
-}
-
-int SLinterp_is_utf8_mode (void)
-{
-   return _pSLinterp_UTF8_Mode;
-}
-
-static int utf8_enable (int mode)
-{
-   char *locale;
-
-   if (mode != -1)
-     return (mode != 0);
-
-   (void) setlocale (LC_ALL, "");
-
-#ifdef HAVE_NL_LANGINFO_CODESET
-   locale = nl_langinfo (CODESET);
-   if ((locale != NULL) && (*locale))
-     {
-	if ((0 == strcmp (locale, "UTF-8"))
-	    || (0 == strcmp (locale, "utf-8"))
-	    || (0 == strcmp (locale, "utf8"))
-	    || (0 == strcmp (locale, "UTF8")))
-	  return 1;
-	
-	return 0;
-     }
-#endif
-
-   locale = setlocale (LC_ALL, "");
-
-   if (((locale == NULL) || (*locale == 0))
-       && ((NULL == (locale = getenv ("LC_ALL"))) || (*locale == 0))
-       && ((NULL == (locale = getenv ("LC_CTYPE"))) || (*locale == 0))
-       && ((NULL == (locale = getenv ("LANG"))) || (*locale == 0)))
-     return 0;
-
-   /* setlocale man page says the return value is something like:
-    *   language[_territory][.codeset][@modifier][+special][,...
-    * Here, we want the codeset, if present.
-    */
-   
-   while (*locale && (*locale != '.') && (*locale != '@')
-	  && (*locale != '+') && (*locale != ','))
-     locale++;
-   
-   if (*locale == '.')
-     {
-	locale++;
-	if (0 == strncmp (locale, "UTF-8", 5))
-	  locale += 5;
-	else if (0 == strncmp (locale, "utf8", 4))
-	  locale += 4;
-	else
-	  return 0;
-	
-	if ((*locale == 0) || (*locale == '@') 
-	    || (*locale == '+') || (*locale == ','))
-	  return 1;
-     }
-   
-   return 0;
-}
-
-  
-/* Returns the value of _pSLutf8_mode */
-int SLutf8_enable (int mode)
-{
-   mode = utf8_enable (mode);
-   _pSLutf8_mode = mode;
-   _pSLtt_UTF8_Mode = mode;
-   _pSLinterp_UTF8_Mode = mode;
-   return mode;
-}
-
-#ifndef MIDNIGHT_COMMANDER_CODE
-
-char *SLmalloc (unsigned int len)
-{
-   char *p;
-
-   p = (char *) SLMALLOC_FUN (len);
-   if (p == NULL)
-     SLang_set_error (SL_MALLOC_ERROR);
-
-   return p;
-}
-
-void SLfree (char *p)
-{
-   if (p != NULL) SLFREE_FUN (p);
-}
-
-char *SLrealloc (char *p, unsigned int len)
-{
-   if (len == 0)
-     {
-	SLfree (p);
-	return NULL;
-     }
-
-   if (p == NULL) p = SLmalloc (len);
-   else
-     {
-	p = (char *)SLREALLOC_FUN (p, len);
-	if (p == NULL)
-	  SLang_set_error (SL_MALLOC_ERROR);
-     }
-   return p;
-}
-
-#endif                                /* !MIDNIGHT_COMMANDER_CODE */
-
-char *SLcalloc (unsigned int nelems, unsigned int len)
-{
-   char *p;
-
-   len = nelems * len;
-   p = SLmalloc (len);
-   if (p != NULL) memset (p, 0, len);
-   return p;
-}
-
-#if 0 /* was: !defined(HAVE_ISSETUGID) && defined(__GLIBC__) && (__GLIBC__ >= 2) */
-extern int __libc_enable_secure;
-# define HAVE___LIBC_ENABLE_SECURE 1
-#endif
-
-int _pSLsecure_issetugid (void)
-{
-#ifdef HAVE_ISSETUGID
-   return (1 == issetugid ());
-#else
-# if defined HAVE___LIBC_ENABLE_SECURE && 0
-   return __libc_enable_secure;
-# else
-#  if defined(HAVE_GETUID) && defined(HAVE_GETEUID) && defined(HAVE_GETGID) && defined(HAVE_GETEUID)
-   static int enable_secure;
-   if (enable_secure == 0)
-    {
-       if ((getuid () != geteuid ()) 
-	   || (getgid () != getegid ()))
-	 enable_secure = 1;
-       else
-	 enable_secure = -1;
-    }
-   return (enable_secure == 1);
-#  else
-   return 0;
-#  endif
-# endif
-#endif
-}
-
-/* Like getenv, except if running as setuid or setgid, returns NULL */
-char *_pSLsecure_getenv (char *s)
-{
-   if (_pSLsecure_issetugid ())
-     return NULL;
-   return getenv (s);
-}
-
-
-typedef struct Interrupt_Hook_Type
-{
-   int (*func)(VOID_STAR);
-   VOID_STAR client_data;
-   struct Interrupt_Hook_Type *next;
-}
-Interrupt_Hook_Type;
-
-static Interrupt_Hook_Type *Interrupt_Hooks = NULL;
-
-static Interrupt_Hook_Type *
-  find_interrupt_hook (int (*func)(VOID_STAR), VOID_STAR cd,
-		       Interrupt_Hook_Type **prevp)
-{
-   Interrupt_Hook_Type *h = Interrupt_Hooks;
-   Interrupt_Hook_Type *prev = NULL;
-   while (h != NULL)
-     {
-	if ((h->func == func) && (h->client_data == cd))
-	  {
-	     if (prevp != NULL)
-	       *prevp = prev;
-	     return h;
-	  }
-	h = h->next;
-     }
-   return NULL;
-}
-   
-int SLang_add_interrupt_hook (int (*func)(VOID_STAR), VOID_STAR cd)
-{
-   Interrupt_Hook_Type *h;
-
-   if (NULL != find_interrupt_hook (func, cd, NULL))
-     return 0;
-   
-   if (NULL == (h = (Interrupt_Hook_Type *)SLmalloc (sizeof (Interrupt_Hook_Type))))
-     return -1;
-   
-   h->func = func;
-   h->client_data = cd;
-   h->next = Interrupt_Hooks;
-   Interrupt_Hooks = h;
-   return 0;
-}
-
-void SLang_remove_interrupt_hook (int (*func)(VOID_STAR), VOID_STAR cd)
-{
-   Interrupt_Hook_Type *h, *hprev;
-
-   if (NULL == (h = find_interrupt_hook (func, cd, &hprev)))
-     return;
-   
-   if (hprev == NULL)
-     Interrupt_Hooks = h->next;
-   else
-     hprev->next = h->next;
-   
-   SLfree ((char *) h);
-}
-
-int SLang_handle_interrupt (void)
-{
-   Interrupt_Hook_Type *h;
-   int status = 0;
-
-   h = Interrupt_Hooks;
-   while (h != NULL)
-     {
-	if (-1 == (*h->func)(h->client_data))
-	  status = -1;
-
-	h = h->next;
-     }
-   return status;
-}
-
-#if defined(__WIN32__) && defined(SLANG_DLL)
-# include <windows.h>
-
-BOOL WINAPI DllMain(HANDLE hInstance,DWORD dwReason,LPVOID lpParam)
-{
-   return 1;
-}
-#endif
diff --git a/slang/sldisply.c b/slang/sldisply.c
deleted file mode 100644
index 909ef87..0000000
--- a/slang/sldisply.c
+++ /dev/null
@@ -1,2897 +0,0 @@
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-#include "slinclud.h"
-
-#include <time.h>
-#include <ctype.h>
-
-#if !defined(VMS) || (__VMS_VER >= 70000000)
-# include <sys/time.h>
-# ifdef __QNX__
-#  include <sys/select.h>
-# endif
-# include <sys/types.h>
-#endif
-
-#ifdef __BEOS__
-/* Prototype for select */
-# include <net/socket.h>
-#endif
-
-#ifdef HAVE_TERMIOS_H
-# include <termios.h>
-#endif
-
-#ifdef VMS
-# include <unixlib.h>
-# include <unixio.h>
-# include <dvidef.h>
-# include <descrip.h>
-# include <lib$routines.h>
-# include <starlet.h>
-#else
-# if !defined(sun)
-#  include <sys/ioctl.h>
-# endif
-#endif
-
-#ifdef SYSV
-# include <sys/termio.h>
-# include <sys/stream.h>
-# include <sys/ptem.h>
-# include <sys/tty.h>
-#endif
-
-#if defined (_AIX) && !defined (FD_SET)
-# include <sys/select.h>	/* for FD_ISSET, FD_SET, FD_ZERO */
-#endif
-
-#include <errno.h>
-
-#if defined(__DECC) && defined(VMS)
-/* These get prototypes for write an sleep */
-# include <unixio.h>
-#endif
-#include <signal.h>
-
-#include "slang.h"
-#include "_slang.h"
-
-/* Colors:  These definitions are used for the display.  However, the
- * application only uses object handles which get mapped to this
- * internal representation.  The mapping is performed by the Color_Map
- * structure below. */
-
-#define CHAR_MASK	0x000000FF
-#define FG_MASK		0x0000FF00
-#define BG_MASK		0x00FF0000
-#define ATTR_MASK	0x1F000000
-#define BGALL_MASK	0x0FFF0000
-
-/* The 0x10000000 bit represents the alternate character set.  BGALL_MASK does
- * not include this attribute.
- */
-
-#define GET_FG(fgbg) (((fgbg) & FG_MASK) >> 8)
-#define GET_BG(fgbg) (((fgbg) & BG_MASK) >> 16)
-#define MAKE_COLOR(fg, bg) (((fg) | ((bg) << 8)) << 8)
-
-int SLtt_Screen_Cols = 80;
-int SLtt_Screen_Rows = 24;
-int SLtt_Term_Cannot_Insert;
-int SLtt_Term_Cannot_Scroll;
-int SLtt_Use_Ansi_Colors;
-int SLtt_Blink_Mode = 0;
-int SLtt_Use_Blink_For_ACS = 0;
-int SLtt_Newline_Ok = 0;
-int SLtt_Has_Alt_Charset = 0;
-int SLtt_Force_Keypad_Init = 0;
-
-/* static int UTF8_Mode = -1; */
-
-void (*_pSLtt_color_changed_hook)(void);
-
-#if SLTT_HAS_NON_BCE_SUPPORT
-static int Bce_Color_Offset = 0;
-#endif
-static int Can_Background_Color_Erase = 1;
-
-/* -1 means unknown */
-int SLtt_Has_Status_Line = -1;	       /* hs */
-int SLang_TT_Write_FD = -1;
-
-static int Automatic_Margins;
-/* static int No_Move_In_Standout; */
-static int Worthless_Highlight;
-#define HP_GLITCH_CODE
-#ifdef HP_GLITCH_CODE
-/* This glitch is exclusive to HP term.  Basically it means that to clear
- * attributes, one has to erase to the end of the line.
- */
-static int Has_HP_Glitch;
-#endif
-
-static char *Reset_Color_String;
-static int Is_Color_Terminal = 0;
-
-static int Linux_Console;
-static int QANSI_Console;
-static int Mouse_Mode = -1;
-
-/* The following comment is nolonger valid, but is here in case there are
- * some apps that use SLtt_Use_Blink_For_ACS and still need porting to v2.
- * -------
- * It is crucial that JMAX_COLORS must be less than 128 since the high bit
- * is used to indicate a character from the ACS (alt char set).  The exception
- * to this rule is if SLtt_Use_Blink_For_ACS is true.  This means that of
- * the highbit is set, we interpret that as a blink character.  This is
- * exploited by DOSemu.
- */
-#define JMAX_COLORS 512
-#define JNORMAL_COLOR 0
-
-typedef struct
-{
-   SLtt_Char_Type fgbg;
-   SLtt_Char_Type mono;
-}
-Brush_Info_Type;
-
-static Brush_Info_Type Brush_Table[JMAX_COLORS];
-
-/* 0 if least significant bit is blue, not red */
-/* static int Is_Fg_BGR = 0; */
-static int Is_Bg_BGR = 0;
-#define COLOR_ARG(color, is_bgr) ((is_bgr) ? RGB_to_BGR[(color)&0x7] : (color))
-static SLCONST int RGB_to_BGR[] =
-{
-     0, 4, 2, 6, 1, 5, 3, 7
-};
-
-
-static char *Color_Fg_Str = "\033[3%dm";
-static char *Color_Bg_Str = "\033[4%dm";
-static char *Default_Color_Fg_Str = "\033[39m";
-static char *Default_Color_Bg_Str = "\033[49m";
-
-static int Max_Terminfo_Colors = 8;	       /* termcap Co */
-
-char *SLtt_Graphics_Char_Pairs;	       /* ac termcap string -- def is vt100 */
-
-/* 1 if terminal lacks the ability to go into insert mode or into delete
-   mode. Currently controlled by S-Lang but later perhaps termcap. */
-
-static char *UnderLine_Vid_Str;
-static char *Blink_Vid_Str;
-static char *Bold_Vid_Str;
-static char *Ins_Mode_Str; /* = "\033[4h"; */   /* ins mode (im) */
-static char *Eins_Mode_Str; /* = "\033[4l"; */  /* end ins mode (ei) */
-static char *Scroll_R_Str; /* = "\033[%d;%dr"; */ /* scroll region */
-static char *Cls_Str; /* = "\033[2J\033[H"; */  /* cl termcap STR  for ansi terminals */
-static char *Rev_Vid_Str; /* = "\033[7m"; */    /* mr,so termcap string */
-static char *Norm_Vid_Str; /* = "\033[m"; */   /* me,se termcap string */
-static char *Del_Eol_Str; /* = "\033[K"; */	       /* ce */
-static char *Del_Bol_Str; /* = "\033[1K"; */	       /* cb */
-static char *Del_Char_Str; /* = "\033[P"; */   /* dc */
-static char *Del_N_Lines_Str; /* = "\033[%dM"; */  /* DL */
-static char *Add_N_Lines_Str; /* = "\033[%dL"; */  /* AL */
-static char *Rev_Scroll_Str;
-static char *Curs_Up_Str;
-static char *Curs_F_Str;    /* RI termcap string */
-static char *Cursor_Visible_Str;    /* ve termcap string */
-static char *Cursor_Invisible_Str;    /* vi termcap string */
-#if 0
-static char *Start_Mouse_Rpt_Str;  /* Start mouse reporting mode */
-static char *End_Mouse_Rpt_Str;  /* End mouse reporting mode */
-#endif
-static char *Start_Alt_Chars_Str;  /* as */
-static char *End_Alt_Chars_Str;   /* ae */
-static char *Enable_Alt_Char_Set;  /* eA */
-
-static char *Term_Init_Str;
-static char *Keypad_Init_Str;
-static char *Term_Reset_Str;
-static char *Keypad_Reset_Str;
-
-/* status line functions */
-static char *Disable_Status_line_Str;  /* ds */
-static char *Return_From_Status_Line_Str;   /* fs */
-static char *Goto_Status_Line_Str;     /* ts */
-static int Num_Status_Line_Columns;    /* ws */
-/* static int Status_Line_Esc_Ok;	 */       /* es */
-
-/* static int Len_Curs_F_Str = 5; */
-
-/* cm string has %i%d since termcap numbers columns from 0 */
-/* char *CURS_POS_STR = "\033[%d;%df";  ansi-- hor and vert pos */
-static char *Curs_Pos_Str; /* = "\033[%i%d;%dH";*/   /* cm termcap string */
-
-/* scrolling region */
-static int Scroll_r1 = 0, Scroll_r2 = 23;
-static int Cursor_r, Cursor_c;	       /* 0 based */
-
-/* current attributes --- initialized to impossible value */
-static SLtt_Char_Type Current_Fgbg = 0xFFFFFFFFU;
-
-static int Cursor_Set;		       /* 1 if cursor position known, 0
-					* if not.  -1 if only row is known
-					*/
-
-#define MAX_OUTPUT_BUFFER_SIZE 4096
-
-static unsigned char Output_Buffer[MAX_OUTPUT_BUFFER_SIZE];
-static unsigned char *Output_Bufferp = Output_Buffer;
-
-unsigned long SLtt_Num_Chars_Output;
-
-int _pSLusleep (unsigned long usecs)
-{
-#if !defined(VMS) || (__VMS_VER >= 70000000)
-   struct timeval tv;
-   tv.tv_sec = usecs / 1000000;
-   tv.tv_usec = usecs % 1000000;
-   return select(0, NULL, NULL, NULL, &tv);
-#else
-   return 0;
-#endif
-}
-
-int SLtt_flush_output (void)
-{
-   int nwrite = 0;
-   unsigned int total;
-   int n = (int) (Output_Bufferp - Output_Buffer);
-
-   SLtt_Num_Chars_Output += n;
-
-   total = 0;
-   while (n > 0)
-     {
-	nwrite = write (SLang_TT_Write_FD, (char *) Output_Buffer + total, n);
-	if (nwrite == -1)
-	  {
-	     nwrite = 0;
-#ifdef EAGAIN
-	     if (errno == EAGAIN)
-	       {
-		  _pSLusleep (100000);   /* 1/10 sec */
-		  continue;
-	       }
-#endif
-#ifdef EWOULDBLOCK
-	     if (errno == EWOULDBLOCK)
-	       {
-		  _pSLusleep (100000);
-		  continue;
-	       }
-#endif
-#ifdef EINTR
-	     if (errno == EINTR) continue;
-#endif
-	     break;
-	  }
-	n -= nwrite;
-	total += nwrite;
-     }
-   Output_Bufferp = Output_Buffer;
-   return n;
-}
-
-int SLtt_Baud_Rate;
-static void tt_write(char *str, unsigned int n)
-{
-   static unsigned long last_time;
-   static int total;
-   unsigned long now;
-   unsigned int ndiff;
-
-   if ((str == NULL) || (n == 0)) return;
-   total += n;
-
-   while (1)
-     {
-	ndiff = MAX_OUTPUT_BUFFER_SIZE - (int) (Output_Bufferp - Output_Buffer);
-	if (ndiff < n)
-	  {
-	     SLMEMCPY ((char *) Output_Bufferp, str, ndiff);
-	     Output_Bufferp += ndiff;
-	     SLtt_flush_output ();
-	     n -= ndiff;
-	     str += ndiff;
-	  }
-	else
-	  {
-	     SLMEMCPY ((char *) Output_Bufferp, str, n);
-	     Output_Bufferp += n;
-	     break;
-	  }
-     }
-
-   if (((SLtt_Baud_Rate > 150) && (SLtt_Baud_Rate <= 9600))
-       && (10 * total > SLtt_Baud_Rate))
-     {
-	total = 0;
-	if ((now = (unsigned long) time(NULL)) - last_time <= 1)
-	  {
-	     SLtt_flush_output ();
-	     sleep((unsigned) 1);
-	  }
-	last_time = now;
-     }
-}
-
-static void tt_write_string (char *str)
-{
-   if (str != NULL) tt_write(str, strlen(str));
-}
-
-void SLtt_write_string (char *str)
-{
-   tt_write_string (str);
-   Cursor_Set = 0;
-}
-
-void SLtt_putchar (char ch)
-{
-   SLtt_normal_video ();
-   if (Cursor_Set == 1)
-     {
-	if (ch >= ' ') Cursor_c++;
-	else if (ch == '\b') Cursor_c--;
-	else if (ch == '\r') Cursor_c = 0;
-	else Cursor_Set = 0;
-
-	if ((Cursor_c + 1 == SLtt_Screen_Cols)
-	    && Automatic_Margins) Cursor_Set = 0;
-     }
-
-   if (Output_Bufferp < Output_Buffer + MAX_OUTPUT_BUFFER_SIZE)
-     {
-	*Output_Bufferp++ = (unsigned char) ch;
-     }
-   else tt_write (&ch, 1);
-}
-
-static unsigned int tt_sprintf(char *buf, unsigned int buflen, char *fmt, int x, int y)
-{
-   char *fmt_max;
-   unsigned char *b, *bmax, ch;
-   int offset;
-   int z, z1, parse_level;
-   int zero_pad;
-   int field_width;
-   int variables [26];
-   int stack [64];
-   unsigned int stack_len;
-   int parms [10];
-#define STACK_POP (stack_len ? stack[--stack_len] : 0)
-
-   if (fmt == NULL)
-     {
-	*buf = 0;
-	return 0;
-     }
-
-   stack [0] = y;	       /* pushed for termcap */
-   stack [1] = x;
-   stack_len = 2;
-
-   parms [1] = x;	       /* p1 */
-   parms [2] = y;	       /* p2 */
-
-   offset = 0;
-   zero_pad = 0;
-   field_width = 0;
-
-   b = (unsigned char *) buf;
-   bmax = b + buflen;
-
-   fmt_max = fmt + strlen (fmt);
-
-   while ((fmt < fmt_max) && (b < bmax))
-     {
-	ch = *fmt++;
-
-	if (ch != '%')
-	  {
-	     *b++ = ch;
-	     continue;
-	  }
-
-	if (fmt == fmt_max) break;
-	ch = *fmt++;
-
-	switch (ch)
-	  {
-	   default:
-	     *b++ = ch;
-	     break;
-
-	   case 'p':
-
-	     if (fmt == fmt_max) break;
-	     ch = *fmt++;
-	     if ((ch >= '0') && (ch <= '9'))
-	       stack [stack_len++] = parms [ch - '0'];
-	     break;
-
-	   case '\'':   /* 'x' */
-	     if (fmt == fmt_max) break;
-	     stack [stack_len++] = *fmt++;
-	     if (fmt < fmt_max) fmt++;     /* skip ' */
-	     break;
-
-	   case '{':	       /* literal constant, e.g. {30} */
-	     z = 0;
-	     while ((fmt < fmt_max) && ((ch = *fmt) <= '9') && (ch >= '0'))
-	       {
-		  z = z * 10 + (ch - '0');
-		  fmt++;
-	       }
-	     stack [stack_len++] = z;
-	     if ((ch == '}') && (fmt < fmt_max)) fmt++;
-	     break;
-
-	   case '0':
-	     if (fmt == fmt_max) break;
-	     ch = *fmt;
-	     if ((ch != '2') && (ch != '3'))
-	       break;
-	     zero_pad = 1;
-	     fmt++;
-	     /* drop */
-
-	   case '2':
-	   case '3':
-	     if (fmt == fmt_max) break;
-	     if (*fmt == 'x')
-	       {
-		  char x_fmt_buf [4];
-		  char *x_fmt_buf_ptr;
-
-		  x_fmt_buf_ptr = x_fmt_buf;
-		  if (zero_pad) *x_fmt_buf_ptr++ = '0';
-		  *x_fmt_buf_ptr++ = ch;
-		  *x_fmt_buf_ptr++ = 'X';
-		  *x_fmt_buf_ptr = 0;
-
-		  z = STACK_POP;
-		  z += offset;
-
-		  sprintf ((char *)b, x_fmt_buf, z);
-		  b += strlen ((char *)b);
-		  zero_pad = 0;
-		  break;
-	       }
-
-	     field_width = (ch - '0');
-		  /* drop */
-
-	   case 'd':
-	     z = STACK_POP;
-	     z += offset;
-	     if (z >= 100)
-	       {
-		  *b++ = z / 100 + '0';
-		  z = z % 100;
-		  zero_pad = 1;
-		  field_width = 2;
-	       }
-	     else if (zero_pad && (field_width == 3))
-	       *b++ = '0';
-
-	     if (b == bmax) break;
-	     if (z >= 10)
-	       {
-		  *b++ = z / 10 + '0';
-		  z = z % 10;
-	       }
-	     else if (zero_pad && (field_width >= 2))
-	       *b++ = '0';
-
-	     if (b == bmax) break;
-	     *b++ = z + '0';
-	     field_width = zero_pad = 0;
-	     break;
-
-	   case 'x':
-	     z = STACK_POP;
-	     z += offset;
-	     if (b + 16 >= bmax)
-	       break;
-	     sprintf ((char *) b, "%X", z);
-	     b += strlen ((char *)b);
-	     break;
-
-	   case 'i':
-	     offset = 1;
-	     break;
-
-	   case '+':
-	     /* Handling this depends upon whether or not we are parsing
-	      * terminfo.  Terminfo requires the stack so use it as an
-	      * indicator.
-	      */
-	     if (stack_len > 2)
-	       {
-		  z = STACK_POP;
-		  stack [stack_len - 1] += z;
-	       }
-	     else if (fmt < fmt_max)
-	       {
-		  ch = *fmt++;
-		  if ((unsigned char) ch == 128) ch = 0;
-		  ch = ch + (unsigned char) STACK_POP;
-		  if (ch == '\n') ch++;
-		  *b++ = ch;
-	       }
-	     break;
-
-	     /* Binary operators */
-	   case '-':
-	   case '*':
-	   case '/':
-	   case 'm':
-	   case '&':
-	   case '|':
-	   case '^':
-	   case '=':
-	   case '>':
-	   case '<':
-	   case 'A':
-	   case 'O':
-	     z1 = STACK_POP;
-	     z = STACK_POP;
-	     switch (ch)
-	       {
-		case '-': z = (z - z1); break;
-		case '*': z = (z * z1); break;
-		case '/': z = (z / z1); break;
-		case 'm': z = (z % z1); break;
-		case '&': z = (z & z1); break;
-		case '|': z = (z | z1); break;
-		case '^': z = (z ^ z1); break;
-		case '=': z = (z == z1); break;
-		case '>': z = (z > z1); break;
-		case '<': z = (z < z1); break;
-		case 'A': z = (z && z1); break;
-		case 'O': z = (z || z1); break;
-	       }
-	     stack [stack_len++] = z;
-	     break;
-
-	     /* unary */
-	   case '!':
-	     z = STACK_POP;
-	     stack [stack_len++] = !z;
-	     break;
-
-	   case '~':
-	     z = STACK_POP;
-	     stack [stack_len++] = ~z;
-	     break;
-
-	   case 'r':		       /* termcap -- swap parameters */
-	     z = stack [0];
-	     stack [0] = stack [1];
-	     stack [1] = z;
-	     break;
-
-	   case '.':		       /* termcap */
-	   case 'c':
-	     ch = (unsigned char) STACK_POP;
-	     if (ch == '\n') ch++;
-	     *b++ = ch;
-	     break;
-
-	   case 'g':
-	     if (fmt == fmt_max) break;
-	     ch = *fmt++;
-	     if ((ch >= 'a') && (ch <= 'z'))
-	       stack [stack_len++] = variables [ch - 'a'];
-	     break;
-
-	   case 'P':
-	     if (fmt == fmt_max) break;
-	     ch = *fmt++;
-	     if ((ch >= 'a') && (ch <= 'z'))
-	       variables [ch - 'a'] = STACK_POP;
-	     break;
-
-	     /* If then else parsing.  Actually, this is rather easy.  The
-	      * key is to notice that 'then' does all the work.  'if' simply
-	      * there to indicate the start of a test and endif indicates
-	      * the end of tests.  If 'else' is seen, then skip to
-	      * endif.
-	      */
-	   case '?':		       /* if */
-	   case ';':		       /* endif */
-	     break;
-
-	   case 't':		       /* then */
-	     z = STACK_POP;
-	     if (z != 0)
-	       break;		       /* good.  Continue parsing. */
-
-	     /* z == 0 and test has failed.  So, skip past this entire if
-	      * expression to the matching else or matching endif.
-	      */
-	     /* drop */
-	   case 'e':		       /* else */
-
-	     parse_level = 0;
-	     while (fmt < fmt_max)
-	       {
-		  unsigned char ch1;
-
-		  ch1 = *fmt++;
-		  if ((ch1 != '%') || (fmt == fmt_max))
-		    continue;
-
-		  ch1 = *fmt++;
-
-		  if (ch1 == '?') parse_level++;   /* new if */
-		  else if (ch1 == 'e')
-		    {
-		       if ((ch != 'e') && (parse_level == 0))
-			 break;
-		    }
-		  else if (ch1 == ';')
-		    {
-		       if (parse_level == 0)
-			 break;
-		       parse_level--;
-		    }
-	       }
-	     break;
-	  }
-     }
-   if (b >= bmax)
-     b = bmax - 1;
-   *b = 0;
-
-   return (unsigned int) (b - (unsigned char *) buf);
-}
-
-static void tt_printf(char *fmt, int x, int y)
-{
-   char buf[1024];
-   unsigned int n;
-   if (fmt == NULL) return;
-   n = tt_sprintf(buf, sizeof (buf), fmt, x, y);
-   tt_write(buf, n);
-}
-
-void SLtt_set_scroll_region (int r1, int r2)
-{
-   Scroll_r1 = r1;
-   Scroll_r2 = r2;
-   tt_printf (Scroll_R_Str, Scroll_r1, Scroll_r2);
-   Cursor_Set = 0;
-}
-
-void SLtt_reset_scroll_region (void)
-{
-   SLtt_set_scroll_region(0, SLtt_Screen_Rows - 1);
-}
-
-int SLtt_set_cursor_visibility (int show)
-{
-   if ((Cursor_Visible_Str == NULL) || (Cursor_Invisible_Str == NULL))
-     return -1;
-
-   tt_write_string (show ? Cursor_Visible_Str : Cursor_Invisible_Str);
-   return 0;
-}
-
-/* the goto_rc function moves to row relative to scrolling region */
-void SLtt_goto_rc(int r, int c)
-{
-   char *s = NULL;
-   int n;
-   char buf[6];
-
-   if ((c < 0) || (r < 0))
-     {
-	Cursor_Set = 0;
-	return;
-     }
-
-   /* if (No_Move_In_Standout && Current_Fgbg) SLtt_normal_video (); */
-   r += Scroll_r1;
-
-   if ((Cursor_Set > 0) || ((Cursor_Set < 0) && !Automatic_Margins))
-     {
-	n = r - Cursor_r;
-	if ((n == -1) && (Cursor_Set > 0) && (Cursor_c == c)
-	    && (Curs_Up_Str != NULL))
-	  {
-	     s = Curs_Up_Str;
-	  }
-	else if ((n >= 0) && (n <= 4))
-	  {
-	     if ((n == 0) && (Cursor_Set == 1)
-		 && ((c > 1) || (c == Cursor_c)))
-	       {
-		  if (Cursor_c == c) return;
-		  if (Cursor_c == c + 1)
-		    {
-                       /* cursor movement optimizations, like backspace
-			  doesn't work as needed on qansi-m consoles when 
-			  current table is not a G0, so we'll disable it. */
-            	       if (!QANSI_Console)
-                       {
-		         s = buf;
-		         *s++ = '\b'; *s = 0;
-		         s = buf;
-		       }
-		       else
-		       {
-                          /* do the generic cursor positioning,
-		             without an optimization */
-			 s = NULL;
-		       }
-		    }
-	       }
-	     else if ((c == 0) && (!QANSI_Console)) /* the same things
-	    			    for the qansi-m console limitation */
-	       {
-		  s = buf;
-		  if ((Cursor_Set != 1) || (Cursor_c != 0)) *s++ = '\r';
-		  while (n--) *s++ = '\n';
-#ifdef VMS
-		  /* Need to add this after \n to start a new record.  Sheesh. */
-		  *s++ = '\r';
-#endif
-		  *s = 0;
-		  s = buf;
-	       }
-	     /* Will fail on VMS */
-#ifndef VMS
-	     else if ((SLtt_Newline_Ok && (Cursor_Set == 1) &&
-		      (Cursor_c >= c) && (c + 3 > Cursor_c)) &&
-		      (!QANSI_Console))
-	       {
-		  s = buf;
-		  while (n--) *s++ = '\n';
-		  n = Cursor_c - c;
-		  while (n--) *s++ = '\b';
-		  *s = 0;
-		  s = buf;
-	       }
-#endif
-	  }
-     }
-   if (s != NULL) tt_write_string(s);
-   else tt_printf(Curs_Pos_Str, r, c);
-   Cursor_c = c; Cursor_r = r;
-   Cursor_Set = 1;
-}
-
-void SLtt_begin_insert (void)
-{
-   tt_write_string(Ins_Mode_Str);
-}
-
-void SLtt_end_insert (void)
-{
-   tt_write_string(Eins_Mode_Str);
-}
-
-void SLtt_delete_char (void)
-{
-   SLtt_normal_video ();
-   tt_write_string(Del_Char_Str);
-}
-
-void SLtt_erase_line (void)
-{
-   tt_write ("\r", 1);
-   Cursor_Set = 1; Cursor_c = 0;
-   SLtt_del_eol();
-   /* Put the cursor back at the beginning of the line */
-   tt_write ("\r", 1);
-   Cursor_Set = 1; Cursor_c = 0;
-}
-
-/* It appears that the Linux console, and most likely others do not
- * like scrolling regions that consist of one line.  So I have to
- * resort to this stupidity to make up for that stupidity.
- */
-static void delete_line_in_scroll_region (void)
-{
-   SLtt_goto_rc (Cursor_r - Scroll_r1, 0);
-   SLtt_del_eol ();
-}
-
-void SLtt_delete_nlines (int nn)
-{
-   int r1, curs;
-   unsigned int n;
-
-   if (nn <= 0) return;
-   n = (unsigned int) nn;
-
-   SLtt_normal_video ();
-
-   if (Scroll_r1 == Scroll_r2)
-     {
-	delete_line_in_scroll_region ();
-	return;
-     }
-
-   if (Del_N_Lines_Str != NULL) tt_printf(Del_N_Lines_Str, n, 0);
-   else
-   /* get a new terminal */
-     {
-	char buf[80];
-	unsigned int dn = n;
-
-	if (dn > sizeof (buf))
-	  dn = sizeof (buf);
-
-	SLMEMSET (buf, '\n', dn);
-	while (n > dn)
-	  {
-	     tt_write (buf, dn);
-	     n -= dn;
-	  }
-	tt_write (buf, n);
-
-	r1 = Scroll_r1;
-	curs = Cursor_r;
-	SLtt_set_scroll_region(curs, Scroll_r2);
-	SLtt_goto_rc(Scroll_r2 - Scroll_r1, 0);
-	SLMEMSET(buf, '\n', (unsigned int) n);
-	tt_write(buf, (unsigned int) n);
-	/* while (n--) tt_putchar('\n'); */
-	SLtt_set_scroll_region(r1, Scroll_r2);
-	SLtt_goto_rc(curs, 0);
-     }
-}
-
-void SLtt_cls (void)
-{
-   /* If the terminal is a color terminal but the user wants black and 
-    * white, then make sure that the colors are reset.  This appears to be
-    * necessary.
-    */
-   if ((SLtt_Use_Ansi_Colors == 0) && Is_Color_Terminal)
-     {
-	if (Reset_Color_String != NULL)
-	  tt_write_string (Reset_Color_String);
-	else
-	  tt_write ("\033[0m\033[m", 7);
-     }
-
-   SLtt_normal_video();
-   SLtt_reset_scroll_region ();
-   tt_write_string(Cls_Str);
-}
-
-void SLtt_reverse_index (int n)
-{
-   if (!n) return;
-
-   SLtt_normal_video();
-
-   if (Scroll_r1 == Scroll_r2)
-     {
-	delete_line_in_scroll_region ();
-	return;
-     }
-
-   if (Add_N_Lines_Str != NULL) tt_printf(Add_N_Lines_Str,n, 0);
-   else
-     {
-	while(n--) tt_write_string(Rev_Scroll_Str);
-     }
-}
-
-int SLtt_Ignore_Beep = 1;
-static char *Visible_Bell_Str;
-
-void SLtt_beep (void)
-{
-   if (SLtt_Ignore_Beep & 0x1) SLtt_putchar('\007');
-
-   if (SLtt_Ignore_Beep & 0x2)
-     {
-	if (Visible_Bell_Str != NULL) tt_write_string (Visible_Bell_Str);
-#ifdef __linux__
-	else if (Linux_Console)
-	  {
-	     tt_write ("\033[?5h", 5);
-	     SLtt_flush_output ();
-	     _pSLusleep (50000);
-	     tt_write ("\033[?5l", 5);
-	  }
-#endif
-     }
-   SLtt_flush_output ();
-}
-
-static void write_string_with_care (char *);
-
-static void del_eol (void)
-{
-#if 0
-   int c;
-#endif
-   if ((Del_Eol_Str != NULL)
-       && (Can_Background_Color_Erase || ((Current_Fgbg & ~0xFF) == 0)))
-     {
-	tt_write_string(Del_Eol_Str);
-	return;
-     }
-
-#if 0
-   c = Cursor_c;
-   
-   /* Avoid writing to the lower right corner.  If the terminal does not
-    * have Del_Eol_Str, then it probably does not have what it takes to play
-    * games with insert-mode to "push" the desired character into that corner.
-    */
-   if (Cursor_r + 1 < SLtt_Screen_Rows)
-     c++;
-
-   while (c < SLtt_Screen_Cols)
-     {
-	tt_write (" ", 1);
-	c++;
-     }
-   Cursor_c = (SLtt_Screen_Cols-1);
-#else
-   while (Cursor_c < SLtt_Screen_Cols)
-     {
-	write_string_with_care (" ");
-	Cursor_c++;
-     }
-   Cursor_c = SLtt_Screen_Cols - 1;
-   Cursor_Set = 0;
-#endif
-}
-
-void SLtt_del_eol (void)
-{
-   if (Current_Fgbg != 0xFFFFFFFFU) SLtt_normal_video ();
-   del_eol ();
-}
-
-typedef SLCONST struct
-{
-   char *name;
-   SLtt_Char_Type color;
-}
-Color_Def_Type;
-
-#define MAX_COLOR_NAMES 17
-static Color_Def_Type Color_Defs [MAX_COLOR_NAMES] =
-{
-     {"black",		SLSMG_COLOR_BLACK},
-     {"red",		SLSMG_COLOR_RED},
-     {"green",		SLSMG_COLOR_GREEN},
-     {"brown",		SLSMG_COLOR_BROWN},
-     {"blue",		SLSMG_COLOR_BLUE},
-     {"magenta",	SLSMG_COLOR_MAGENTA},
-     {"cyan",		SLSMG_COLOR_CYAN},
-     {"lightgray",	SLSMG_COLOR_LGRAY},
-     {"gray",		SLSMG_COLOR_GRAY},
-     {"brightred",	SLSMG_COLOR_BRIGHT_RED},
-     {"brightgreen",	SLSMG_COLOR_BRIGHT_GREEN},
-     {"yellow",		SLSMG_COLOR_BRIGHT_BROWN},
-     {"brightblue",	SLSMG_COLOR_BRIGHT_BLUE},
-     {"brightmagenta",	SLSMG_COLOR_BRIGHT_CYAN},
-     {"brightcyan",	SLSMG_COLOR_BRIGHT_MAGENTA},
-     {"white",		SLSMG_COLOR_BRIGHT_WHITE},
-#define SLSMG_COLOR_DEFAULT 0xFF
-     {"default",		SLSMG_COLOR_DEFAULT}
-};
-
-static int Brushes_Initialized = 0;
-
-static int initialize_brushes (void)
-{
-   int fg, bg;
-   Brush_Info_Type *b, *bmax;
-
-   b = Brush_Table;
-   bmax = b + JMAX_COLORS;
-
-   bg = 0;
-   while (b < bmax)
-     {
-	fg = 7;
-	while (b < bmax)
-	  {
-	     if (fg != bg)
-	       {
-		  b->fgbg = MAKE_COLOR(fg,bg);
-		  b->mono = SLTT_REV_MASK;
-		  b++;
-	       }
-	     if (fg == 0)
-	       break;
-	     fg--;
-	  }
-	bg++;
-	if (bg == 8)
-	  bg = 0;
-     }
-
-   Brush_Table[0].mono = 0;
-   Brushes_Initialized = 1;
-   return 0;
-}
-   
-   
-static Brush_Info_Type *get_brush_info (unsigned int color)
-{
-   if (Brushes_Initialized == 0)
-     initialize_brushes ();
-
-   color &= SLSMG_COLOR_MASK;
-
-   if (color >= JMAX_COLORS)
-     color = 0;
-
-   return Brush_Table + color;
-}
-
-static SLtt_Char_Type get_brush_attr (unsigned int color)
-{
-   Brush_Info_Type *b;
-   
-   if (NULL == (b = get_brush_info (color)))
-     return (SLtt_Char_Type)-1;
-   
-   if (SLtt_Use_Ansi_Colors)
-     return b->fgbg;
-   
-   return b->mono;
-}
-
-static SLtt_Char_Type get_brush_fgbg (unsigned int color)
-{
-   return get_brush_info(color)->fgbg;
-}
-
-int SLtt_set_mono (int obj, char *what, SLtt_Char_Type mask)
-{
-   Brush_Info_Type *b;
-
-   (void) what;
-   if (NULL == (b = get_brush_info (obj)))
-     return -1;
-   
-   b->mono = mask & ATTR_MASK;
-   return 0;
-}
-
-static char *check_color_for_digit_form (char *color)
-{
-   unsigned int i, ich;
-   unsigned char *s = (unsigned char *) color;
-
-   i = 0;
-   while ((ich = (unsigned int) *s) != 0)
-     {
-	if ((ich < '0') || (ich > '9'))
-	  return color;
-
-	i = i * 10 + (ich - '0');
-	s++;
-     }
-
-   if (i < MAX_COLOR_NAMES)
-     color = Color_Defs[i].name;
-
-   return color;
-}
-
-static int get_default_colors (char **fgp, char **bgp)
-{
-   static char fg_buf[16], bg_buf[16], *bg, *fg;
-   static int already_parsed;
-   char *p, *pmax;
-
-   if (already_parsed == -1)
-     return -1;
-
-   if (already_parsed)
-     {
-	*fgp = fg;
-	*bgp = bg;
-	return 0;
-     }
-
-   already_parsed = -1;
-
-   bg = getenv ("COLORFGBG");
-
-   if (bg == NULL)
-     {
-	bg = getenv ("DEFAULT_COLORS");
-	if (bg == NULL)
-	  return -1;
-     }
-
-   p = fg_buf;
-   pmax = p + (sizeof (fg_buf) - 1);
-
-   while ((*bg != 0) && (*bg != ';'))
-     {
-	if (p < pmax) *p++ = *bg;
-	bg++;
-     }
-   *p = 0;
-
-   if (*bg) bg++;
-
-   p = bg_buf;
-   pmax = p + (sizeof (bg_buf) - 1);
-
-   /* Mark suggested allowing for extra application specific stuff following
-    * the background color.  That is what the check for the semi-colon is for.
-    */
-   while ((*bg != 0) && (*bg != ';'))
-     {
-	if (p < pmax) *p++ = *bg;
-	bg++;
-     }
-   *p = 0;
-
-   if (!strcmp (fg_buf, "default") || !strcmp(bg_buf, "default"))
-     {
-	*fgp = *bgp = fg = bg = "default";
-     }
-   else
-     {
-	*fgp = fg = check_color_for_digit_form (fg_buf);
-	*bgp = bg = check_color_for_digit_form (bg_buf);
-     }
-   already_parsed = 1;
-   return 0;
-}
-
-static int Color_0_Modified = 0;
-
-int SLtt_set_color_object (int obj, SLtt_Char_Type attr)
-{
-   Brush_Info_Type *b;
-   
-   if (NULL == (b = get_brush_info (obj)))
-     return -1;
-
-   b->fgbg = attr;
-   if (obj == 0) Color_0_Modified = 1;
-
-   if (_pSLtt_color_changed_hook != NULL)
-     (*_pSLtt_color_changed_hook)();
-   
-   return 0;
-}
-
-SLtt_Char_Type SLtt_get_color_object (int obj)
-{
-   return get_brush_fgbg (obj);
-}
-
-int SLtt_add_color_attribute (int obj, SLtt_Char_Type attr)
-{
-   Brush_Info_Type *b;
-   
-   if (NULL == (b = get_brush_info (obj)))
-     return -1;
-
-   b->fgbg |= (attr & ATTR_MASK);
-
-   if (obj == 0) Color_0_Modified = 1;
-   if (_pSLtt_color_changed_hook != NULL)
-     (*_pSLtt_color_changed_hook)();
-   
-   return 0;
-}
-
-static SLtt_Char_Type fb_to_fgbg (SLtt_Char_Type f, SLtt_Char_Type b)
-{
-   SLtt_Char_Type attr;
-
-   if (Max_Terminfo_Colors != 8)
-     {
-	if (f != SLSMG_COLOR_DEFAULT) f %= Max_Terminfo_Colors;
-	if (b != SLSMG_COLOR_DEFAULT) b %= Max_Terminfo_Colors;
-	return ((f << 8) | (b << 16));
-     }
-
-   /* Otherwise we have 8 ansi colors.  Try to get bright versions
-    * by using the BOLD and BLINK attributes.
-    */
-
-   attr = 0;
-
-   /* Note:  If f represents default, it will have the value 0xFF */
-   if (f != SLSMG_COLOR_DEFAULT)
-     {
-	if (f & 0x8) attr = SLTT_BOLD_MASK;
-	f &= 0x7;
-     }
-
-   if (b != SLSMG_COLOR_DEFAULT)
-     {
-	if (b & 0x8) attr |= SLTT_BLINK_MASK;
-	b &= 0x7;
-     }
-
-   return ((f << 8) | (b << 16) | attr);
-}
-
-/* This looks for colors with name form 'colorN'.  If color is of this
- * form, N is passed back via parameter list.
- */
-static int parse_color_digit_name (char *color, SLtt_Char_Type *f)
-{
-   unsigned int i;
-   unsigned char ch;
-
-   if (strncmp (color, "color", 5))
-     return -1;
-
-   color += 5;
-   if (*color == 0)
-     return -1;
-
-   i = 0;
-   while (1)
-     {
-	unsigned int j;
-
-	ch = (unsigned char) *color++;
-	if (ch == 0)
-	  break;
-	if ((ch > '9') || (ch < '0'))
-	  return -1;
-	
-	if (i > 0xFFFFFFFFU / 10)
-	  return -1;
-	j = (i *= 10);
-	i += (ch - '0');
-	if (i < j)
-	  return -1;
-     }
-
-   *f = (SLtt_Char_Type) i;
-   return 0;
-}
-
-static int make_color_fgbg (char *fg, char *bg, SLtt_Char_Type *fgbg)
-{
-   SLtt_Char_Type f = 0xFFFFFFFFU, b = 0xFFFFFFFFU;
-   char *dfg, *dbg;
-   unsigned int i;
-
-   if ((fg != NULL) && (*fg == 0)) fg = NULL;
-   if ((bg != NULL) && (*bg == 0)) bg = NULL;
-
-   if ((fg == NULL) || (bg == NULL))
-     {
-	if (-1 == get_default_colors (&dfg, &dbg))
-	  return -1;
-
-	if (fg == NULL) fg = dfg;
-	if (bg == NULL) bg = dbg;
-     }
-
-   if (-1 == parse_color_digit_name (fg, &f))
-     {
-	for (i = 0; i < MAX_COLOR_NAMES; i++)
-	  {
-	     if (strcmp(fg, Color_Defs[i].name)) continue;
-	     f = Color_Defs[i].color;
-	     break;
-	  }
-     }
-
-   if (-1 == parse_color_digit_name (bg, &b))
-     {
-	for (i = 0; i < MAX_COLOR_NAMES; i++)
-	  {
-	     if (strcmp(bg, Color_Defs[i].name)) continue;
-	     b = Color_Defs[i].color;
-	     break;
-	  }
-     }
-
-   if ((f == 0xFFFFFFFFU) || (b == 0xFFFFFFFFU))
-     return -1;
-
-   *fgbg = fb_to_fgbg (f, b);
-   return 0;
-}
-
-int SLtt_set_color (int obj, char *what, char *fg, char *bg)
-{
-   SLtt_Char_Type fgbg;
-
-   (void) what;
-   
-   if (-1 == make_color_fgbg (fg, bg, &fgbg))
-     return -1;
-
-   return SLtt_set_color_object (obj, fgbg);
-}
-
-int SLtt_set_color_fgbg (int obj, SLtt_Char_Type f, SLtt_Char_Type b)
-{
-   return SLtt_set_color_object (obj, fb_to_fgbg (f, b));
-}
-
-void SLtt_set_alt_char_set (int i)
-{
-   static int last_i;
-   if (SLtt_Has_Alt_Charset == 0) return;
-
-   i = (i != 0);
-
-   if (i == last_i) return;
-   tt_write_string (i ? Start_Alt_Chars_Str : End_Alt_Chars_Str );
-   last_i = i;
-}
-
-static void write_attributes (SLtt_Char_Type fgbg)
-{
-   int bg0, fg0;
-   int unknown_attributes;
-
-   if (Worthless_Highlight) return;
-   if (fgbg == Current_Fgbg) return;
-
-   unknown_attributes = 0;
-
-   /* Before spitting out colors, fix attributes */
-   if ((fgbg & ATTR_MASK) != (Current_Fgbg & ATTR_MASK))
-     {
-	if (Current_Fgbg & ATTR_MASK)
-	  {
-	     tt_write_string(Norm_Vid_Str);
-	     /* In case normal video turns off ALL attributes: */
-	     if (fgbg & SLTT_ALTC_MASK)
-	       Current_Fgbg &= ~SLTT_ALTC_MASK;
-	     SLtt_set_alt_char_set (0);
-	  }
-
-	if ((fgbg & SLTT_ALTC_MASK)
-	    != (Current_Fgbg & SLTT_ALTC_MASK))
-	  {
-	     SLtt_set_alt_char_set ((int) (fgbg & SLTT_ALTC_MASK));
-	  }
-
-	if (fgbg & SLTT_ULINE_MASK) tt_write_string (UnderLine_Vid_Str);
-	if (fgbg & SLTT_BOLD_MASK) SLtt_bold_video ();
-	if (fgbg & SLTT_REV_MASK) tt_write_string (Rev_Vid_Str);
-	if (fgbg & SLTT_BLINK_MASK)
-	  {
-	     /* Someday Linux will have a blink mode that set high intensity
-	      * background.  Lets be prepared.
-	      */
-	     if (SLtt_Blink_Mode) tt_write_string (Blink_Vid_Str);
-	  }
-	unknown_attributes = 1;
-     }
-
-   if (SLtt_Use_Ansi_Colors)
-     {
-	fg0 = (int) GET_FG(fgbg);
-	bg0 = (int) GET_BG(fgbg);
-
-	if (unknown_attributes 
-	    || (fg0 != (int)GET_FG(Current_Fgbg)))
-	  {
-	     if (fg0 == SLSMG_COLOR_DEFAULT)
-	       tt_write_string (Default_Color_Fg_Str);
-	     else
-	       tt_printf (Color_Fg_Str, COLOR_ARG(fg0, Is_Bg_BGR), 0);
-	  }
-
-	if (unknown_attributes
-	    || (bg0 != (int)GET_BG(Current_Fgbg)))
-	  {
-	     if (bg0 == SLSMG_COLOR_DEFAULT)
-	       tt_write_string (Default_Color_Bg_Str);
-	     else
-	       tt_printf (Color_Bg_Str, COLOR_ARG(bg0, Is_Bg_BGR), 0);
-	  }
-     }
-
-   Current_Fgbg = fgbg;
-}
-
-static int Video_Initialized;
-
-void SLtt_reverse_video (int color)
-{
-   SLtt_Char_Type fgbg;
-
-   if (Worthless_Highlight) return;
-
-   if (Video_Initialized == 0)
-     {
-	if (color == JNORMAL_COLOR)
-	  {
-	     tt_write_string (Norm_Vid_Str);
-	  }
-	else tt_write_string (Rev_Vid_Str);
-	Current_Fgbg = 0xFFFFFFFFU;
-	return;
-     }
-
-  fgbg = get_brush_attr (color);
-
-   if (fgbg == Current_Fgbg) return;
-   write_attributes (fgbg);
-}
-
-void SLtt_normal_video (void)
-{
-   SLtt_reverse_video(JNORMAL_COLOR);
-}
-
-void SLtt_narrow_width (void)
-{
-   tt_write ("\033[?3l", 5);
-}
-
-void SLtt_wide_width (void)
-{
-   tt_write ("\033[?3h", 5);
-}
-
-/* Highest bit represents the character set. */
-#define COLOR_OF(a) ((a)->color & SLSMG_COLOR_MASK)
-
-static int bce_color_eqs (SLsmg_Char_Type *a, SLsmg_Char_Type *b)
-{
-   SLsmg_Color_Type ca, cb;
-   Brush_Info_Type *ba, *bb;
-
-   ca = COLOR_OF(a);
-   cb = COLOR_OF(b);
-
-   if (ca == cb)
-     return 1;
-
-   ba = get_brush_info (ca);
-   bb = get_brush_info (cb);
-   
-   if (SLtt_Use_Ansi_Colors == 0)
-     return ba->mono == bb->mono;
-
-   if (Bce_Color_Offset == 0)
-     return ba->fgbg == bb->fgbg;
-
-   /* If either are color 0, then we do not know what that means since the
-    * terminal does not support BCE */
-   if ((ca == 0) || (cb == 0))
-     return 0;
-   
-   return get_brush_fgbg (ca-1) == get_brush_fgbg(cb-1);
-}
-
-/* The whole point of this routine is to prevent writing to the last column
- * and last row on terminals with automatic margins.
- */
-static void write_string_with_care (char *str)
-{
-   unsigned int len;
-
-   if (str == NULL) return;
-
-   len = strlen (str);
-   if (Automatic_Margins && (Cursor_r + 1 == SLtt_Screen_Rows))
-     {
-	if (_pSLtt_UTF8_Mode == 0) 
-	 {
-	   if (len + (unsigned int) Cursor_c >= (unsigned int) SLtt_Screen_Cols)
-	     {
-	        /* For now, just do not write there.  Later, something more
-	        * sophisticated will be implemented.
-	        */
-	        if (SLtt_Screen_Cols > Cursor_c)
-	          len = SLtt_Screen_Cols - Cursor_c - 1;
-	        else 
-	          len = 0;
-	     }
-	 }
-       else
-	 {
-	    unsigned int nchars = SLutf8_strlen((SLuchar_Type *)str, 1);
-	    if (nchars + (unsigned int) Cursor_c >= (unsigned int) SLtt_Screen_Cols)
-	     {
-	       if (SLtt_Screen_Cols > Cursor_c)
-	         {
-		    char *p;
-		    nchars = SLtt_Screen_Cols - Cursor_c - 1;
-		    p = (char *)SLutf8_skip_chars((SLuchar_Type *) str, (SLuchar_Type *)(str + len), nchars, NULL, 1);
-		    len = p - str;
-		 }
-	       else
-		  len = 0; 
-	     }
-	 }
-     }
-   tt_write (str, len);
-}
-
-static void send_attr_str (SLsmg_Char_Type *s, SLsmg_Char_Type *smax)
-{
-   unsigned char out[1+SLUTF8_MAX_MBLEN*SLSMG_MAX_CHARS_PER_CELL*SLTT_MAX_SCREEN_COLS];
-   unsigned char *p, *pmax;
-   register SLtt_Char_Type attr;
-   SLsmg_Color_Type color, last_color = (SLsmg_Color_Type)-1;
-   int dcursor_c;
-
-   p = out;
-   pmax = p + (sizeof (out)-1);
-
-   dcursor_c = 0;
-   while (s < smax)
-     {
-	SLwchar_Type wch;
-	unsigned int nchars;
-
-	if (0 == (nchars = s->nchars))
-	  {
-	     /* 2nd element of a char that occupies two columns */
-	     s++;
-	     if (_pSLtt_UTF8_Mode == 0)
-	       *p++ = ' ';
-	     dcursor_c++;
-	     continue;
-	  }
-
-	color = s->color;
-
-#if SLTT_HAS_NON_BCE_SUPPORT
-	if (Bce_Color_Offset
-	    && (color >= Bce_Color_Offset))
-	  color -= Bce_Color_Offset;
-#endif
-
-	wch = s->wchars[0];
-
-	if (color != last_color)
-	  {
-	     attr = get_brush_attr (color);
-
-	     if (color & SLSMG_ACS_MASK) /* alternate char set */
-	       {
-		  if (SLtt_Use_Blink_For_ACS)
-		    {
-		       if (SLtt_Blink_Mode) attr |= SLTT_BLINK_MASK;
-		    }
-		  else attr |= SLTT_ALTC_MASK;
-	       }
-
-	     if (attr != Current_Fgbg)
-	       {
-		  if ((wch != ' ')
-		      || (nchars > 1)
-		      /* it is a space so only consider it different if it
-		       * has different attributes.
-		       */
-		      || (attr != Current_Fgbg)
-		      )
-		    {
-		       if (p != out)
-			 {
-			    *p = 0;
-			    write_string_with_care ((char *) out);
-			    p = out;
-			    Cursor_c += dcursor_c;
-			    dcursor_c = 0;
-			 }
-		       write_attributes (attr);
-		       last_color = color;
-		    }
-	       }
-	  }
-	
-	if ((wch < 0x80) && (nchars == 1))
-	  *p++ = (unsigned char) wch;
-	else if (_pSLtt_UTF8_Mode == 0)
-	  {
-	     if (wch > 255)
-	       wch = '?';
-	     else if (wch < (SLwchar_Type)SLsmg_Display_Eight_Bit)
-	       wch = '?';
-	     *p++ = (unsigned char) wch;
-	  }
-	else
-	  {
-	     unsigned int i;
-	     for (i = 0; i < nchars; i++)
-	       {
-		  if (NULL == (p = SLutf8_encode (s->wchars[i], p, pmax-p)))
-		    {
-		       fprintf (stderr, "*** send_attr_str: buffer too small\n");
-		       return;
-		    }
-	       }
-	  }
-	dcursor_c++;
-	s++;
-     }
-   *p = 0;
-   if (p != out) write_string_with_care ((char *) out);
-   Cursor_c += dcursor_c;
-}
-
-static void forward_cursor (unsigned int n, int row)
-{
-   char buf [1024];
-
-
-   /* if (Current_Fgbg & ~0xFF) */
-   /*   { */
-   /* 	unsigned int num = 0; */
-   /* 	while (num < n) */
-   /* 	  { */
-   /* 	     write_string_with_care (" "); */
-   /* 	     num++; */
-   /* 	  } */
-   /* 	Cursor_c += n; */
-   /* 	return; */
-   /*   } */
-   
-	
-   if (n <= 4)
-     {
-	SLtt_normal_video ();
-#if 0
-	if (n >= sizeof (buf))
-	  n = sizeof (buf) - 1;
-#endif
-	SLMEMSET (buf, ' ', n);
-	buf[n] = 0;
-	write_string_with_care (buf);
-	Cursor_c += n;
-     }
-   else if (Curs_F_Str != NULL)
-     {
-	Cursor_c += n;
-	n = tt_sprintf(buf, sizeof (buf), Curs_F_Str, (int) n, 0);
-	tt_write(buf, n);
-     }
-   else SLtt_goto_rc (row, (int) (Cursor_c + n));
-}
-
-
-/* FIXME!!  If the terminal does not support color, then this route has 
- * problems of color object 0 has been assigned some monochrome attribute
- * such as reverse video.  In such a case, space_char=' ' is not a simple
- * space character as is assumed below.
- */
-
-#define COLOR_EQS(a,b) ((COLOR_OF(a)==COLOR_OF(b)) || bce_color_eqs (a,b))
-#define CHARSET(a) ((a)->color&SLSMG_ACS_MASK)
-#define CHAR_EQS(a, b) (((a)->nchars==(b)->nchars) \
-			   && (((a)->nchars == 0) \
-				  || ((((a)->wchars[0]==(b)->wchars[0]) \
-					 && (0 == memcmp((a)->wchars, (b)->wchars, (a)->nchars*sizeof(SLwchar_Type)))) \
-					 && (COLOR_EQS(a,b)) \
-					 && (CHARSET(a)==CHARSET(b)))))
-
-#define CHAR_EQS_SPACE(a) (((a)->wchars[0]==' ') && ((a)->color==0) && ((a)->nchars==1))
-
-void SLtt_smart_puts(SLsmg_Char_Type *neww, SLsmg_Char_Type *oldd, int len, int row)
-{
-   register SLsmg_Char_Type *p, *q, *qmax, *pmax, *buf;
-   SLsmg_Char_Type buffer[SLTT_MAX_SCREEN_COLS+1];
-   unsigned int n_spaces;
-   SLsmg_Char_Type *space_match, *last_buffered_match;
-#ifdef HP_GLITCH_CODE
-   int handle_hp_glitch = 0;
-#endif
-   SLsmg_Char_Type *space_char;
-   SLsmg_Char_Type space_char_buf;
-
-#define SLTT_USE_INSERT_HACK 1
-#if SLTT_USE_INSERT_HACK
-   SLsmg_Char_Type *insert_hack_prev = NULL;
-   SLsmg_Char_Type *insert_hack_char = NULL;
-
-   if ((row + 1 == SLtt_Screen_Rows)
-       && (len == SLtt_Screen_Cols)
-       && (len > 1)
-       && (SLtt_Term_Cannot_Insert == 0)
-       && Automatic_Margins)
-     {
-	SLsmg_Char_Type *a, *b;
-	insert_hack_char = &neww[len-1];
-
-	a = oldd+(len-1);
-	b = neww+(len-1);
-	
-	if (CHAR_EQS(a,b))
-	  insert_hack_char = NULL;
-	else 
-	  insert_hack_prev = &neww[len-2];
-     }
-#endif
-     
-   memset ((char *) &space_char_buf, 0, sizeof (SLsmg_Char_Type));
-   space_char = &space_char_buf;
-   space_char->nchars = 1;
-   space_char->wchars[0] = ' ';
-
-   if (len > SLTT_MAX_SCREEN_COLS)
-     len = SLTT_MAX_SCREEN_COLS;
-
-   q = oldd; p = neww;
-   qmax = oldd + len;
-   pmax = p + len;
-
-   /* Find out where to begin --- while they match, we are ok */
-   while (1)
-     {
-	if (q == qmax) return;
-
-#if SLANG_HAS_KANJI_SUPPORT
-	if (*p & 0x80)
-	  { /* new is kanji */
-	     if ((*q & 0x80) && ((q + 1) < qmax))
-	       { /* old is also kanji */
-		  if (((0xFF & *q) != (0xFF & *p))
-		      || ((0xFF & q[1]) != (0xFF & p[1])))
-		    break; /* both kanji, but not match */
-
-		  else
-		    { /* kanji match ! */
-		       if (!COLOR_EQS(*q, *p)) break;
-		       q++; p++;
-		       if (!COLOR_EQS(*q, *p)) break;
-		       /* really match! */
-		       q++; p++;
-		       continue;
-		    }
-	       }
-	     else break; /* old is not kanji */
-	  }
-	else
-	  { /* new is not kanji */
-	     if (*q & 0x80) break; /* old is kanji */
-	  }
-#endif
-	if (!CHAR_EQS(q, p)) break;
-	q++; p++;
-     }
-
-#ifdef HP_GLITCH_CODE
-   if (Has_HP_Glitch)
-     {
-	SLsmg_Char_Type *qq = q;
-
-	SLtt_goto_rc (row, (int) (p - neww));
-
-	while (qq < qmax)
-	  {
-	     if (qq->color)
-	       {
-		  SLtt_normal_video ();
-		  SLtt_del_eol ();
-		  qmax = q;
-		  handle_hp_glitch = 1;
-		  break;
-	       }
-	     qq++;
-	  }
-     }
-#endif
-   /* Find where the last non-blank character on old/new screen is */
-
-   if (CHAR_EQS_SPACE(pmax-1))
-     {
-	/* If we get here, then we can erase to the end of the line to create
-	 * the final space.  However, this will only work _if_ erasing will 
-	 * get us the correct color.  If the terminal supports BCE, then this
-	 * is easy.  If it does not, then we can only perform this operation
-	 * if the color is known via something like COLORFGBG.  For now, 
-	 * I just will not perform the optimization for such terminals.
-	 */
-	if ((Can_Background_Color_Erase)
-	    && SLtt_Use_Ansi_Colors)
-	  space_char = pmax - 1;
-
-	while (pmax > p)
-	  {
-	     pmax--;
-	     if (!CHAR_EQS(pmax, space_char))
-	       {
-		  pmax++;
-		  break;
-	       }
-	  }
-     }
-
-   while (qmax > q)
-     {
-	qmax--;
-	if (!CHAR_EQS(qmax, space_char))
-	  {
-	     qmax++;
-	     break;
-	  }
-     }
-
-   last_buffered_match = buf = buffer;		       /* buffer is empty */
-
-#ifdef HP_GLITCH_CODE
-   if (handle_hp_glitch)
-     {
-	while (p < pmax)
-	  {
-	     *buf++ = *p++;
-	  }
-     }
-#endif
-
-#ifdef HP_GLITCH_CODE
-   if (Has_HP_Glitch == 0)
-     {
-#endif
-	/* Try use use erase to bol if possible */
-	if ((Del_Bol_Str != NULL) && (CHAR_EQS_SPACE(neww)))
-	  {
-	     SLsmg_Char_Type *p1;
-	     SLsmg_Color_Type blank_color = 0;
-
-	     p1 = neww;
-	     if ((Can_Background_Color_Erase)
-		 && SLtt_Use_Ansi_Colors)
-	       {
-		  SLsmg_Char_Type *blank = p1;
-		  blank_color = COLOR_OF(blank);
-		  while ((p1 < pmax) && (CHAR_EQS (p1, blank)))
-		    p1++;
-	       }
-	     else
-	       {
-		  /* black+white attributes do not support bce */
-		  while ((p1 < pmax) && (CHAR_EQS_SPACE (p1)))
-		    p1++;
-	       }
-	     
-	     /* Is this optimization worth it?  Assume Del_Bol_Str is ESC [ 1 K
-	      * It costs 4 chars + the space needed to properly position the 
-	      * cursor, e.g., ESC [ 10;10H. So, it costs at least 13 characters.
-	      */
-	     if ((p1 > neww + 13) 
-		 && (p1 >= p)
-		 /* Avoid erasing from the end of the line */
-		 && ((p1 != pmax) || (pmax < neww + len)))
-	       {
-		  int ofs = (int) (p1 - neww);
-		  q = oldd + ofs;
-		  p = p1;
-		  SLtt_goto_rc (row, ofs - 1);
-		  SLtt_reverse_video (blank_color);
-		  tt_write_string (Del_Bol_Str);
-		  tt_write (" ", 1);
-		  Cursor_c += 1;
-	       }
-	     else
-	       SLtt_goto_rc (row, (int) (p - neww));
-	  }
-	else
-	  SLtt_goto_rc (row, (int) (p - neww));
-#ifdef HP_GLITCH_CODE
-     }
-#endif
-   
-   
-   /* loop using overwrite then skip algorithm until done */
-   while (1)
-     {
-	/* while they do not match and we do not hit a space, buffer them up */
-	n_spaces = 0;
-	while (p < pmax)
-	  {
-	     if (CHAR_EQS_SPACE(q) && CHAR_EQS_SPACE(p))
-	       {
-		  /* If *q is not a space, we would have to overwrite it.
-		   * However, if *q is a space, then while *p is also one,
-		   * we only need to skip over the blank field.
-		   */
-		  space_match = p;
-		  p++; q++;
-		  while ((p < pmax)
-			 && CHAR_EQS_SPACE(q)
-			 && CHAR_EQS_SPACE(p))
-		    {
-		       p++;
-		       q++;
-		    }
-		  n_spaces = (unsigned int) (p - space_match);
-		  break;
-	       }
-#if SLANG_HAS_KANJI_SUPPORT
-	     if ((*p & 0x80) && ((p + 1) < pmax))
-	       { /* new is kanji */
-		  if (*q & 0x80)
-		    { /* old is also kanji */
-		       if (((0xFF & *q) != (0xFF & *p))
-			   || ((0xFF & q[1]) != (0xFF & p[1])))
-			 {
-			    /* both kanji, but not match */
-			    *buf++ = *p++;
-			    *buf++ = *p++;
-			    q += 2;
-			    continue;
-			 }
-		       else
-			 { /* kanji match ? */
-			    if (!COLOR_EQS(*q, *p) || !COLOR_EQS(*(q+1), *(p+1)))
-			      {
-				 /* code is match, but color is diff */
-				 *buf++ = *p++;
-				 *buf++ = *p++;
-				 q += 2;
-				 continue;
-			      }
-			    /* really match ! */
-			    break;
-			 }
-		    }
- 		  else
-		    { /* old is not kanji */
-		       *buf++ = *p++;
-		       *buf++ = *p++;
-		       q += 2;
-		       continue;
-		    }
-	       }
-	     else
-	       { /* new is not kanji */
- 		  if (*q & 0x80)
-		    { /* old is kanji */
-		       *buf++ = *p++;
-		       q++;
-		       continue;
-		    }
-	       }
-#endif
-
-	     if (CHAR_EQS(q, p)) 
-	       {
-		  /* Could be the second half of a double width character */
-		  if (p->nchars || q->nchars)
-		    break;
-	       }
-	     *buf++ = *p++;
-	     q++;
-	  }
-
-	/* At this point, the buffer contains characters that do not match */
-	if (buf != buffer) send_attr_str (buffer, buf);
-	buf = buffer;
-
-	if (n_spaces 
-	    && ((p < pmax) 	       /* erase to eol will achieve this effect*/
-		|| (!CHAR_EQS_SPACE(space_char))))/* unless space_char is not a simple space */
-	  {
-	     forward_cursor (n_spaces, row);
-	  }
-	/* Now we overwrote what we could and cursor is placed at position
-	 * of a possible match of new and old.  If this is the case, skip
-	 * some more.
-	 */
-	
-	/* Note that from here on, the buffer will contain matched characters */
-#if !SLANG_HAS_KANJI_SUPPORT
-	while ((p < pmax) && CHAR_EQS(p, q))
-	  {
-	     *buf++ = *p++;
-	     q++;
-	  }
-#else
-	/* Kanji */
-	while (p < pmax)
-	  {
-	     if ((*p & 0x80) && ((p + 1) < pmax))
-	       { /* new is kanji */
-		  if (*q & 0x80)
-		    { /* old is also kanji */
-		       if (((0xFF & *q) == (0xFF & *p))
-			   && ((0xFF & q[1]) == (0xFF & p[1])))
-			 {
-			    /* kanji match ? */
-			    if (!COLOR_EQS(*q, *p)
-				|| !COLOR_EQS(q[1], p[1]))
-			      break;
-
-			    *buf++ = *p++;
-			    q++;
-			    if (p >= pmax)
-			      {
-				 *buf++ = 32;
-				 p++;
-				 break;
-			      }
-			    else
-			      {
-				 *buf++ = *p++;
-				 q++;
-				 continue;
-			      }
-			 }
-		       else break; /* both kanji, but not match */
-		    }
-		  else break; /* old is not kanji */
-	       }
-	     else
-	       {  /* new is not kanji */
-		  if (*q & 0x80) break; /* old is kanji */
-		  if (!CHAR_EQS(*q, *p)) break;
-		  *buf++ = *p++;
-		  q++;
-	       }
-	  }
-#endif
-	last_buffered_match = buf;
-	if (p >= pmax) break;
-
-	/* jump to new position is it is greater than 5 otherwise
-	 * let it sit in the buffer and output it later.
-	 */
-	if ((int) (buf - buffer) >= 5)
-	  {
-	     forward_cursor ((unsigned int) (buf - buffer), row);
-	     last_buffered_match = buf = buffer;
-	  }
-     }
-
-   /* At this point we have reached the end of the new string with the 
-    * exception of space_chars hanging off the end of it, but we may not have
-    * reached the end of the old string if they did not match.
-    */
-   
-   /* Here the buffer will consist only of characters that have matched */
-   if (buf != buffer)
-     {
-	if (q < qmax)
-	  {
-	     if ((buf == last_buffered_match)
-		 && ((int) (buf - buffer) >= 5))
-	       {
-		  forward_cursor ((unsigned int) (buf - buffer), row);
-	       }
-	     else
-	       {
-		  send_attr_str (buffer, buf);
-	       }
-	  }
-     }
-
-   if (q < qmax) 
-     {
-	SLtt_reverse_video (COLOR_OF(space_char));
-	del_eol ();
-     }
-   
-#if SLTT_USE_INSERT_HACK
-   else if (insert_hack_char != NULL)
-     {
-	SLtt_goto_rc (SLtt_Screen_Rows-1, SLtt_Screen_Cols-2);
-	send_attr_str (insert_hack_char, insert_hack_char+1);
-	SLtt_goto_rc (SLtt_Screen_Rows-1, SLtt_Screen_Cols-2);
-	SLtt_begin_insert ();
-	send_attr_str (insert_hack_prev, insert_hack_prev+1);
-	SLtt_end_insert ();
-     }
-#endif
-
-   if (Automatic_Margins && (Cursor_c + 1 >= SLtt_Screen_Cols)) Cursor_Set = 0;
-}
-
-static void get_color_info (void)
-{
-   char *fg, *bg;
-
-   /* Allow easy mechanism to override inadequate termcap/terminfo files. */
-   if (SLtt_Use_Ansi_Colors == 0)
-     SLtt_Use_Ansi_Colors = (NULL != getenv ("COLORTERM"));
-
-   if (SLtt_Use_Ansi_Colors)
-     Is_Color_Terminal = 1;
-
-#if SLTT_HAS_NON_BCE_SUPPORT
-   if (Can_Background_Color_Erase == 0)
-     Can_Background_Color_Erase = (NULL != getenv ("COLORTERM_BCE"));
-#endif
-
-   if (-1 == get_default_colors (&fg, &bg))
-     return;
-
-   /* Check to see if application has already set them. */
-   if (Color_0_Modified)
-     return;
-
-   SLtt_set_color (0, NULL, fg, bg);
-   SLtt_set_color (1, NULL, bg, fg);
-}
-
-/* termcap stuff */
-
-#ifdef __unix__
-
-static int Termcap_Initalized = 0;
-
-/* #define USE_TERMCAP 1 */
-#ifdef USE_TERMCAP
-/* Termcap based system */
-static char Termcap_Buf[4096];
-/* static char Termcap_String_Buf[4096]; */
-/* static char *Termcap_String_Ptr; */
-extern char *tgetstr(char *, char **);
-extern int tgetent(char *, char *);
-extern int tgetnum(char *);
-extern int tgetflag(char *);
-#else
-/* Terminfo */
-static SLterminfo_Type *Terminfo;
-#endif
-
-#define TGETFLAG(x) (SLtt_tgetflag(x) > 0)
-
-static char *fixup_tgetstr (char *what)
-{
-   register char *w, *w1;
-   char *wsave;
-   
-   if (what == NULL)
-     return NULL;
-
-   /* Check for AIX brain-damage */
-   if (*what == '@')
-     return NULL;
-
-   /* lose pad info --- with today's technology, term is a loser if
-    it is really needed */
-   while ((*what == '.') ||
-	  ((*what >= '0') && (*what <= '9'))) what++;
-   if (*what == '*') what++;
-   
-   /* lose terminfo padding--- looks like $<...> */
-   w = what;
-   while (*w) if ((*w++ == '$') && (*w == '<'))
-     {
-	w1 = w - 1;
-	while (*w && (*w != '>')) w++;
-	if (*w == 0) break;
-	w++;
-	wsave = w1;
-	while ((*w1++ = *w++) != 0);
-	w = wsave;
-     }
-
-   if (*what == 0) what = NULL;
-   return what;
-}
-
-char *SLtt_tgetstr (char *cap)
-{
-   char *s;
-#ifdef USE_TERMCAP
-   char area_buf[4096];
-   char *area;
-#endif
-   if (Termcap_Initalized == 0)
-     return NULL;
-   
-#ifdef USE_TERMCAP
-   /* tmp_area = &Termcap_String_Buf; */
-   area = area_buf;
-   s = tgetstr (cap, &area);
-   if (area > area_buf + sizeof(area_buf))
-     {
-	SLang_exit_error ("\
-The termcap tgetstr appears to have overflowed a buffer.\n\
-The integrity of this program has been violated.\n");
-     }
-#else
-   s = _pSLtt_tigetstr (Terminfo, cap);
-#endif
-
-   /* Do not strip pad info for alternate character set.  I need to make
-    * this more general.
-    */
-   /* FIXME: Priority=low; */
-   if (0 == strcmp (cap, "ac"))
-     return s;
-
-   s = fixup_tgetstr (s);
-#ifdef USE_TERMCAP
-   if ((s >= area_buf) && (s < area_buf + sizeof(area_buf)))
-     {
-	/* It looks like tgetstr placed the object in the buffer and
-	 * returned a pointer to that buffer.  So, we have to make a
-	 * copy of it.
-	 * 
-	 * Yes, this introduces a leak...
-	 */
-	s = SLmake_string (s);
-     }
-#endif
-   return s;
-}
-
-int SLtt_tgetnum (char *s)
-{
-   if (Termcap_Initalized == 0)
-     return -1;
-#ifdef USE_TERMCAP
-   return tgetnum (s);
-#else
-   return _pSLtt_tigetnum (Terminfo, s);
-#endif
-}
-
-int SLtt_tgetflag (char *s)
-{
-   if (Termcap_Initalized == 0)
-     return -1;
-#ifdef USE_TERMCAP
-   return tgetflag (s);
-#else
-   return _pSLtt_tigetflag (Terminfo, s);
-#endif
-}
-
-#if 0
-int SLtt_tgetent(char *term)
-{
-   return SLtt_initialize(term) == 0;
-}
-
-int SLtt_tputs(char *str, int affcnt, int (*p)(int))
-{
-   while (*str) (*p)(*str++);
-   return 0;
-}
-
-
-char *SLtt_tgoto(char *cap, int col, int row)
-{
-  static char buf[64];
-
-  /* beware of overflows. 2^64 is 20 bytes printed */
-  if (strlen(cap) > 23)
-	strcpy(buf, "capability too long");
-  else
-	tt_sprintf(buf, cap, row, col);
-  return buf;
-}
-#endif
-
-static int Vt100_Like = 0;
-
-void SLtt_get_terminfo (void)
-{
-   char *term;
-   int status;
-
-   term = getenv ("TERM");
-   if (term == NULL)
-     SLang_exit_error("TERM environment variable needs set.");
-
-   if (0 == (status = SLtt_initialize (term)))
-     return;
-
-   if (status == -1)
-     {
-	SLang_exit_error ("Unknown terminal: %s\n\
-Check the TERM environment variable.\n\
-Also make sure that the terminal is defined in the terminfo database.\n\
-Alternatively, set the TERMCAP environment variable to the desired\n\
-termcap entry.",
-			  term);
-     }
-
-   if (status == -2)
-     {
-	SLang_exit_error ("\
-Your terminal lacks the ability to clear the screen or position the cursor.\n");
-     }
-}
-
-/* Returns 0 if all goes well, -1 if terminal capabilities cannot be deduced,
- * or -2 if terminal cannot position the cursor.
- */
-int SLtt_initialize (char *term)
-{
-   char *t, ch;
-   int is_xterm;
-   int almost_vtxxx;
-
-   if (_pSLtt_UTF8_Mode == -1)
-     _pSLtt_UTF8_Mode = _pSLutf8_mode;
-
-   if (SLang_TT_Write_FD == -1)
-     {
-	/* Apparantly, this cannot fail according to the man pages. */
-	SLang_TT_Write_FD = fileno (stdout);
-     }
-   
-   if (term == NULL)
-     {
-	term = getenv ("TERM");
-	if (term == NULL)
-	  return -1;
-     }
-
-   if (_pSLsecure_issetugid ()
-       && ((term[0] == '.') || (NULL != strchr(term, '/'))))
-     return -1;
-   
-   Linux_Console = (!strncmp (term, "linux", 5)
-# ifdef linux
-		    || !strncmp(term, "con", 3)
-# endif
-		    );
-
-   QANSI_Console = !strncmp (term, "qansi-m", 7);
-
-   t = term;
-
-   if (strcmp(t, "vt52") && (*t++ == 'v') && (*t++ == 't')
-       && (ch = *t, (ch >= '1') && (ch <= '9'))) Vt100_Like = 1;
-
-   is_xterm = ((0 == strncmp (term, "xterm", 5))
-	       || (0 == strncmp (term, "rxvt", 4))
-	       || (0 == strncmp (term, "Eterm", 5)));
-
-   almost_vtxxx = (Vt100_Like
-		   || Linux_Console
-		   || is_xterm
-		   || !strcmp (term, "screen"));
-
-# ifndef USE_TERMCAP
-   if (NULL == (Terminfo = _pSLtt_tigetent (term)))
-     {
-	if (almost_vtxxx) /* Special cases. */
-	  {
-	     int vt102 = 1;
-	     if (!strcmp (term, "vt100")) vt102 = 0;
-	     get_color_info ();
-   	     SLtt_set_term_vtxxx (&vt102);
-	     (void) SLtt_get_screen_size ();
-	     return 0;
-	  }
-	return -1;
-     }
-# else				       /* USE_TERMCAP */
-   if (1 != tgetent(Termcap_Buf, term))
-     return -1;
-   /* Termcap_String_Ptr = Termcap_String_Buf; */
-# endif				       /* NOT USE_TERMCAP */
-
-   Termcap_Initalized = 1;
-
-   Cls_Str = SLtt_tgetstr ("cl");
-   Curs_Pos_Str = SLtt_tgetstr ("cm");
-
-   if ((NULL == (Ins_Mode_Str = SLtt_tgetstr("im")))
-       || ( NULL == (Eins_Mode_Str = SLtt_tgetstr("ei")))
-       || ( NULL == (Del_Char_Str = SLtt_tgetstr("dc"))))
-     SLtt_Term_Cannot_Insert = 1;
-
-   Visible_Bell_Str = SLtt_tgetstr ("vb");
-   Curs_Up_Str = SLtt_tgetstr ("up");
-   Rev_Scroll_Str = SLtt_tgetstr("sr");
-   Del_N_Lines_Str = SLtt_tgetstr("DL");
-   Add_N_Lines_Str = SLtt_tgetstr("AL");
-
-   /* Actually these are used to initialize terminals that use cursor
-    * addressing.  Hard to believe.
-    */
-   Term_Init_Str = SLtt_tgetstr ("ti");
-   Term_Reset_Str = SLtt_tgetstr ("te");
-
-   /* If I do this for vtxxx terminals, arrow keys start sending ESC O A,
-    * which I do not want.  This is mainly for HP terminals.
-    */
-   if ((almost_vtxxx == 0) || SLtt_Force_Keypad_Init)
-     {
-	Keypad_Init_Str = SLtt_tgetstr ("ks");
-	Keypad_Reset_Str = SLtt_tgetstr ("ke");
-     }
-
-   /* Make up for defective termcap/terminfo databases */
-   if ((Vt100_Like && (term[2] != '1'))
-       || Linux_Console
-       || is_xterm
-       )
-     {
-	if (Del_N_Lines_Str == NULL) Del_N_Lines_Str = "\033[%dM";
-	if (Add_N_Lines_Str == NULL) Add_N_Lines_Str = "\033[%dL";
-     }
-
-   Scroll_R_Str = SLtt_tgetstr("cs");
-
-   SLtt_get_screen_size ();
-
-   if ((Scroll_R_Str == NULL)
-       || (((NULL == Del_N_Lines_Str) || (NULL == Add_N_Lines_Str))
-	   && (NULL == Rev_Scroll_Str)))
-     {
-	if (is_xterm
-	    || Linux_Console
-	    )
-	  {
-	     /* Defective termcap mode!!!! */
-	     SLtt_set_term_vtxxx (NULL);
-	  }
-	else SLtt_Term_Cannot_Scroll = 1;
-     }
-
-   Del_Eol_Str = SLtt_tgetstr("ce");
-   Del_Bol_Str = SLtt_tgetstr("cb");
-   if (is_xterm && (Del_Bol_Str == NULL))
-     Del_Bol_Str = "\033[1K";
-   if (is_xterm && (Del_Eol_Str == NULL))
-     Del_Eol_Str = "\033[K";
-
-   Rev_Vid_Str = SLtt_tgetstr("mr");
-   if (Rev_Vid_Str == NULL) Rev_Vid_Str = SLtt_tgetstr("so");
-
-   Bold_Vid_Str = SLtt_tgetstr("md");
-
-   /* Although xterm cannot blink, it does display the blinking characters
-    * as bold ones.  Some Rxvt will display the background as high intensity.
-    */
-   if ((NULL == (Blink_Vid_Str = SLtt_tgetstr("mb")))
-       && is_xterm)
-     Blink_Vid_Str = "\033[5m";
-
-   UnderLine_Vid_Str = SLtt_tgetstr("us");
-
-   Start_Alt_Chars_Str = SLtt_tgetstr ("as");   /* smacs */
-   End_Alt_Chars_Str = SLtt_tgetstr ("ae");   /* rmacs */
-   Enable_Alt_Char_Set = SLtt_tgetstr ("eA");   /* enacs */
-   SLtt_Graphics_Char_Pairs = SLtt_tgetstr ("ac");
-
-   if (NULL == SLtt_Graphics_Char_Pairs)
-     {
-	/* make up for defective termcap/terminfo */
-	if (Vt100_Like)
-	  {
-	     Start_Alt_Chars_Str = "\016";
-	     End_Alt_Chars_Str = "\017";
-	     Enable_Alt_Char_Set = "\033)0";
-	  }
-     }
-
-    /* aixterm added by willi */
-   if (is_xterm || !strncmp (term, "aixterm", 7))
-     {
-#if 0
-	Start_Alt_Chars_Str = "\016";
-	End_Alt_Chars_Str = "\017";
-	Enable_Alt_Char_Set = "\033(B\033)0";
-#else
-	Start_Alt_Chars_Str = "\033(0";
-	End_Alt_Chars_Str = "\033(B";
-	Enable_Alt_Char_Set = "";
-#endif
-     }
-
-   if ((SLtt_Graphics_Char_Pairs == NULL) &&
-       ((Start_Alt_Chars_Str == NULL) || (End_Alt_Chars_Str == NULL)))
-     {
-	SLtt_Has_Alt_Charset = 0;
-	Enable_Alt_Char_Set = NULL;
-     }
-   else SLtt_Has_Alt_Charset = 1;
-
-#ifdef AMIGA
-   Enable_Alt_Char_Set = Start_Alt_Chars_Str = End_Alt_Chars_Str = NULL;
-#endif
-
-   /* status line capabilities */
-   if ((SLtt_Has_Status_Line == -1)
-       && (0 != (SLtt_Has_Status_Line = TGETFLAG ("hs"))))
-     {
-	Disable_Status_line_Str = SLtt_tgetstr ("ds");
-	Return_From_Status_Line_Str = SLtt_tgetstr ("fs");
-	Goto_Status_Line_Str = SLtt_tgetstr ("ts");
-	/* Status_Line_Esc_Ok = TGETFLAG("es"); */
-	Num_Status_Line_Columns = SLtt_tgetnum ("ws");
-	if (Num_Status_Line_Columns < 0) Num_Status_Line_Columns = 0;
-     }
-
-   if (NULL == (Norm_Vid_Str = SLtt_tgetstr("me")))
-     {
-	Norm_Vid_Str = SLtt_tgetstr("se");
-     }
-
-   Cursor_Invisible_Str = SLtt_tgetstr("vi");
-   Cursor_Visible_Str = SLtt_tgetstr("ve");
-
-   Curs_F_Str = SLtt_tgetstr("RI");
-
-# if 0
-   if (NULL != Curs_F_Str)
-     {
-	Len_Curs_F_Str = strlen(Curs_F_Str);
-     }
-   else Len_Curs_F_Str = strlen(Curs_Pos_Str);
-# endif
-
-   Automatic_Margins = TGETFLAG ("am");
-   /* No_Move_In_Standout = !TGETFLAG ("ms"); */
-# ifdef HP_GLITCH_CODE
-   Has_HP_Glitch = TGETFLAG ("xs");
-# else
-   Worthless_Highlight = TGETFLAG ("xs");
-# endif
-
-   if (Worthless_Highlight == 0)
-     {				       /* Magic cookie glitch */
-	Worthless_Highlight = (SLtt_tgetnum ("sg") > 0);
-     }
-
-   if (Worthless_Highlight)
-     SLtt_Has_Alt_Charset = 0;
-
-   Reset_Color_String = SLtt_tgetstr ("op");
-   
-   /* Apparantly the difference between "AF" and "Sf" is that AF uses RGB, 
-    * but Sf uses BGR.
-    */
-   Color_Fg_Str = SLtt_tgetstr ("AF"); /* ANSI setaf */
-   if (Color_Fg_Str == NULL)
-     {
-	Color_Fg_Str = SLtt_tgetstr ("Sf");   /* setf */
-	/* Is_Fg_BGR = (Color_Fg_Str != NULL); */
-     }
-   Color_Bg_Str = SLtt_tgetstr ("AB"); /* ANSI setbf */
-   if (Color_Bg_Str == NULL)
-     {
-	Color_Bg_Str = SLtt_tgetstr ("Sb");   /* setb */
-	/* Is_Fg_BGR = (Color_Bg_Str != NULL); */
-     }
-
-   if ((Max_Terminfo_Colors = SLtt_tgetnum ("Co")) < 0)
-     Max_Terminfo_Colors = 8;
-
-   if ((Color_Bg_Str != NULL) && (Color_Fg_Str != NULL))
-     SLtt_Use_Ansi_Colors = 1;
-   else
-     {
-#if 0
-	Color_Fg_Str = "%?%p1%{7}%>%t\033[1;3%p1%{8}%m%dm%e\033[3%p1%dm%;";
-	Color_Bg_Str = "%?%p1%{7}%>%t\033[5;4%p1%{8}%m%dm%e\033[4%p1%dm%;";
-	Max_Terminfo_Colors = 16;
-#else
-	Color_Fg_Str = "\033[3%dm";
-	Color_Bg_Str = "\033[4%dm";
-	Max_Terminfo_Colors = 8;
-#endif
-     }
-
-#if SLTT_HAS_NON_BCE_SUPPORT
-   Can_Background_Color_Erase = TGETFLAG ("ut");   /* bce */
-   /* Modern xterms have the BCE capability as well as the linux console */
-   if (Can_Background_Color_Erase == 0)
-     {
-	Can_Background_Color_Erase = (Linux_Console
-# if SLTT_XTERM_ALWAYS_BCE
-				      || is_xterm
-# endif
-				      );
-     }
-#endif
-   get_color_info ();
-
-  
-   if ((Cls_Str == NULL)
-       || (Curs_Pos_Str == NULL))
-     return -2;
-
-   return 0;
-}
-
-#endif
-/* Unix */
-
-/* specific to vtxxx only */
-void SLtt_enable_cursor_keys (void)
-{
-#ifdef __unix__
-   if (Vt100_Like)
-#endif
-     tt_write_string("\033=\033[?1l");
-}
-
-#ifdef VMS
-int SLtt_initialize (char *term)
-{
-   SLtt_get_terminfo ();
-   return 0;
-}
-
-void SLtt_get_terminfo ()
-{
-   int zero = 0;
-
-   /* Apparantly, this cannot fail according to the man pages. */
-   if (SLang_TT_Write_FD == -1)
-     SLang_TT_Write_FD = fileno (stdout);
-   
-   Can_Background_Color_Erase = 0;
-
-   Color_Fg_Str = "\033[3%dm";
-   Color_Bg_Str = "\033[4%dm";
-   Max_Terminfo_Colors = 8;
-
-   get_color_info ();
-
-   SLtt_set_term_vtxxx(&zero);
-   Start_Alt_Chars_Str = "\016";
-   End_Alt_Chars_Str = "\017";
-   SLtt_Has_Alt_Charset = 1;
-   SLtt_Graphics_Char_Pairs = "aaffgghhjjkkllmmnnooqqssttuuvvwwxx";
-   Enable_Alt_Char_Set = "\033(B\033)0";
-   SLtt_get_screen_size ();
-}
-#endif
-
-/* This sets term for vt102 terminals it parameter vt100 is 0.  If vt100
- * is non-zero, set terminal appropriate for a only vt100
- * (no add line capability). */
-
-void SLtt_set_term_vtxxx(int *vt100)
-{
-   Norm_Vid_Str = "\033[m";
-
-   Scroll_R_Str = "\033[%i%d;%dr";
-   Cls_Str = "\033[2J\033[H";
-   Rev_Vid_Str = "\033[7m";
-   Bold_Vid_Str = "\033[1m";
-   Blink_Vid_Str = "\033[5m";
-   UnderLine_Vid_Str = "\033[4m";
-   Del_Eol_Str = "\033[K";
-   Del_Bol_Str = "\033[1K";
-   Rev_Scroll_Str = "\033M";
-   Curs_F_Str = "\033[%dC";
-   /* Len_Curs_F_Str = 5; */
-   Curs_Pos_Str = "\033[%i%d;%dH";
-   if ((vt100 == NULL) || (*vt100 == 0))
-     {
-	Ins_Mode_Str = "\033[4h";
-	Eins_Mode_Str = "\033[4l";
-	Del_Char_Str =  "\033[P";
-	Del_N_Lines_Str = "\033[%dM";
-	Add_N_Lines_Str = "\033[%dL";
-	SLtt_Term_Cannot_Insert = 0;
-     }
-   else
-     {
-	Del_N_Lines_Str = NULL;
-	Add_N_Lines_Str = NULL;
-	SLtt_Term_Cannot_Insert = 1;
-     }
-   SLtt_Term_Cannot_Scroll = 0;
-   /* No_Move_In_Standout = 0; */
-}
-
-int SLtt_init_video (void)
-{
-   /*   send_string_to_term("\033[?6h"); */
-   /* relative origin mode */
-   tt_write_string (Term_Init_Str);
-   tt_write_string (Keypad_Init_Str);
-   SLtt_reset_scroll_region();
-   SLtt_end_insert();
-   tt_write_string (Enable_Alt_Char_Set);
-   Video_Initialized = 1;
-   return 0;
-}
-
-int SLtt_reset_video (void)
-{
-   SLtt_goto_rc (SLtt_Screen_Rows - 1, 0);
-   Cursor_Set = 0;
-   SLtt_normal_video ();	       /* MSKermit requires this  */
-   tt_write_string(Norm_Vid_Str);
-
-   Current_Fgbg = 0xFFFFFFFFU;
-   SLtt_set_alt_char_set (0);
-   if (SLtt_Use_Ansi_Colors)
-     {
-	if (Reset_Color_String == NULL)
-	  {
-	     SLtt_Char_Type attr;
-	     if (-1 != make_color_fgbg (NULL, NULL, &attr))
-	       write_attributes (attr);
-	     else tt_write_string ("\033[0m\033[m");
-	  }
-	else tt_write_string (Reset_Color_String);
-	Current_Fgbg = 0xFFFFFFFFU;
-     }
-   SLtt_erase_line ();
-   tt_write_string (Keypad_Reset_Str);
-   tt_write_string (Term_Reset_Str);
-
-   if (Mouse_Mode == 1)
-     SLtt_set_mouse_mode (0, 1);
-
-   SLtt_flush_output ();
-   Video_Initialized = 0;
-   return 0;
-}
-
-void SLtt_bold_video (void)
-{
-   tt_write_string (Bold_Vid_Str);
-}
-
-int SLtt_set_mouse_mode (int mode, int force)
-{
-   char *term;
-
-   if (force == 0)
-     {
-	if (NULL == (term = (char *) getenv("TERM"))) return -1;
-	if (strncmp ("xterm", term, 5))
-	  return -1;
-     }
-
-   Mouse_Mode = (mode != 0);
-
-   if (mode)
-     tt_write_string ("\033[?9h");
-   else
-     tt_write_string ("\033[?9l");
-
-   return 0;
-}
-
-void SLtt_disable_status_line (void)
-{
-   if (SLtt_Has_Status_Line > 0)
-     {
-	tt_write_string (Disable_Status_line_Str);
-	SLtt_flush_output ();
-     }
-}
-
-int SLtt_write_to_status_line (char *s, int col)
-{
-   if ((SLtt_Has_Status_Line <= 0)
-       || (Goto_Status_Line_Str == NULL)
-       || (Return_From_Status_Line_Str == NULL))
-     return -1;
-
-   tt_printf (Goto_Status_Line_Str, col, 0);
-   tt_write_string (s);
-   tt_write_string (Return_From_Status_Line_Str);
-   return 0;
-}
-
-void SLtt_get_screen_size (void)
-{
-#ifdef VMS
-   int status, code;
-   unsigned short chan;
-   $DESCRIPTOR(dev_dsc, "SYS$INPUT:");
-#endif
-   int r = 0, c = 0;
-
-#ifdef TIOCGWINSZ
-   struct winsize wind_struct;
-
-   do
-     {
-	if ((ioctl(1,TIOCGWINSZ,&wind_struct) == 0)
-	    || (ioctl(0, TIOCGWINSZ, &wind_struct) == 0)
-	    || (ioctl(2, TIOCGWINSZ, &wind_struct) == 0))
-	  {
-	     c = (int) wind_struct.ws_col;
-	     r = (int) wind_struct.ws_row;
-	     break;
-	  }
-     }
-   while (errno == EINTR);
-
-#endif
-
-#ifdef VMS
-   status = sys$assign(&dev_dsc,&chan,0,0,0);
-   if (status & 1)
-     {
-	code = DVI$_DEVBUFSIZ;
-	status = lib$getdvi(&code, &chan,0, &c, 0,0);
-	if (!(status & 1))
-	  c = 80;
-	code = DVI$_TT_PAGE;
-	status = lib$getdvi(&code, &chan,0, &r, 0,0);
-	if (!(status & 1))
-	  r = 24;
-	sys$dassgn(chan);
-     }
-#endif
-
-   if (r <= 0)
-     {
-	char *s = getenv ("LINES");
-	if (s != NULL) r = atoi (s);
-     }
-
-   if (c <= 0)
-     {
-	char *s = getenv ("COLUMNS");
-	if (s != NULL) c = atoi (s);
-     }
-
-   if ((r <= 0) || (r > SLTT_MAX_SCREEN_ROWS)) r = 24;
-   if ((c <= 0) || (c > SLTT_MAX_SCREEN_COLS)) c = 80;
-   SLtt_Screen_Rows = r;
-   SLtt_Screen_Cols = c;
-}
-
-#if SLTT_HAS_NON_BCE_SUPPORT
-int _pSLtt_get_bce_color_offset (void)
-{
-   if ((SLtt_Use_Ansi_Colors == 0)
-       || Can_Background_Color_Erase
-       || SLtt_Use_Blink_For_ACS)      /* in this case, we cannot lose a color */
-     Bce_Color_Offset = 0;
-   else
-     {
-	SLtt_Char_Type fgbg = get_brush_fgbg (0);
-	if (GET_BG(fgbg) == SLSMG_COLOR_DEFAULT)
-	  Bce_Color_Offset = 0;
-	else
-	  Bce_Color_Offset = 1;
-     }
-   
-   return Bce_Color_Offset;
-}
-#endif
-
-int SLtt_utf8_enable (int mode)
-{
-   if (mode == -1)
-     mode = _pSLutf8_mode;
-
-   return _pSLtt_UTF8_Mode = mode;
-}
-
-int SLtt_is_utf8_mode (void)
-{
-   int mode = _pSLtt_UTF8_Mode;
-   if (mode == -1)
-     mode = _pSLutf8_mode;
-
-   return mode;
-}
diff --git a/slang/slerr.c b/slang/slerr.c
deleted file mode 100644
index c1ea2f0..0000000
--- a/slang/slerr.c
+++ /dev/null
@@ -1,766 +0,0 @@
-/* error handling common to all routines. */
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-#include "slinclud.h"
-
-#include "slang.h"
-#include "_slang.h"
-
-void (*_pSLinterpreter_Error_Hook) (int);
-
-void (*SLang_VMessage_Hook) (char *, va_list);
-void (*SLang_Error_Hook)(char *);
-void (*SLang_Exit_Error_Hook)(char *, va_list);
-void (*SLang_Dump_Routine)(char *);
-
-volatile int _pSLang_Error = 0;
-volatile int SLKeyBoard_Quit = 0;
-
-typedef struct _Exception_Type Exception_Type;
-struct _Exception_Type
-{
-   int error_code;
-   char *name;
-   char *description;
-   Exception_Type *subclasses;
-   Exception_Type *next;
-   Exception_Type *parent;
-};
-
-static Exception_Type *Exception_Root;
-static Exception_Type Exception_Root_Buf = 
-{
-   -1, "AnyError", "All Errors", NULL, NULL, NULL
-};
-
-
-/* Built-in error codes */
-/* These values should correspond to the values produced by _pSLerr_init.
- * Some apps may not use the interpreter, and as such _pSLerr_init will not
- * get called.
- */
-int SL_Any_Error = -1;
-int SL_Unknown_Error = 6;
-int SL_Internal_Error = 5;
-int SL_OS_Error = 1;
-int   SL_Malloc_Error = 2;
-int   SL_Import_Error = 7;
-int SL_RunTime_Error = 3;
-int   SL_InvalidParm_Error = 4;
-int   SL_TypeMismatch_Error = 8;
-int   SL_UserBreak_Error = 9;
-int   SL_Stack_Error = 10;
-int     SL_StackOverflow_Error = 12;
-int     SL_StackUnderflow_Error = 11;
-int   SL_ReadOnly_Error = 13;
-int   SL_VariableUninitialized_Error = 14;
-int   SL_NumArgs_Error = 15;
-int   SL_Index_Error = 16;
-int   SL_Usage_Error = 17;
-int   SL_Application_Error = 18;
-int   SL_NotImplemented_Error = 19;
-int   SL_LimitExceeded_Error = 20;
-int   SL_Forbidden_Error = 21;
-int   SL_Math_Error = 22;
-int     SL_DivideByZero_Error = 23;
-int     SL_ArithOverflow_Error = 24;
-int     SL_ArithUnderflow_Error = 25;
-int     SL_Domain_Error = 26;
-int   SL_IO_Error = 27;
-int     SL_Write_Error = 28;
-int     SL_Read_Error = 29;
-int     SL_Open_Error = 30;
-int   SL_Data_Error = 31;
-int   SL_Unicode_Error = 32;
-int     SL_InvalidUTF8_Error = 33;
-int   SL_Namespace_Error = 34;
-int SL_Parse_Error = 35;
-int   SL_Syntax_Error = 36;
-int   SL_DuplicateDefinition_Error = 37;
-int   SL_UndefinedName_Error = 38;
-
-typedef struct
-{
-   int *errcode_ptr;
-   char *name;
-   char *description;
-   int *base_class_ptr;
-}
-BuiltIn_Exception_Table_Type;
-
-static SLCONST BuiltIn_Exception_Table_Type BuiltIn_Exception_Table[] =
-{
-   /* Define MallocError and InvalidParmError ASAP */
-     {&SL_OS_Error, "OSError", "OS Error", &SL_Any_Error},
-       {&SL_Malloc_Error, "MallocError", "Not enough memory", &SL_OS_Error},
-
-     {&SL_RunTime_Error, "RunTimeError", "Run-Time Error", &SL_Any_Error},
-       {&SL_InvalidParm_Error, "InvalidParmError", "Invalid Parameter", &SL_RunTime_Error},
-
-     {&SL_Internal_Error, "InternalError", "Internal Error", &SL_Any_Error},
-     {&SL_Unknown_Error, "UnknownError", "Unknown Error", &SL_Any_Error},
-
-   /* Rest of OSErrors */
-       {&SL_Import_Error, "ImportError", "Import Error", &SL_OS_Error},
-
-   /* Rest of RunTimeErrors */
-       {&SL_TypeMismatch_Error, "TypeMismatchError", "Type Mismatch", &SL_RunTime_Error},
-       {&SL_UserBreak_Error, "UserBreakError", "User Break", &SL_RunTime_Error},
-       {&SL_Stack_Error, "StackError", "Stack Error", &SL_RunTime_Error},
-         {&SL_StackUnderflow_Error, "StackUnderflowError", "Stack Underflow Error", &SL_Stack_Error},
-         {&SL_StackOverflow_Error, "StackOverflowError", "Stack Overflow Error", &SL_Stack_Error},
-       {&SL_ReadOnly_Error, "ReadOnlyError", "Read-Only Error", &SL_RunTime_Error},
-       {&SL_VariableUninitialized_Error, "VariableUninitializedError", "Variable Uninitialized Error", &SL_RunTime_Error},
-       {&SL_NumArgs_Error, "NumArgsError", "Invalid Number of Arguments", &SL_RunTime_Error},
-       {&SL_Index_Error, "IndexError", "Invalid Index", &SL_RunTime_Error},
-       {&SL_Usage_Error, "UsageError", "Illegal Usage", &SL_RunTime_Error},
-       {&SL_Application_Error, "ApplicationError", "Application Error", &SL_RunTime_Error},
-       {&SL_NotImplemented_Error, "NotImplementedError", "Not Implemented", &SL_RunTime_Error},
-       {&SL_LimitExceeded_Error, "LimitExceededError", "Limit Exceeded", &SL_RunTime_Error},
-       {&SL_Forbidden_Error, "ForbiddenError", "Operation Forbidden", &SL_RunTime_Error},
-       {&SL_Math_Error, "MathError", "Math Error", &SL_RunTime_Error},
-         {&SL_DivideByZero_Error, "DivideByZeroError", "Divide by Zero", &SL_Math_Error},
-         {&SL_ArithOverflow_Error, "ArithOverflowError", "Arithmetic Overflow", &SL_Math_Error},
-         {&SL_ArithUnderflow_Error, "ArithUnderflowError", "Arithmetic Underflow", &SL_Math_Error},
-         {&SL_Domain_Error, "DomainError", "Domain Error", &SL_Math_Error},
-       {&SL_IO_Error, "IOError", "I/O Error", &SL_RunTime_Error},
-         {&SL_Write_Error, "WriteError", "Write failed", &SL_IO_Error},
-         {&SL_Read_Error, "ReadError", "Read failed", &SL_IO_Error},
-         {&SL_Open_Error, "OpenError", "Open failed", &SL_IO_Error},
-       {&SL_Data_Error, "DataError", "Data Error", &SL_RunTime_Error},
-       {&SL_Unicode_Error, "UnicodeError", "Unicode Error", &SL_RunTime_Error},
-         {&SL_InvalidUTF8_Error, "UTF8Error", "Invalid UTF8", &SL_Unicode_Error},
-       {&SL_Namespace_Error, "NamespaceError", "Namespace Error", &SL_RunTime_Error},
-
-   /* Parse Errors */
-       {&SL_Parse_Error, "ParseError", "Parse Error", &SL_Any_Error},
-         {&SL_Syntax_Error, "SyntaxError", "Syntax Error", &SL_Parse_Error},
-         {&SL_DuplicateDefinition_Error, "DuplicateDefinitionError", "Duplicate Definition", &SL_Parse_Error},
-         {&SL_UndefinedName_Error, "UndefinedNameError", "Undefined Name", &SL_Parse_Error},
-   {NULL, NULL, NULL, NULL}
-};
-
-static Exception_Type *find_exception (Exception_Type *root, int error_code)
-{
-   Exception_Type *e;
-
-   while (root != NULL)
-     {
-	if (error_code == root->error_code)
-	  return root;
-
-	if (root->subclasses != NULL)
-	  {
-	     e = find_exception (root->subclasses, error_code);
-	     if (e != NULL)
-	       return e;
-	  }
-	root = root->next;
-     }
-
-   return root;
-}
-
-static int is_exception_ancestor (int a, int b)
-{
-   Exception_Type *e;
-
-   if (a == b)
-     return 1;
-
-   if (NULL == (e = find_exception (Exception_Root, a)))
-     return 0;
-   
-   while (e->parent != NULL)
-     {
-	e = e->parent;
-	if (e->error_code == b)
-	  return 1;
-     }
-   return 0;
-}
-
-int SLerr_exception_eqs (int a, int b)
-{
-   if (is_exception_ancestor (a, b))
-     return 1;
-   
-   return 0;
-}
-
-static void free_this_exception (Exception_Type *e)
-{
-   if (e == NULL)
-     return;
-   
-   if (e->name != NULL)
-     SLang_free_slstring (e->name);
-
-   if (e->description != NULL)
-     SLang_free_slstring (e->description);
-
-   SLfree ((char *)e);
-}
-
-	
-static int Next_Exception_Code;
-/* The whole point of this nonsense involving the _pSLerr_New_Exception_Hook
- * is to provide a mechanism to avoid linking in the interpreter for apps
- * that just want the other facilities.
- */
-int (*_pSLerr_New_Exception_Hook)(char *name, char *desc, int error_code);
-
-int _pSLerr_init_interp_exceptions (void)
-{
-   SLCONST BuiltIn_Exception_Table_Type *b;
-   Exception_Type *e;
-
-   if (_pSLerr_New_Exception_Hook == NULL)
-     return 0;
-   
-   e = &Exception_Root_Buf;
-   if (-1 == (*_pSLerr_New_Exception_Hook)(e->name, e->description, e->error_code))
-     return -1;
-
-   b = BuiltIn_Exception_Table;
-   while (b->errcode_ptr != NULL)
-     {
-	if (-1 == (*_pSLerr_New_Exception_Hook)(b->name, b->description, *b->errcode_ptr))
-	  return -1;
-	
-	b++;
-     }
-   return 0;
-}
-
-int SLerr_new_exception (int baseclass, char *name, char *descript)
-{
-   Exception_Type *base;
-   Exception_Type *e;
-
-   if (-1 == _pSLerr_init ())
-     return -1;
-
-   base = find_exception (Exception_Root, baseclass);
-   if (base == NULL)
-     {
-	SLang_verror (SL_InvalidParm_Error,
-		      "Base class for new exception not found");
-	return -1;
-     }
-   
-   e = (Exception_Type *) SLcalloc (1, sizeof (Exception_Type));
-   if (e == NULL)
-     return -1;
-   
-   if ((NULL == (e->name = SLang_create_slstring (name)))
-       || (NULL == (e->description = SLang_create_slstring (descript))))
-     {
-	free_this_exception (e);
-	return -1;
-     }
-   
-   e->error_code = Next_Exception_Code;
-
-   if ((_pSLerr_New_Exception_Hook != NULL)
-       && (-1 == (*_pSLerr_New_Exception_Hook) (e->name, e->description, e->error_code)))
-     {
-	free_this_exception (e);
-	return -1;
-     }
-
-   e->parent = base;
-   e->next = base->subclasses;
-   base->subclasses = e;
-
-   Next_Exception_Code++;
-   return e->error_code;
-}
-
-
-static int init_exceptions (void)
-{
-   SLCONST BuiltIn_Exception_Table_Type *b;
-
-   if (Exception_Root != NULL)
-     return 0;
-
-   Exception_Root = &Exception_Root_Buf;
-   Next_Exception_Code = 1;
-   b = BuiltIn_Exception_Table;
-   while (b->errcode_ptr != NULL)
-     {
-	int err_code;
-	
-	err_code = SLerr_new_exception (*b->base_class_ptr, b->name, b->description);
-	if (err_code == -1)
-	  return -1;
-
-	*b->errcode_ptr = err_code;
-	b++;
-     }
-   
-   return 0;
-}
-
-static void free_exceptions (Exception_Type *root)
-{
-   while (root != NULL)
-     {
-	Exception_Type *next;
-
-	if (root->subclasses != NULL)
-	  free_exceptions (root->subclasses);
-	
-	next = root->next;
-	free_this_exception (root);
-	root = next;
-     }
-}
-
-	
-static void deinit_exceptions (void)
-{
-   Exception_Type *root = Exception_Root;
-   
-   if (root != NULL)
-     free_exceptions (root->subclasses);
-   
-   Exception_Root = NULL;
-   Next_Exception_Code = 0;
-}
-
-char *SLerr_strerror (int err_code)
-{
-   Exception_Type *e;
-
-   if (err_code == 0)
-     err_code = _pSLang_Error;
-
-   if (-1 == _pSLerr_init ())
-     return "Unable to initialize SLerr module";
-
-   if (NULL == (e = find_exception (Exception_Root, err_code)))
-     return "Invalid/Unknown Error Code";
-   
-   return e->description;
-}
-
-/* Error Queue Functions
- *   SLang_verror (int errcode, fmt, args)
- *     Add an error message to the queue.
- *   SLerr_delete_queue ()
- *     Removes messages from the error queue
- *   SLerr_print_queue ()
- *     Prints all messages from the queue, deletes the queue
- */
-typedef struct _Error_Message_Type
-{
-   char *msg;			       /* SLstring, may be NULL */
-   int msg_type;
-#define _SLERR_MSG_ERROR	1
-#define _SLERR_MSG_WARNING	2
-#define _SLERR_MSG_TRACEBACK	4
-   struct _Error_Message_Type *next;
-}
-Error_Message_Type;
-
-typedef struct
-{
-   Error_Message_Type *head;
-   Error_Message_Type *tail;
-}
-Error_Queue_Type;
-
-static Error_Queue_Type *Default_Error_Queue;
-
-static void free_error_msg (Error_Message_Type *m)
-{
-   if (m == NULL)
-     return;
-   if (m->msg != NULL)
-     SLang_free_slstring (m->msg);
-   SLfree ((char *)m);
-}
-       
-static Error_Message_Type *allocate_error_msg (char *msg, int msg_type)
-{
-   Error_Message_Type *m;
-
-   if (NULL == (m = (Error_Message_Type*) SLcalloc (1, sizeof (Error_Message_Type))))
-     return NULL;
-   
-   if ((NULL != msg) && (NULL == (m->msg = SLang_create_slstring (msg))))
-     {
-	free_error_msg (m);
-	return NULL;
-     }
-   m->msg_type = msg_type;
-   return m;
-}
-
-static void free_queued_messages (Error_Queue_Type *q)
-{
-   Error_Message_Type *m;
-
-   if (q == NULL)
-     return;
-
-   m = q->head;
-   while (m != NULL)
-     {
-	Error_Message_Type *m1 = m->next;
-	free_error_msg (m);
-	m = m1;
-     }
-   q->head = NULL;
-   q->tail = NULL;
-}
-
-static void delete_msg_queue (Error_Queue_Type *q)
-{
-   if (q == NULL)
-     return;
-   
-   free_queued_messages (q);
-   SLfree ((char *)q);
-}
-
-   
-static Error_Queue_Type *create_msg_queue (void)
-{
-   Error_Queue_Type *q;
-
-   if (NULL == (q = (Error_Queue_Type *)SLcalloc (1, sizeof(Error_Queue_Type))))
-     return NULL;
-   
-   return q;
-}
-
-static int queue_message (Error_Queue_Type *q, char *msg, int msg_type)
-{
-   Error_Message_Type *m;
-   
-   if (NULL == (m = allocate_error_msg (msg, msg_type)))
-     return -1;
-   
-   if (q->tail != NULL)
-     q->tail->next = m;
-   if (q->head == NULL)
-     q->head = m;
-   q->tail = m;
-   
-   return 0;
-}
-
-static void print_error (int msg_type, char *err)
-{
-   unsigned int len;
-
-   switch (msg_type)
-     {
-      case _SLERR_MSG_ERROR:
-	if (SLang_Error_Hook != NULL)
-	  {
-	     (*SLang_Error_Hook)(err);
-	     return;
-	  }
-	break;
-      case _SLERR_MSG_TRACEBACK:
-      case _SLERR_MSG_WARNING:
-	if (SLang_Dump_Routine != NULL)
-	  {
-	     (*SLang_Dump_Routine)(err);
-	     return;
-	  }
-	break;
-     }
-   
-   len = strlen (err);
-   if (len == 0)
-     return;
-
-   fputs (err, stderr);
-   if ((err[len-1] != '\n')
-       && (msg_type != _SLERR_MSG_TRACEBACK))
-     fputs("\n", stderr);
-
-   fflush (stderr);
-}
-
-static void print_queue (void)
-{
-   if (-1 == _pSLerr_init ())
-     print_error (_SLERR_MSG_ERROR, "Unable to initialize SLerr module");
-   
-   if (_pSLang_Error == 0)
-     return;
-
-   if (Default_Error_Queue != NULL)
-     {
-	Error_Queue_Type *q = Default_Error_Queue;
-	Error_Message_Type *m = q->head;
-	while (m != NULL)
-	  {
-	     Error_Message_Type *m_next = m->next;
-	     if (m->msg != NULL)
-	       print_error (m->msg_type, m->msg);
-	     m = m_next;
-	  }
-	
-	free_queued_messages (q);
-     }
-#if 0
-   if (_pSLang_Error != SL_Usage_Error)
-     {
-	print_error (_SLERR_MSG_ERROR, SLerr_strerror (_pSLang_Error));
-     }
-#endif
-}
-
-/* This function returns a pointer to the first error message in the queue.
- * Make no attempts to free the returned pointer.
- */
-char *_pSLerr_get_error_from_queue (void)
-{
-   Error_Queue_Type *q;
-   Error_Message_Type *m;
-   unsigned int len;
-   char *err, *err1, *err_max;
-
-   if (NULL == (q = Default_Error_Queue))
-     return NULL;
-
-   len = 0;
-   m = q->head;
-   while (m != NULL)
-     {
-	if (m->msg_type == _SLERR_MSG_ERROR)
-	  len += 1 + strlen (m->msg);
-
-	m = m->next;
-     }
-   
-   if (len) 
-     len--;			       /* last \n not needed */
-
-   if (NULL == (err = _pSLallocate_slstring (len)))
-     return NULL;
-   
-   err_max = err + len;
-   err1 = err;
-   m = q->head;
-   while (m != NULL)
-     {
-	if (m->msg_type == _SLERR_MSG_ERROR)
-	  {
-	     unsigned int dlen = strlen (m->msg);
-	     strcpy (err1, m->msg);
-	     err1 += dlen;
-	     if (err1 != err_max)
-	       *err1++ = '\n';
-	  }
-	m = m->next;
-     }
-   *err1 = 0;
-   
-   return _pSLcreate_via_alloced_slstring (err, len);
-}
-
-void _pSLerr_print_message_queue (void)
-{
-   print_queue ();
-}
-
-
-static volatile int Suspend_Error_Messages = 0;
-int _pSLerr_resume_messages (void)
-{
-   if (Suspend_Error_Messages == 0)
-     return 0;
-   
-   Suspend_Error_Messages--;
-   if (Suspend_Error_Messages == 0)
-     print_queue ();
-   return 0;
-}
-
-int _pSLerr_suspend_messages (void)
-{
-   Suspend_Error_Messages++;
-   return 0;
-}
-
-void _pSLerr_free_queued_messages (void)
-{
-   free_queued_messages (Default_Error_Queue);
-}
-
-
-void SLang_verror (int err_code, char *fmt, ...)
-{
-   va_list ap;
-   char err [4096];
-
-   if (-1 == _pSLerr_init ())
-     {
-	print_queue ();
-	return;
-     }
-
-   if (err_code == 0) 
-     err_code = SL_INTRINSIC_ERROR;
-
-   if (_pSLang_Error == 0)
-     SLang_set_error (err_code);
-
-   if (fmt == NULL)
-     return;
-
-   va_start(ap, fmt);
-   (void) SLvsnprintf (err, sizeof (err), fmt, ap);
-   va_end(ap);
-
-   if (Suspend_Error_Messages)
-     (void) queue_message (Default_Error_Queue, err, _SLERR_MSG_ERROR);
-   else
-     print_error (_SLERR_MSG_ERROR, err);
-}
-
-int _pSLerr_traceback_msg (char *fmt, ...)
-{
-   va_list ap;
-   char msg [4096];
-
-   va_start(ap, fmt);
-   (void) SLvsnprintf (msg, sizeof (msg), fmt, ap);
-   va_end(ap);
-
-   return queue_message (Default_Error_Queue, msg, _SLERR_MSG_TRACEBACK);
-}
-
-void SLang_exit_error (char *fmt, ...)
-{
-   va_list ap;
-
-   print_queue ();
-   va_start (ap, fmt);
-   if (SLang_Exit_Error_Hook != NULL)
-     {
-	(*SLang_Exit_Error_Hook) (fmt, ap);
-	exit (1);
-     }
-
-   if (fmt != NULL)
-     {
-	vfprintf (stderr, fmt, ap);
-	fputs ("\n", stderr);
-	fflush (stderr);
-     }
-   va_end (ap);
-
-   exit (1);
-}
-
-int SLang_set_error (int error)
-{
-   /* Only allow an error to be cleared (error==0), but not changed
-    * if there already is an error.
-    */
-   if ((error == 0)
-       || (_pSLang_Error == 0))
-     _pSLang_Error = error;
-
-   if (_pSLinterpreter_Error_Hook != NULL)
-     (*_pSLinterpreter_Error_Hook) (_pSLang_Error);
-   
-   return 0;
-}
-
-int SLang_get_error (void)
-{
-   return _pSLang_Error;
-}
-
-void SLang_vmessage (char *fmt, ...)
-{
-   va_list ap;
-
-   if (fmt == NULL)
-     return;
-
-   va_start (ap, fmt);
-
-   if (SLang_VMessage_Hook != NULL)
-     (*SLang_VMessage_Hook) (fmt, ap);
-   else
-     {
-	vfprintf (stdout, fmt, ap);
-	fputs ("\n", stdout);
-     }
-
-   va_end (ap);
-}
-
-/* This routine does not queue messages.  It is used for tracing, etc. */
-void _pSLerr_dump_msg (char *fmt, ...)
-{
-   char buf[1024];
-   va_list ap;
-
-   va_start (ap, fmt);
-   if (SLang_Dump_Routine != NULL)
-     {
-	(void) SLvsnprintf (buf, sizeof (buf), fmt, ap);
-	(*SLang_Dump_Routine) (buf);
-     }
-   else
-     {
-	vfprintf (stderr, fmt, ap);
-	fflush (stderr);
-     }
-   va_end (ap);
-}
-
-int _pSLerr_init (void)
-{
-   if (Default_Error_Queue == NULL)
-     {
-	Suspend_Error_Messages = 0;
-	if (NULL == (Default_Error_Queue = create_msg_queue ()))
-	  return -1;
-     }
-
-   if (-1 == init_exceptions ())
-     return -1;
-   
-   return 0;
-}
-
-void _pSLerr_deinit (void)
-{
-   deinit_exceptions ();
-   delete_msg_queue (Default_Error_Queue);
-   Suspend_Error_Messages = 0;
-   Default_Error_Queue = NULL;
-}
-
diff --git a/slang/slgetkey.c b/slang/slgetkey.c
deleted file mode 100644
index 48ae3e1..0000000
--- a/slang/slgetkey.c
+++ /dev/null
@@ -1,320 +0,0 @@
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-#include "slinclud.h"
-
-#include "slang.h"
-#include "_slang.h"
-
-unsigned int SLang_Input_Buffer_Len = 0;
-unsigned char SLang_Input_Buffer [SL_MAX_INPUT_BUFFER_LEN];
-
-int SLang_Abort_Char = 7;
-int SLang_Ignore_User_Abort = 0;
-
-/* This has the effect of mapping all characters in the range 128-169 to
- * ESC [ something
- */
-
-unsigned int SLang_getkey (void)
-{
-   unsigned int imax;
-   unsigned int ch;
-
-   if (SLang_Input_Buffer_Len)
-     {
-	ch = (unsigned int) *SLang_Input_Buffer;
-	SLang_Input_Buffer_Len--;
-	imax = SLang_Input_Buffer_Len;
-
-	SLMEMCPY ((char *) SLang_Input_Buffer,
-		(char *) (SLang_Input_Buffer + 1), imax);
-     }
-   else if (SLANG_GETKEY_ERROR == (ch = _pSLsys_getkey ())) return ch;
-
-#if SLANG_MAP_VTXXX_8BIT
-# if !defined(IBMPC_SYSTEM)
-   if (ch & 0x80)
-     {
-	unsigned char i;
-	i = (unsigned char) (ch & 0x7F);
-	if (i < ' ')
-	  {
-	     i += 64;
-	     SLang_ungetkey (i);
-	     ch = 27;
-	  }
-     }
-# endif
-#endif
-   return(ch);
-}
-
-int SLang_ungetkey_string (unsigned char *s, unsigned int n)
-{
-   register unsigned char *bmax, *b, *b1;
-   if (SLang_Input_Buffer_Len + n + 3 > SL_MAX_INPUT_BUFFER_LEN)
-     return -1;
-
-   b = SLang_Input_Buffer;
-   bmax = (b - 1) + SLang_Input_Buffer_Len;
-   b1 = bmax + n;
-   while (bmax >= b) *b1-- = *bmax--;
-   bmax = b + n;
-   while (b < bmax) *b++ = *s++;
-   SLang_Input_Buffer_Len += n;
-   return 0;
-}
-
-int SLang_buffer_keystring (unsigned char *s, unsigned int n)
-{
-
-   if (n + SLang_Input_Buffer_Len + 3 > SL_MAX_INPUT_BUFFER_LEN) return -1;
-
-   SLMEMCPY ((char *) SLang_Input_Buffer + SLang_Input_Buffer_Len,
-	   (char *) s, n);
-   SLang_Input_Buffer_Len += n;
-   return 0;
-}
-
-int SLang_ungetkey (unsigned char ch)
-{
-   return SLang_ungetkey_string(&ch, 1);
-}
-
-int SLang_input_pending (int tsecs)
-{
-   int n;
-   unsigned char c;
-   if (SLang_Input_Buffer_Len) return (int) SLang_Input_Buffer_Len;
-
-   n = _pSLsys_input_pending (tsecs);
-
-   if (n <= 0) return 0;
-
-   c = (unsigned char) SLang_getkey ();
-   SLang_ungetkey_string (&c, 1);
-
-   return n;
-}
-
-void SLang_flush_input (void)
-{
-   int quit = SLKeyBoard_Quit;
-
-   SLang_Input_Buffer_Len = 0;
-   SLKeyBoard_Quit = 0;
-   while (_pSLsys_input_pending (0) > 0)
-     {
-	(void) _pSLsys_getkey ();
-	/* Set this to 0 because _pSLsys_getkey may stuff keyboard buffer if
-	 * key sends key sequence (OS/2, DOS, maybe VMS).
-	 */
-	SLang_Input_Buffer_Len = 0;
-     }
-   SLKeyBoard_Quit = quit;
-}
-
-#ifdef IBMPC_SYSTEM
-static int Map_To_ANSI;
-int SLgetkey_map_to_ansi (int enable)
-{
-   Map_To_ANSI = enable;
-   return 0;
-}
-
-static int convert_scancode (unsigned int scan, 
-			     unsigned int shift,
-			     int getkey,
-			     unsigned int *ret_key)
-{
-   unsigned char buf[16];
-   unsigned char *b;
-   unsigned char end;
-   int is_arrow;
-
-   shift &= (_pSLTT_KEY_ALT|_pSLTT_KEY_SHIFT|_pSLTT_KEY_CTRL);
-
-   b = buf;
-   if (_pSLTT_KEY_ALT == shift)
-     {
-	shift = 0;
-	*b++ = 27;
-     }
-   *b++ = 27;
-   *b++ = '[';
-
-   is_arrow = 0;
-   end = '~';
-   if (shift)
-     {
-	if (shift == _pSLTT_KEY_CTRL)
-	  end = '^';
-	else if (shift == _pSLTT_KEY_SHIFT)
-	  end = '$';
-	else shift = 0;
-     }
-
-   /* These mappings correspond to what rxvt produces under Linux */
-   switch (scan & 0xFF)
-     {
-      default:
-	return -1;
-
-      case 0x47:		       /* home */
-	*b++ = '1';
-	break;
-      case 0x48:		       /* up */
-	end = 'A';
-	is_arrow = 1;
-	break;
-      case 0x49:		       /* PgUp */
-	*b++ = '5';
-	break;
-      case 0x4B:		       /* Left */
-	end = 'D';
-	is_arrow = 1;
-	break;
-      case 0x4D:		       /* Right */
-	end = 'C';
-	is_arrow = 1;
-	break;
-      case 0x4F:		       /* End */
-	*b++ = '4';
-	break;
-      case 0x50:		       /* Down */
-	end = 'B';
-	is_arrow = 1;
-	break;
-      case 0x51:		       /* PgDn */
-	*b++ = '6';
-	break;
-      case 0x52:		       /* Insert */
-	*b++ = '2';
-	break;
-      case 0x53:		       /* Delete */
-	*b++ = '3';
-	break;
-      case ';':			       /* F1 */
-	*b++ = '1';
-	*b++ = '1';
-	break;
-      case '<':			       /* F2 */
-	*b++ = '1';
-	*b++ = '2';
-	break;
-      case '=':			       /* F3 */
-	*b++ = '1';
-	*b++ = '3';
-	break;
-
-      case '>':			       /* F4 */
-	*b++ = '1';
-	*b++ = '4';
-	break;
-
-      case '?':			       /* F5 */
-	*b++ = '1';
-	*b++ = '5';
-	break;
-
-      case '@':			       /* F6 */
-	*b++ = '1';
-	*b++ = '7';
-	break;
-
-      case 'A':			       /* F7 */
-	*b++ = '1';
-	*b++ = '8';
-	break;
-
-      case 'B':			       /* F8 */
-	*b++ = '1';
-	*b++ = '9';
-	break;
-
-      case 'C':			       /* F9 */
-	*b++ = '2';
-	*b++ = '0';
-	break;
-
-      case 'D':			       /* F10 */
-	*b++ = '2';
-	*b++ = '1';
-	break;
-
-      case 0x57:		       /* F11 */
-	*b++ = '2';
-	*b++ = '3';
-	break;
-
-      case 0x58:		       /* F12 */
-	*b++ = '2';
-	*b++ = '4';
-	break;
-     }
-
-   if (is_arrow && shift)
-     {
-	if (shift == _pSLTT_KEY_CTRL)
-	  end &= 0x1F;
-	else
-	  end |= 0x20;
-     }
-   *b++ = end;
-   
-   if (getkey)
-     {
-	(void) SLang_buffer_keystring (buf + 1, (unsigned int) (b - (buf + 1)));
-	*ret_key = buf[0];
-	return 0;
-     }
-
-   (void) SLang_buffer_keystring (buf, (unsigned int) (b - buf));
-   return 0;
-}
-
-   
-unsigned int _pSLpc_convert_scancode (unsigned int scan,
-				     unsigned int shift,
-				     int getkey)
-{
-   unsigned char buf[16];
-
-   if (Map_To_ANSI)
-     {
-	if (0 == convert_scancode (scan, shift, getkey, &scan))
-	  return scan;
-     }
-   
-   if (getkey)
-     {
-	buf[0] = scan & 0xFF;
-	SLang_buffer_keystring (buf, 1);
-	return (scan >> 8) & 0xFF;
-     }
-   buf[0] = (scan >> 8) & 0xFF;
-   buf[1] = scan & 0xFF;
-   (void) SLang_buffer_keystring (buf, 2);
-   return 0;
-}
-
-#endif
diff --git a/slang/sllower.c b/slang/sllower.c
deleted file mode 100644
index 8f7107f..0000000
--- a/slang/sllower.c
+++ /dev/null
@@ -1,17 +0,0 @@
-#include "slinclud.h"
-#include <ctype.h>
-
-#include "slang.h"
-#include "_slang.h"
-
-#define DEFINE_PSLWC_TOLOWER_TABLE
-#include "sllower.h"
-
-#define MODE_VARIABLE _pSLinterp_UTF8_Mode
-SLwchar_Type SLwchar_tolower (SLwchar_Type ch)
-{
-   if (MODE_VARIABLE)
-     return ch + SL_TOLOWER_LOOKUP(ch);
-   
-   return tolower(ch);
-}
diff --git a/slang/slmisc.c b/slang/slmisc.c
deleted file mode 100644
index 6eeff09..0000000
--- a/slang/slmisc.c
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-Trimmed down for use in GNU Midnight Commander.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-#define _GNU_SOURCE
-#include "slinclud.h"
-
-#include <ctype.h>
-
-#include "slang.h"
-#include "_slang.h"
-
-
-char *SLmake_string(char *str)
-{
-   return SLmake_nstring(str, strlen (str));
-}
-
-char *SLmake_nstring (char *str, unsigned int n)
-{
-   char *ptr;
-
-   if (NULL == (ptr = SLmalloc(n + 1)))
-     {
-	return NULL;
-     }
-   SLMEMCPY (ptr, str, n);
-   ptr[n] = 0;
-   return(ptr);
-}
-
-/*
- * This function assumes that the initial \ char has been removed.
- */
-char *_pSLexpand_escaped_char(char *p, SLwchar_Type *ch, int *isunicodep)
-{
-   int i = 0;
-   SLwchar_Type max = 0;
-   SLwchar_Type num, base = 0;
-   SLwchar_Type ch1;
-   int isunicode;
-   int needs_brace;
-
-   ch1 = *p++;
-   isunicode = 0;
-   needs_brace = 0;
-
-   switch (ch1)
-     {
-      default: num = ch1; break;
-      case 'n': num = '\n'; break;
-      case 't': num = '\t'; break;
-      case 'v': num = '\v'; break;
-      case 'b': num = '\b'; break;
-      case 'r': num = '\r'; break;
-      case 'f': num = '\f'; break;
-      case 'E': case 'e': num = 27; break;
-      case 'a': num = 7;
-	break;
-
-	/* octal */
-      case '0': case '1': case '2': case '3':
-      case '4': case '5': case '6': case '7':
-	max = '7';
-	base = 8; i = 2; num = ch1 - '0';
-	break;
-
-      case 'd':			       /* decimal -- S-Lang extension */
-	base = 10;
-	i = 3;
-	max = '9';
-	num = 0;
-	break;
-
-      case 'u':
-	isunicode = 1;
-	/* drop */
-      case 'x':			       /* hex */
-	base = 16;
-	max = '9';
-	i = 2;
-	num = 0;
-	
-	if (*p == '{')
-	  {
-	     p++;
-	     i = 0;
-	     while (p[i] && (p[i] != '}'))
-	       i++;
-	     if (p[i] != '}')
-	       {
-		  SLang_verror (SL_SYNTAX_ERROR, "Escaped character missing closing }.");
-		  return NULL;
-	       }
-	     /* The meaning of \x{...} is mode dependent.  If in UTF-8 mode, then
-	      * \x{...} always generates a unicode character.  Otherwise, the
-	      * meaning of \x{...} depends upon the number of characters enclosed
-	      * by the brace.  If there are less than 3, then assume no unicode.
-	      * If greater than or equal to 3, then assume unicode.
-	      */
-	     if (isunicode == 0)       /* \x... */
-	       isunicode = _pSLinterp_UTF8_Mode || (i > 2);
-	     needs_brace = 1;
-	  }
-	break;
-     }
-
-   while (i)
-     {
-	ch1 = *p;
-
-	i--;
-
-	if ((ch1 <= max) && (ch1 >= '0'))
-	  {
-	     num = base * num + (ch1 - '0');
-	  }
-	else if (base == 16)
-	  {
-	     ch1 |= 0x20;
-	     if ((ch1 < 'a') || ((ch1 > 'f'))) break;
-	     num = base * num + 10 + (ch1 - 'a');
-	  }
-	else break;
-	p++;
-     }
-
-   if (needs_brace)
-     {
-	if (*p != '}')
-	  {
-	     SLang_verror (SL_SYNTAX_ERROR, "Malformed escaped character.");
-	     return NULL;
-	  }
-	p++;
-     }
-
-   if (isunicodep != NULL)
-     *isunicodep = isunicode;
-
-   *ch = num;
-   return p;
-}
diff --git a/slang/slsignal.c b/slang/slsignal.c
deleted file mode 100644
index 276d6bb..0000000
--- a/slang/slsignal.c
+++ /dev/null
@@ -1,351 +0,0 @@
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-#include "slinclud.h"
-
-#include <signal.h>
-
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#ifdef HAVE_SYS_WAIT_H
-# include <sys/wait.h>
-#endif
-
-#include <errno.h>
-
-#include "slang.h"
-#include "_slang.h"
-
-/* Do not trust these environments */
-#if defined(__MINGW32__) || defined(AMIGA)
-# ifdef SLANG_POSIX_SIGNALS
-#  undef SLANG_POSIX_SIGNALS
-# endif
-#endif
-
-/* This function will cause system calls to be restarted after signal if possible */
-SLSig_Fun_Type *SLsignal (int sig, SLSig_Fun_Type *f)
-{
-#if defined(SLANG_POSIX_SIGNALS)
-   struct sigaction old_sa, new_sa;
-
-# ifdef SIGALRM
-   /* We want system calls to be interrupted by SIGALRM. */
-   if (sig == SIGALRM) return SLsignal_intr (sig, f);
-# endif
-
-   sigemptyset (&new_sa.sa_mask);
-   new_sa.sa_handler = f;
-
-   new_sa.sa_flags = 0;
-# ifdef SA_RESTART
-   new_sa.sa_flags |= SA_RESTART;
-# endif
-
-   if (-1 == sigaction (sig, &new_sa, &old_sa))
-     return (SLSig_Fun_Type *) SIG_ERR;
-
-   return old_sa.sa_handler;
-#else
-   /* Not POSIX. */
-   return signal (sig, f);
-#endif
-}
-
-/* This function will NOT cause system calls to be restarted after
- * signal if possible
- */
-SLSig_Fun_Type *SLsignal_intr (int sig, SLSig_Fun_Type *f)
-{
-#ifdef SLANG_POSIX_SIGNALS
-   struct sigaction old_sa, new_sa;
-
-   sigemptyset (&new_sa.sa_mask);
-   new_sa.sa_handler = f;
-
-   new_sa.sa_flags = 0;
-# ifdef SA_INTERRUPT
-   new_sa.sa_flags |= SA_INTERRUPT;
-# endif
-
-   if (-1 == sigaction (sig, &new_sa, &old_sa))
-     return (SLSig_Fun_Type *) SIG_ERR;
-
-   return old_sa.sa_handler;
-#else
-   /* Not POSIX. */
-   return signal (sig, f);
-#endif
-}
-
-/* We are primarily interested in blocking signals that would cause the
- * application to reset the tty.  These include suspend signals and
- * possibly interrupt signals.
- */
-#ifdef SLANG_POSIX_SIGNALS
-static sigset_t Old_Signal_Mask;
-#endif
-
-static volatile unsigned int Blocked_Depth;
-
-int SLsig_block_signals (void)
-{
-#ifdef SLANG_POSIX_SIGNALS
-   sigset_t new_mask;
-#endif
-
-   Blocked_Depth++;
-   if (Blocked_Depth != 1)
-     {
-	return 0;
-     }
-
-#ifdef SLANG_POSIX_SIGNALS
-   sigemptyset (&new_mask);
-# ifdef SIGQUIT
-   sigaddset (&new_mask, SIGQUIT);
-# endif
-# ifdef SIGTSTP
-   sigaddset (&new_mask, SIGTSTP);
-# endif
-# ifdef SIGINT
-   sigaddset (&new_mask, SIGINT);
-# endif
-# ifdef SIGTTIN
-   sigaddset (&new_mask, SIGTTIN);
-# endif
-# ifdef SIGTTOU
-   sigaddset (&new_mask, SIGTTOU);
-# endif
-# ifdef SIGWINCH
-   sigaddset (&new_mask, SIGWINCH);
-# endif
-
-   (void) sigprocmask (SIG_BLOCK, &new_mask, &Old_Signal_Mask);
-   return 0;
-#else
-   /* Not implemented. */
-   return -1;
-#endif
-}
-
-int SLsig_unblock_signals (void)
-{
-   if (Blocked_Depth == 0)
-     return -1;
-
-   Blocked_Depth--;
-
-   if (Blocked_Depth != 0)
-     return 0;
-
-#ifdef SLANG_POSIX_SIGNALS
-   (void) sigprocmask (SIG_SETMASK, &Old_Signal_Mask, NULL);
-   return 0;
-#else
-   return -1;
-#endif
-}
-
-#ifdef MSWINDOWS
-int SLsystem (char *cmd)
-{
-   SLang_verror (SL_NOT_IMPLEMENTED, "system not implemented");
-   return -1;
-}
-
-#else
-int SLsystem (char *cmd)
-{
-#ifdef SLANG_POSIX_SIGNALS
-   pid_t pid;
-   int status;
-   struct sigaction ignore;
-# ifdef SIGINT
-   struct sigaction save_intr;
-# endif
-# ifdef SIGQUIT
-   struct sigaction save_quit;
-# endif
-# ifdef SIGCHLD
-   sigset_t child_mask, save_mask;
-# endif
-
-   if (cmd == NULL) return 1;
-
-   ignore.sa_handler = SIG_IGN;
-   sigemptyset (&ignore.sa_mask);
-   ignore.sa_flags = 0;
-
-# ifdef SIGINT
-   if (-1 == sigaction (SIGINT, &ignore, &save_intr))
-     return -1;
-# endif
-
-# ifdef SIGQUIT
-   if (-1 == sigaction (SIGQUIT, &ignore, &save_quit))
-     {
-	(void) sigaction (SIGINT, &save_intr, NULL);
-	return -1;
-     }
-# endif
-
-# ifdef SIGCHLD
-   sigemptyset (&child_mask);
-   sigaddset (&child_mask, SIGCHLD);
-   if (-1 == sigprocmask (SIG_BLOCK, &child_mask, &save_mask))
-     {
-#  ifdef SIGINT
-	(void) sigaction (SIGINT, &save_intr, NULL);
-#  endif
-#  ifdef SIGQUIT
-	(void) sigaction (SIGQUIT, &save_quit, NULL);
-#  endif
-	return -1;
-     }
-# endif
-
-   pid = fork();
-
-   if (pid == -1)
-     status = -1;
-   else if (pid == 0)
-     {
-	/* Child */
-# ifdef SIGINT
-	(void) sigaction (SIGINT, &save_intr, NULL);
-# endif
-# ifdef SIGQUIT
-	(void) sigaction (SIGQUIT, &save_quit, NULL);
-# endif
-# ifdef SIGCHLD
-	(void) sigprocmask (SIG_SETMASK, &save_mask, NULL);
-# endif
-
-	execl ("/bin/sh", "sh", "-c", cmd, NULL);
-	_exit (127);
-     }
-   else
-     {
-	/* parent */
-	while (-1 == waitpid (pid, &status, 0))
-	  {
-# ifdef EINTR
-	     if (errno == EINTR)
-	       continue;
-# endif
-# ifdef ERESTARTSYS
-	     if (errno == ERESTARTSYS)
-	       continue;
-# endif
-	     status = -1;
-	     break;
-	  }
-     }
-# ifdef SIGINT
-   if (-1 == sigaction (SIGINT, &save_intr, NULL))
-     status = -1;
-# endif
-# ifdef SIGQUIT
-   if (-1 == sigaction (SIGQUIT, &save_quit, NULL))
-     status = -1;
-# endif
-# ifdef SIGCHLD
-   if (-1 == sigprocmask (SIG_SETMASK, &save_mask, NULL))
-     status = -1;
-# endif
-
-   return status;
-
-#else				       /* No POSIX Signals */
-# ifdef SIGINT
-   void (*sint)(int);
-# endif
-# ifdef SIGQUIT
-   void (*squit)(int);
-# endif
-   int status;
-
-# ifdef SIGQUIT
-   squit = SLsignal (SIGQUIT, SIG_IGN);
-# endif
-# ifdef SIGINT
-   sint = SLsignal (SIGINT, SIG_IGN);
-# endif
-   status = system (cmd);
-# ifdef SIGINT
-   SLsignal (SIGINT, sint);
-# endif
-# ifdef SIGQUIT
-   SLsignal (SIGQUIT, squit);
-# endif
-   return status;
-#endif				       /* POSIX_SIGNALS */
-}
-#endif
-
-#if 0
-#include <windows.h>
-static int msw_system (char *cmd)
-{
-   STARTUPINFO startup_info;
-   PROCESS_INFORMATION process_info;
-   int status;
-
-   if (cmd == NULL) return -1;
-
-   memset ((char *) &startup_info, 0, sizeof (STARTUPINFO));
-   startup_info.cb = sizeof(STARTUPINFO);
-   startup_info.dwFlags = STARTF_USESHOWWINDOW;
-   startup_info.wShowWindow = SW_SHOWDEFAULT;
-
-   if (FALSE == CreateProcess (NULL,
-			       cmd,
-			       NULL,
-			       NULL,
-			       FALSE,
-			       NORMAL_PRIORITY_CLASS|CREATE_NEW_CONSOLE,
-			       NULL,
-			       NULL,
-			       &startup_info,
-			       &process_info))
-     {
-	SLang_verror (0, "%s: CreateProcess failed.", cmd);
-	return -1;
-     }
-
-   status = -1;
-
-   if (0xFFFFFFFFUL != WaitForSingleObject (process_info.hProcess, INFINITE))
-     {
-	DWORD exit_code;
-
-	if (TRUE == GetExitCodeProcess (process_info.hProcess, &exit_code))
-	  status = (int) exit_code;
-     }
-
-   CloseHandle (process_info.hThread);
-   CloseHandle (process_info.hProcess);
-
-   return status;
-}
-#endif
diff --git a/slang/slsmg.c b/slang/slsmg.c
deleted file mode 100644
index b8f38e2..0000000
--- a/slang/slsmg.c
+++ /dev/null
@@ -1,2165 +0,0 @@
-/* SLang Screen management routines */
-#include "slinclud.h"
-
-#include <stdio.h>
-#include <string.h>
-#include "slang.h"
-#include "_slang.h"
-
-typedef struct
-  {
-     int n;                    /* number of chars written last time */
-     int flags;                /* line untouched, etc... */
-     SLsmg_Char_Type *old, *neew;
-#ifndef IBMPC_SYSTEM
-     unsigned long old_hash, new_hash;
-#endif
-  }
-Screen_Type;
-
-#define TOUCHED 0x1
-#define TRASHED 0x2
-static int Screen_Trashed;
-
-static Screen_Type SL_Screen[SLTT_MAX_SCREEN_ROWS];
-static int Start_Col, Start_Row;
-static unsigned int Screen_Cols, Screen_Rows;
-static int This_Row, This_Col;
-static SLsmg_Color_Type This_Color;
-
-static int UTF8_Mode = -1;
-
-#if SLTT_HAS_NON_BCE_SUPPORT && !defined(IBMPC_SYSTEM)
-#define REQUIRES_NON_BCE_SUPPORT 1
-static int Bce_Color_Offset;
-#endif
-
-int SLsmg_Newline_Behavior = SLSMG_NEWLINE_IGNORED;
-int SLsmg_Backspace_Moves = 0;
-
-#if SLSMG_HAS_EMBEDDED_ESCAPE
-/* If non-zero, interpret escape sequences ESC [ x m as an embedded set color
- * sequence.  The 'x' is a decimal integer that specifies the color.  The sequence
- * ends at m.  Examples:  \e[3m --> set color 3.  \e[272m --> color=272.
- * Note: These escape sequences are NOT ANSI, though similar.  ANSI permits
- * sequences such as \e[32;44m to set the foreground to green/blue.  This interface
- * will support such sequences, _but_ in will map such squences to the sum of 
- * the colors: \e[32;44m --> color (32+44)=76.
- * 
- * In addition to 'm', ']' is also supported.
- */
-static int Embedded_Escape_Mode = 0;
-int SLsmg_embedded_escape_mode (int mode)
-{
-   int old_mode = Embedded_Escape_Mode;
-   Embedded_Escape_Mode = mode;
-   return old_mode;
-}
-
-/* This function gets called with u pointing at what may be '['.  If it sucessfully
- * parses the escape sequence, *up and the color will be updated.
- */
-static int parse_embedded_escape (SLuchar_Type *u, SLuchar_Type *umax, 
-				  SLsmg_Color_Type default_color, 
-				  SLuchar_Type **up, SLsmg_Color_Type *colorp)
-{
-   unsigned int val;
-   SLuchar_Type ch;
-
-   if ((u < umax) && (*u != '['))
-     return -1;
-
-   u++;
-   if ((u < umax) && ((*u == 'm') || (*u == ']')))
-     {
-	*colorp = default_color;       /* ESC[m */
-	*up = u+1;
-	return 0;
-     }
-
-   val = 0;
-   while ((u < umax)
-	  && (((ch = *u) >= '0') && (ch <= '9')))
-     {
-	val = 10*val + (ch - '0');
-	u++;
-     }
-   if ((u < umax) && ((*u == 'm') || (*u == ']')) && (val <= SLSMG_MAX_COLORS))
-     {
-# ifdef REQUIRES_NON_BCE_SUPPORT
-	val += Bce_Color_Offset;
-#endif
-	*colorp = (SLsmg_Color_Type) val;
-	*up = u + 1;
-	return 0;
-     }
-   return -1;
-}
-
-static void parse_embedded_set_color (SLuchar_Type *u, SLuchar_Type *umax,
-				      SLsmg_Color_Type default_color)
-{
-   SLsmg_Color_Type color = default_color;
-
-   while (u < umax)
-     {
-	if (*u++ == 033)
-	  (void) parse_embedded_escape (u, umax, default_color, &u, &color);
-     }
-   if (color == default_color)
-     return;
-   
-#ifdef REQUIRES_NON_BCE_SUPPORT
-   color -= Bce_Color_Offset;
-#endif
-   SLsmg_set_color (color);
-}
-#endif
-
-/* Backward compatibility. Not used. */
-/* int SLsmg_Newline_Moves; */
-static int *tt_Screen_Rows = NULL;
-static int *tt_Screen_Cols = NULL;
-static int *tt_unicode_ok;
-   
-static void (*tt_normal_video)(void);
-static void (*tt_goto_rc)(int, int);
-static void (*tt_cls) (void);
-static void (*tt_del_eol) (void);
-static void (*tt_smart_puts) (SLsmg_Char_Type *, SLsmg_Char_Type *, int, int);
-static int (*tt_flush_output) (void);
-static int (*tt_reset_video) (void);
-static int (*tt_init_video) (void);
-
-#ifndef IBMPC_SYSTEM
-static void (*tt_set_scroll_region)(int, int);
-static void (*tt_reverse_index)(int);
-static void (*tt_reset_scroll_region)(void);
-static void (*tt_delete_nlines)(int);
-#endif
-
-#ifndef IBMPC_SYSTEM
-static int *tt_Term_Cannot_Scroll;
-static int *tt_Has_Alt_Charset;
-static char **tt_Graphics_Char_Pairs;
-#else
-static int *tt_Has_Alt_Charset = NULL;
-static char **tt_Graphics_Char_Pairs = NULL;
-#endif
-
-static int Smg_Inited;
-
-/* This is necessary because the windoze run-time linker cannot perform 
- * relocations on its own.
- */
-static void init_tt_symbols (void)
-{
-   tt_Screen_Rows = &SLtt_Screen_Rows;
-   tt_Screen_Cols = &SLtt_Screen_Cols;
-   tt_unicode_ok = &_pSLtt_UTF8_Mode;
-   
-   tt_normal_video = SLtt_normal_video;
-   tt_goto_rc = SLtt_goto_rc;
-   tt_cls = SLtt_cls;
-   tt_del_eol = SLtt_del_eol;
-   tt_smart_puts = SLtt_smart_puts;
-   tt_flush_output = SLtt_flush_output;
-   tt_reset_video = SLtt_reset_video;
-   tt_init_video = SLtt_init_video;
-
-#ifndef IBMPC_SYSTEM
-   tt_set_scroll_region = SLtt_set_scroll_region;
-   tt_reverse_index = SLtt_reverse_index;
-   tt_reset_scroll_region = SLtt_reset_scroll_region;
-   tt_delete_nlines = SLtt_delete_nlines;
-#endif
-
-#ifndef IBMPC_SYSTEM
-   tt_Term_Cannot_Scroll = &SLtt_Term_Cannot_Scroll;
-   tt_Has_Alt_Charset = &SLtt_Has_Alt_Charset;
-   tt_Graphics_Char_Pairs = &SLtt_Graphics_Char_Pairs;
-#else
-   tt_Has_Alt_Charset = NULL;
-   tt_Graphics_Char_Pairs = NULL;
-#endif
-}
-
-/* Unicode box drawing characters */
-
-/* This lookup table is indexed by the vt100 characters */
-static SLwchar_Type ACS_Map[128];
-
-typedef struct
-{
-   unsigned char vt100_char;
-   unsigned char ascii;
-   SLwchar_Type unicode;
-}
-ACS_Def_Type;
-
-static SLCONST ACS_Def_Type UTF8_ACS_Map[] =
-{
-   {'+', '>', 0x2192 }, /* RIGHTWARDS ARROW */
-   {',', '<', 0x2190 }, /* LEFTWARDS ARROW */
-   {'-', '^', 0x2191 }, /* UPWARDS ARROW */
-   {'.', 'v', 0x2193 }, /* DOWNWARDS ARROW */
-   {'0', '#', 0x25AE }, /* BLACK VERTICAL RECTANGLE */
-   {'`', '+', 0x25C6 }, /* BLACK DIAMOND */
-   {'a', ':', 0x2592 }, /* MEDIUM SHADE */
-   {'f', '\'', 0x00B0 },/* DEGREE SIGN */
-   {'g', '#', 0x00B1 }, /* PLUS-MINUS SIGN */
-   {'h', '#', 0x2592 }, /* MEDIUM SHADE */
-   {'i', '#', 0x2603 }, /* SNOWMAN */
-   {'j', '+', 0x2518 }, /* BOX DRAWINGS LIGHT UP AND LEFT */
-   {'k', '+', 0x2510 }, /* BOX DRAWINGS LIGHT DOWN AND LEFT */
-   {'l', '+', 0x250c }, /* BOX DRAWINGS LIGHT DOWN AND RIGHT */
-   {'m', '+', 0x2514 }, /* BOX DRAWINGS LIGHT UP AND RIGHT */
-   {'n', '+', 0x253C }, /* BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
-   {'o', '~', 0x23BA }, /* HORIZONTAL SCAN LINE-1 */
-   {'p', '-', 0x23BB }, /* HORIZONTAL SCAN LINE-3 (ncurses addition) */
-   {'q', '-', 0x2500 }, /* BOX DRAWINGS LIGHT HORIZONTAL */
-   {'r', '-', 0x23BC }, /* HORIZONTAL SCAN LINE-7 (ncurses addition) */
-   {'s', '_', 0x23BD }, /* HORIZONTAL SCAN LINE-9 */
-   {'t', '+', 0x251C }, /* BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
-   {'u', '+', 0x2524 }, /* BOX DRAWINGS LIGHT VERTICAL AND LEFT */
-   {'v', '+', 0x2534 }, /* BOX DRAWINGS LIGHT UP AND HORIZONTAL */
-   {'w', '+', 0x252C }, /* BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
-   {'x', '|', 0x2502 }, /* BOX DRAWINGS LIGHT VERTICAL */
-   {'y', '<', 0x2264 }, /* LESS-THAN OR EQUAL TO (ncurses addition) */
-   {'z', '>', 0x2265 }, /* GREATER-THAN OR EQUAL TO (ncurses addition) */
-   {'{', '*', 0x03C0 }, /* GREEK SMALL LETTER PI (ncurses addition) */
-   {'|', '!', 0x2260 }, /* NOT EQUAL TO (ncurses addition) */
-   {'}', 'f', 0x00A3 }, /* POUND SIGN (ncurses addition) */
-   {'~', 'o', 0x00B7 }, /* MIDDLE DOT */
-   {0, 0, 0}
-};
-
-#define ACS_MODE_NONE	       -1
-#define ACS_MODE_AUTO		0
-#define ACS_MODE_UNICODE	1
-#define ACS_MODE_TERMINFO	2
-#define ACS_MODE_ASCII		3
-
-static int Current_ACS_Mode = ACS_MODE_NONE;
-static void init_acs (int mode)
-{
-   unsigned int i;
-   SLCONST ACS_Def_Type *acs;
-
-   if (Current_ACS_Mode == mode)
-     return;
-
-   for (i = 0; i < 0x80; i++)
-     ACS_Map[i] = ' ';
-
-   if (mode == ACS_MODE_AUTO)
-     {
-	if (UTF8_Mode && 
-	    (tt_unicode_ok != NULL) && (*tt_unicode_ok > 0))
-	  mode = ACS_MODE_UNICODE;
-	else
-	  mode = ACS_MODE_TERMINFO;
-     }
-
-   switch (mode)
-     {
-      case ACS_MODE_UNICODE:
-	SLsmg_Display_Eight_Bit = 0xA0;
-	acs = UTF8_ACS_Map;
-	while (acs->vt100_char != 0)
-	  {
-	     ACS_Map[acs->vt100_char] = acs->unicode;
-	     acs++;
-	  }
-	break;
-	
-      case ACS_MODE_TERMINFO:
-	if ((tt_Has_Alt_Charset != NULL)
-	    && *tt_Has_Alt_Charset
-	    && (tt_Graphics_Char_Pairs != NULL)
-	    && (*tt_Graphics_Char_Pairs != NULL))
-	  {
-	     unsigned char *p = (unsigned char *) *tt_Graphics_Char_Pairs;
-	     unsigned char *pmax = p + strlen ((char *) p);
-	     
-	     while (p < pmax)
-	       {
-		  unsigned char ch = *p++;
-		  ACS_Map[ch & 0x7F] = *p++;
-	       }
-	     break;
-	  }
-	mode = ACS_MODE_ASCII;
-	/* drop */
-      case ACS_MODE_ASCII:
-      default:
-	acs = UTF8_ACS_Map;
-	while (acs->vt100_char != 0)
-	  {
-	     ACS_Map[acs->vt100_char] = acs->ascii;
-	     acs++;
-	  }
-	break;
-     }
-
-   Current_ACS_Mode = mode;
-}
-
-static void blank_line (SLsmg_Char_Type *c, unsigned int n, SLwchar_Type wch)
-{
-   SLsmg_Char_Type *cmax = c + n;
-   SLsmg_Color_Type color = This_Color;
-
-   memset ((char *)c, 0, n*sizeof(SLsmg_Char_Type));
-   while (c < cmax)
-     {
-	c->nchars = 1;
-	c->wchars[0] = wch;
-	c->color = color;
-	c++;
-     }
-}
-
-static void clear_region (int row, int n, SLwchar_Type ch)
-{
-   int i;
-   int imax = row + n;
-
-   if (imax > (int) Screen_Rows) imax = (int) Screen_Rows;
-   if (row < 0)
-     row = 0;
-
-   for (i = row; i < imax; i++)
-     {						  
-	blank_line (SL_Screen[i].neew, Screen_Cols, ch);
-	SL_Screen[i].flags |= TOUCHED;
-     }
-}
-
-void SLsmg_erase_eol (void)
-{
-   int r, c;
-
-   if (Smg_Inited == 0) return;
-
-   c = This_Col - Start_Col;
-   r = This_Row - Start_Row;
-
-   if ((r < 0) || (r >= (int)Screen_Rows)) return;
-   if (c < 0) c = 0; else if (c >= (int)Screen_Cols) return;
-   blank_line (SL_Screen[This_Row].neew + c , Screen_Cols - c, 0x20);
-   SL_Screen[This_Row].flags |= TOUCHED;
-}
-
-static void scroll_up (void)
-{
-   unsigned int i, imax;
-   SLsmg_Char_Type *neew;
-
-   neew = SL_Screen[0].neew;
-   imax = Screen_Rows - 1;
-   for (i = 0; i < imax; i++)
-     {
-	SL_Screen[i].neew = SL_Screen[i + 1].neew;
-	SL_Screen[i].flags |= TOUCHED;
-     }
-   SL_Screen[i].neew = neew;
-   SL_Screen[i].flags |= TOUCHED;
-   blank_line (neew, Screen_Cols, 0x20);
-   This_Row--;
-}
-
-void SLsmg_gotorc (int r, int c)
-{
-   This_Row = r;
-   This_Col = c;
-}
-
-int SLsmg_get_row (void)
-{
-   return This_Row;
-}
-
-int SLsmg_get_column (void)
-{
-   return This_Col;
-}
-
-void SLsmg_erase_eos (void)
-{
-   if (Smg_Inited == 0) return;
-
-   SLsmg_erase_eol ();
-   clear_region (This_Row + 1, (int)Screen_Rows, 0x20);
-}
-
-static int This_Alt_Char;
-
-void SLsmg_set_char_set (int i)
-{
-#ifdef IBMPC_SYSTEM
-   (void) i;
-#else
-   if (i != 0)
-     This_Alt_Char = SLSMG_ACS_MASK;
-   else This_Alt_Char = 0;
-
-   This_Color &= SLSMG_COLOR_MASK;
-   This_Color |= This_Alt_Char;
-#endif
-}
-
-void SLsmg_set_color (SLsmg_Color_Type color)
-{
-#ifdef REQUIRES_NON_BCE_SUPPORT
-   color += Bce_Color_Offset;
-#endif
-   This_Color = color | This_Alt_Char;
-}
-
-void SLsmg_reverse_video (void)
-{
-   SLsmg_set_color (1);
-}
-
-void SLsmg_normal_video (void)
-{
-   SLsmg_set_color (0);
-}
-
-static int point_visible (int col_too)
-{
-   return ((This_Row >= Start_Row) && (This_Row < Start_Row + (int)Screen_Rows)
-	   && ((col_too == 0)
-	       || ((This_Col >= Start_Col)
-		   && (This_Col < Start_Col + (int)Screen_Cols))));
-}
-
-#define NEXT_CHAR_CELL \
-   { \
-      if (p < pmax) \
-	{ \
-	   if ((p->nchars != i) || (p->color != color)) flags |= TOUCHED; \
-	   p->nchars = i; \
-	   p->color = color; \
-	   p++; \
-	} \
-      i = 0; \
-      col++; \
-   } (void) 0
-
-
-#define ADD_TO_CHAR_CELL(wc) \
-   { \
-      if ((p < pmax) && (p->wchars[i] != wc)) \
-	{ \
-	   p->wchars[i] = wc; \
-	   flags |= TOUCHED; \
-	} \
-      i++; \
-   } (void) 0
-
-#define ADD_CHAR_OR_BREAK(ch) \
-   if (col >= start_col) \
-       { \
-	  if (i != 0) NEXT_CHAR_CELL; \
-	  if (last_was_double_width) \
-	    { \
-	       last_was_double_width = 0; \
-	       NEXT_CHAR_CELL; \
-	    } \
-	  if (col >= max_col) break; \
-	  ADD_TO_CHAR_CELL(ch); \
-       } \
-   else col++
-
-
-void SLsmg_write_chars (unsigned char *u, unsigned char *umax)
-{
-   SLsmg_Char_Type *p, *pmax;
-   SLsmg_Color_Type color;
-   int flags;
-   int col, start_col, max_col;
-   int newline_flag;
-   int utf8_mode = UTF8_Mode;
-   unsigned char display_8bit;
-   int last_was_double_width = 0;
-   int alt_char_set_flag;
-   unsigned int i;
-#if SLSMG_HAS_EMBEDDED_ESCAPE
-   SLsmg_Color_Type default_color;
-#endif
-   if (Smg_Inited == 0) return;
-   
-   display_8bit = (unsigned char) SLsmg_Display_Eight_Bit;
-   if (utf8_mode)
-     display_8bit = 0xA0;
-
-   color = This_Color;
-   /* If we are using unicode characters for the line drawing characters, then
-    * do not attempt to use the terminals alternate character set
-    */
-   alt_char_set_flag = (color & SLSMG_ACS_MASK);
-   if (Current_ACS_Mode == ACS_MODE_UNICODE)
-     color = color & ~SLSMG_ACS_MASK;
-   
-#if SLSMG_HAS_EMBEDDED_ESCAPE
-   default_color = color;	       /* used for ESC[m */
-#endif
-
-   top:				       /* get here only on newline */
-
-   newline_flag = 0;
-   start_col = Start_Col;
-
-   if (point_visible (0) == 0) return;
-
-   col = This_Col;
-   max_col = start_col + Screen_Cols;
-
-   p = SL_Screen[This_Row - Start_Row].neew;
-   pmax = p + Screen_Cols;
-
-   if (col >= start_col)
-     {
-	p += (col - start_col);
-	if ((p < pmax) && (p->nchars == 0))
-	  {
-	     /* It looks like we are about to overwrite the right side of a 
-	      * double width character.
-	      */
-	     if (col > start_col)
-	       {
-		  p--;
-		  p->nchars = 1;
-		  p->wchars[0] = ' ';
-		  p++;
-	       }
-	  }
-     }
-   
-   
-   flags = SL_Screen[This_Row - Start_Row].flags;
-   i = 0;
-   
-   while (u < umax)
-     {
-	SLwchar_Type wc;
-	unsigned int width, nconsumed;
-
-     	if (*u < (SLuchar_Type) 0x80)		       /* ASCII */
-	  {
-	     unsigned char ch;
-
-	     ch = (unsigned char) *u++;
-
-	     if (alt_char_set_flag)
-	       {
-		  wc = ACS_Map[ch];
-		  ADD_CHAR_OR_BREAK(wc);
-		  continue;
-	       }
-
-	     if ((ch >= (SLuchar_Type)0x20) && (ch < (SLuchar_Type)0x7F))
-	       {
-		  ADD_CHAR_OR_BREAK(ch);
-		  continue;
-	       }
-	     
-	     if ((ch == '\t') && (SLsmg_Tab_Width > 0))
-	       {
-		  do
-		    {
-		       if (col < start_col)
-			 col++;
-		       else
-			 {
-			    ADD_CHAR_OR_BREAK(' ');
-			    NEXT_CHAR_CELL;
-			 }
-		    }
-		  while (col % SLsmg_Tab_Width);
-		  continue;
-	       }
-	     
-	     if ((ch == '\n')
-		 && (SLsmg_Newline_Behavior != SLSMG_NEWLINE_PRINTABLE))
-	       {
-		  newline_flag = 1;
-		  break;
-	       }
-	     
-	     if ((ch == 0x8) && SLsmg_Backspace_Moves)
-	       {
-		  if (col != 0) 
-		    {
-		       if (i != 0) 
-			 {
-			    NEXT_CHAR_CELL;
-			    col--;
-			    p--;
-			 }
-		       col--;
-		       p--;
-		    }
-		  continue;
-	       }
-#if SLSMG_HAS_EMBEDDED_ESCAPE
-	     if ((ch == 033) && Embedded_Escape_Mode)
-	       {
-		  SLsmg_Color_Type next_color;
-
-		  if (0 == parse_embedded_escape (u, umax, default_color, &u, &next_color))
-		    {
-		       if (i != 0)
-			 NEXT_CHAR_CELL;
-		       color = next_color;
-		       continue;
-		    }
-	       }
-#endif
-	     ADD_CHAR_OR_BREAK('^');
-	     if (ch == 127) ch = '?'; else ch = ch + '@';
-	     ADD_CHAR_OR_BREAK (ch);
-	     continue;
-	  }
-
-	nconsumed = 1;
-	if ((utf8_mode == 0)
-	    || (NULL == SLutf8_decode (u, umax, &wc, &nconsumed)))
-	  {
-	     unsigned int ii, jj;
-	     unsigned char hexbuf[8];
-	     
-	     if ((utf8_mode == 0) 
-		 && display_8bit && (*u >= display_8bit))
-	       {
-		  ADD_CHAR_OR_BREAK(*u);
-	       }
-	     else for (ii = 0; ii < nconsumed; ii++)
-	       {
-		  sprintf ((char *)hexbuf, "<%02X>", u[ii]);
-		  for (jj = 0; jj < 4; jj++)
-		    {
-		       ADD_CHAR_OR_BREAK (hexbuf[jj]);
-		    }
-	       }
-	     u += nconsumed;
-	     continue;
-	  }
-
-	u += nconsumed;
-	if (wc < (SLwchar_Type)display_8bit)
-	  {
-	     unsigned char hexbuf[8];
-	     unsigned int jj;
-
-	     sprintf ((char *)hexbuf, "<%02X>", (unsigned char) wc);
-	     for (jj = 0; jj < 4; jj++)
-	       {
-		  ADD_CHAR_OR_BREAK (hexbuf[jj]);
-	       }
-	     continue;
-	  }
-
-	width = SLwchar_wcwidth (wc);
-	if (width == 0)
-	  {
-	     /* Combining character--- must follow non-zero width char */
-	     if (i == 0)
-	       continue;
-	     if (i < SLSMG_MAX_CHARS_PER_CELL)
-	       {
-		  ADD_TO_CHAR_CELL (wc);
-	       }
-	     continue;
-	  }
-
-	if (width == 2)
-	  {
-	     if (col + 2 <= start_col)
-	       {
-		  col += 2;
-		  continue;
-	       }
-
-	     if (col + 2 > max_col)
-	       {
-		  ADD_CHAR_OR_BREAK('>');
-		  break;
-	       }
-	     
-	     if (col == start_col - 1)
-	       {
-		  /* double width character is clipped at left part of screen.
-		   * So, display right edge as a space */
-		  col++;
-		  ADD_CHAR_OR_BREAK('<');
-		  continue;
-	       }
-
-	     ADD_CHAR_OR_BREAK(wc);
-	     last_was_double_width = 1;
-	     continue;
-	  }
-
-	ADD_CHAR_OR_BREAK(wc);
-     }
-   
-   if (i != 0)
-     {
-	NEXT_CHAR_CELL;
-     }
-
-   if (last_was_double_width)
-     {
-	if (col < max_col)
-	  NEXT_CHAR_CELL;
-	last_was_double_width = 0;
-     }
-   else if ((col < max_col) && (p->nchars == 0))
-     {
-	/* The left side of a double with character was overwritten */
-	p->nchars = 1;
-	p->wchars[0] = ' ';
-     }
-   SL_Screen[This_Row - Start_Row].flags = flags;
-   This_Col = col;
-
-   /* Why would u be NULL here?? */
-
-   if (SLsmg_Newline_Behavior == SLSMG_NEWLINE_IGNORED)
-     {
-#if SLSMG_HAS_EMBEDDED_ESCAPE
-	if (Embedded_Escape_Mode && (u != NULL))
-	  parse_embedded_set_color (u, umax, default_color);
-#endif
-	return;
-     }
-
-   if (newline_flag == 0)
-     {
-#if SLSMG_HAS_EMBEDDED_ESCAPE
-	SLuchar_Type *usave = u;
-#endif
-	if (u == NULL)
-	  return;
-
-	while (u < umax)
-	  {
-	     if (*u == '\n') break;
-	     u++;
-	  }
-	if (u >= umax)
-	  {
-#if SLSMG_HAS_EMBEDDED_ESCAPE
-	     if (Embedded_Escape_Mode)
-	       parse_embedded_set_color (usave, umax, default_color);
-#endif
-	     return;
-	  }
-	u++;
-     }
-
-   This_Row++;
-   This_Col = 0;
-   if (This_Row == Start_Row + (int)Screen_Rows)
-     {
-	if (SLsmg_Newline_Behavior == SLSMG_NEWLINE_SCROLLS) scroll_up ();
-     }
-   goto top;
-}
-
-
-void SLsmg_write_nchars (char *str, unsigned int len)
-{
-   SLsmg_write_chars ((unsigned char *) str, (unsigned char *)str + len);
-}
-
-void SLsmg_write_string (char *str)
-{
-   SLsmg_write_chars ((unsigned char *)str, 
-		      (unsigned char *)str + strlen (str));
-}
-
-void SLsmg_write_nstring (char *str, unsigned int n)
-{
-   unsigned int width;
-   unsigned char *blank = (unsigned char *)" ";
-   unsigned char *u = (unsigned char *)str;
-
-   /* Avoid a problem if a user accidently passes a negative value */
-   if ((int) n < 0)
-     return;
-
-   if (u == NULL) width = 0;
-   else
-     {
-	unsigned char *umax;
-	
-	width = strlen ((char *)u);
-	if (UTF8_Mode)
-	  umax = SLutf8_skip_chars (u, u+width, n, &width, 0);
-	else 
-	  {
-	     if (width > n) width = n;
-	     umax = u + width;
-	  }
-	SLsmg_write_chars (u, umax);
-     }
-
-   while (width++ < n) SLsmg_write_chars (blank, blank+1);
-}
-
-void SLsmg_write_wrapped_string (SLuchar_Type *u, int r, int c,
-				 unsigned int dr, unsigned int dc,
-				 int fill)
-{
-   int maxc = (int) dc;
-   unsigned char *p, *pmax;
-   int utf8_mode = UTF8_Mode;
-
-   if ((dr == 0) || (dc == 0)) return;
-   p = u;
-   pmax = u + strlen ((char *)u);
-   
-   dc = 0;
-   while (1)
-     {
-	unsigned char ch = *p;
-	if ((ch == 0) || (ch == '\n'))
-	  {
-	     int diff;
-
-	     diff = maxc - (int) dc;
-
-	     SLsmg_gotorc (r, c);
-	     SLsmg_write_chars (u, p);
-	     if (fill && (diff > 0))
-	       {
-		  unsigned char *blank = (unsigned char *)" ";
-		  while (diff--) SLsmg_write_chars (blank, blank+1);
-	       }
-	     if ((ch == 0) || (dr == 1)) break;
-
-	     r++;
-	     dc = 0;
-	     dr--;
-	     p++;
-	     u = p;
-	     continue;
-	  }
-
-	if ((int) dc == maxc)
-	  {
-	     SLsmg_gotorc (r, c);
-	     SLsmg_write_chars (u, p);
-	     if (dr == 1) break;
-
-	     r++;
-	     dc = 0;
-	     dr--;
-	     u = p;
-	     continue;
-	  }
-
-	dc++;
-	if (utf8_mode)
-	  p = SLutf8_skip_chars (p, pmax, 1, NULL, 0);
-	else
-	  p++;
-     }
-}
-
-int SLsmg_Tab_Width = 8;
-
-/* Minimum value for which eight bit char is displayed as is. */
-
-#ifndef IBMPC_SYSTEM
-int SLsmg_Display_Eight_Bit = 160;
-#else
-int SLsmg_Display_Eight_Bit = 128;
-#endif
-
-void SLsmg_write_char (SLwchar_Type ch)
-{
-   unsigned char u[SLUTF8_MAX_MBLEN];
-   unsigned char *umax;
-
-   if ((ch < 0x80) || (UTF8_Mode == 0))
-     {
-	u[0] = (unsigned char) ch;
-	SLsmg_write_chars (u, u+1);
-	return;
-     }
-   if (NULL == (umax = SLutf8_encode (ch, u, SLUTF8_MAX_MBLEN)))
-     return;
-   SLsmg_write_chars (u, umax);
-}
-
-static int Cls_Flag;
-
-void SLsmg_cls (void)
-{
-   int tac;
-   if (Smg_Inited == 0) return;
-
-   tac = This_Alt_Char; This_Alt_Char = 0;
-   SLsmg_set_color (0);
-   clear_region (0, (int)Screen_Rows, 0x20);
-   This_Alt_Char = tac;
-   SLsmg_set_color (0);
-   Cls_Flag = 1;
-}
-#if 0
-static void do_copy (SLsmg_Char_Type *a, SLsmg_Char_Type *b)
-{
-   SLsmg_Char_Type *amax = a + Screen_Cols;
-
-   while (a < amax) *a++ = *b++;
-}
-#endif
-
-#ifndef IBMPC_SYSTEM
-int SLsmg_Scroll_Hash_Border = 0;
-static unsigned long compute_hash (SLsmg_Char_Type *c, unsigned int n)
-{
-   SLsmg_Char_Type *csave, *cmax;
-   int is_blank = 2;
-
-   c += SLsmg_Scroll_Hash_Border;
-   csave = c;
-   cmax = c + (n - SLsmg_Scroll_Hash_Border);
-
-   while ((c < cmax) && is_blank)
-     {
-	if ((c->wchars[0] != 32) || (c->nchars != 1))
-	  is_blank--;
-	c++;
-     }
-   if (is_blank) return 0;
-
-   return _pSLstring_hash ((unsigned char *)csave, (unsigned char *)cmax);
-}
-
-static unsigned long Blank_Hash;
-
-static int try_scroll_down (int rmin, int rmax)
-{
-   int i, r1, r2, di, j;
-   unsigned long hash;
-   int did_scroll;
-   SLsmg_Color_Type color;
-   SLsmg_Char_Type *tmp;
-   int ignore;
-
-   did_scroll = 0;
-   for (i = rmax; i > rmin; i--)
-     {
-	hash = SL_Screen[i].new_hash;
-	if (hash == Blank_Hash) continue;
-
-	if ((hash == SL_Screen[i].old_hash)
-#if 0
-	    || ((i + 1 < Screen_Rows) && (hash == SL_Screen[i + 1].old_hash))
-	    || ((i - 1 > rmin) && (SL_Screen[i].old_hash == SL_Screen[i - 1].new_hash))
-#endif
-	    )
-	  continue;
-
-	for (j = i - 1; j >= rmin; j--)
-	  {
-	     if (hash == SL_Screen[j].old_hash) break;
-	  }
-	if (j < rmin) continue;
-
-	r2 = i;			       /* end scroll region */
-
-	di = i - j;
-	j--;
-	ignore = 0;
-	while ((j >= rmin) && (SL_Screen[j].old_hash == SL_Screen[j + di].new_hash))
-	  {
-	     if (SL_Screen[j].old_hash == Blank_Hash) ignore++;
-	     j--;
-	  }
-	r1 = j + 1;
-
-	/* If this scroll only scrolls this line into place, don't do it.
-	 */
-	if ((di > 1) && (r1 + di + ignore == r2)) continue;
-
-	/* If there is anything in the scrolling region that is ok, abort the
-	 * scroll.
-	 */
-
-	for (j = r1; j <= r2; j++)
-	  {
-	     if ((SL_Screen[j].old_hash != Blank_Hash)
-		 && (SL_Screen[j].old_hash == SL_Screen[j].new_hash))
-	       {
-		  /* See if the scroll is happens to scroll this one into place. */
-		  if ((j + di > r2) || (SL_Screen[j].old_hash != SL_Screen[j + di].new_hash))
-		    break;
-	       }
-	  }
-	if (j <= r2) continue;
-
-	color = This_Color;  This_Color = 0;
-	did_scroll = 1;
-	(*tt_normal_video) ();
-	(*tt_set_scroll_region) (r1, r2);
-	(*tt_goto_rc) (0, 0);
-	(*tt_reverse_index) (di);
-	(*tt_reset_scroll_region) ();
-	/* Now we have a hole in the screen.
-	 * Make the virtual screen look like it.
-	 * 
-	 * Note that if the terminal does not support BCE, then we have
-	 * no idea what color the hole is.  So, for this case, we do not
-	 * want to add Bce_Color_Offset to This_Color since if Bce_Color_Offset
-	 * is non-zero, then This_Color = 0 does not match any valid color
-	 * obtained by adding Bce_Color_Offset.
-	 */
-	for (j = r1; j <= r2; j++) SL_Screen[j].flags = TOUCHED;
-
-	while (di--)
-	  {
-	     tmp = SL_Screen[r2].old;
-	     for (j = r2; j > r1; j--)
-	       {
-		  SL_Screen[j].old = SL_Screen[j - 1].old;
-		  SL_Screen[j].old_hash = SL_Screen[j - 1].old_hash;
-	       }
-	     SL_Screen[r1].old = tmp;
-	     blank_line (SL_Screen[r1].old, Screen_Cols, 0x20);
-	     SL_Screen[r1].old_hash = Blank_Hash;
-	     r1++;
-	  }
-	This_Color = color;
-     }
-
-   return did_scroll;
-}
-
-static int try_scroll_up (int rmin, int rmax)
-{
-   int i, r1, r2, di, j;
-   unsigned long hash;
-   int did_scroll;
-   SLsmg_Color_Type color;
-   SLsmg_Char_Type *tmp;
-   int ignore;
-
-   did_scroll = 0;
-   for (i = rmin; i < rmax; i++)
-     {
-	hash = SL_Screen[i].new_hash;
-	if (hash == Blank_Hash) continue;
-	if (hash == SL_Screen[i].old_hash)
-	  continue;
-	/* find a match further down screen */
-	for (j = i + 1; j <= rmax; j++)
-	  {
-	     if (hash == SL_Screen[j].old_hash) break;
-	  }
-	if (j > rmax) continue;
-
-	r1 = i;			       /* beg scroll region */
-	di = j - i;		       /* number of lines to scroll */
-	j++;			       /* since we know this is a match */
-
-	/* find end of scroll region */
-	ignore = 0;
-	while ((j <= rmax) && (SL_Screen[j].old_hash == SL_Screen[j - di].new_hash))
-	  {
-	     if (SL_Screen[j].old_hash == Blank_Hash) ignore++;
-	     j++;
-	  }
-	r2 = j - 1;		       /* end of scroll region */
-
-	/* If this scroll only scrolls this line into place, don't do it.
-	 */
-	if ((di > 1) && (r1 + di + ignore == r2)) continue;
-
-	/* If there is anything in the scrolling region that is ok, abort the
-	 * scroll.
-	 */
-
-	for (j = r1; j <= r2; j++)
-	  {
-	     if ((SL_Screen[j].old_hash != Blank_Hash)
-		 && (SL_Screen[j].old_hash == SL_Screen[j].new_hash))
-	       {
-		  if ((j - di < r1) || (SL_Screen[j].old_hash != SL_Screen[j - di].new_hash))
-		    break;
-	       }
-
-	  }
-	if (j <= r2) continue;
-
-	did_scroll = 1;
-
-	/* See the above comments about BCE */
-	color = This_Color;  This_Color = 0;
-	(*tt_normal_video) ();
-	(*tt_set_scroll_region) (r1, r2);
-	(*tt_goto_rc) (0, 0);	       /* relative to scroll region */
-	(*tt_delete_nlines) (di);
-	(*tt_reset_scroll_region) ();
-	/* Now we have a hole in the screen.  Make the virtual screen look
-	 * like it.
-	 */
-	for (j = r1; j <= r2; j++) SL_Screen[j].flags = TOUCHED;
-
-	while (di--)
-	  {
-	     tmp = SL_Screen[r1].old;
-	     for (j = r1; j < r2; j++)
-	       {
-		  SL_Screen[j].old = SL_Screen[j + 1].old;
-		  SL_Screen[j].old_hash = SL_Screen[j + 1].old_hash;
-	       }
-	     SL_Screen[r2].old = tmp;
-	     blank_line (SL_Screen[r2].old, Screen_Cols, ' ');
-	     SL_Screen[r2].old_hash = Blank_Hash;
-	     r2--;
-	  }
-	This_Color = color;
-     }
-   return did_scroll;
-}
-
-static void try_scroll (void)
-{
-   int r1, rmin, rmax;
-   int num_up, num_down;
-   /* find region limits. */
-
-   for (rmax = Screen_Rows - 1; rmax > 0; rmax--)
-     {
-	if (SL_Screen[rmax].new_hash != SL_Screen[rmax].old_hash)
-	  {
-	     r1 = rmax - 1;
-	     if ((r1 == 0)
-		 || (SL_Screen[r1].new_hash != SL_Screen[r1].old_hash))
-	       break;
-
-	     rmax = r1;
-	  }
-     }
-
-   for (rmin = 0; rmin < rmax; rmin++)
-     {
-	if (SL_Screen[rmin].new_hash != SL_Screen[rmin].old_hash)
-	  {
-	     r1 = rmin + 1;
-	     if ((r1 == rmax)
-		 || (SL_Screen[r1].new_hash != SL_Screen[r1].old_hash))
-	       break;
-
-	     rmin = r1;
-	  }
-     }
-
-   /* Below, we have two scrolling algorithms.  The first has the effect of
-    * scrolling lines down.  This is usually appropriate when one moves
-    * up the display, e.g., with the UP arrow.  The second algorithm is
-    * appropriate for going the other way.  It is important to choose the
-    * correct one.
-    */
-
-   num_up = 0;
-   for (r1 = rmin; r1 < rmax; r1++)
-     {
-	if (SL_Screen[r1].new_hash == SL_Screen[r1 + 1].old_hash)
-	  num_up++;
-     }
-
-   num_down = 0;
-   for (r1 = rmax; r1 > rmin; r1--)
-     {
-	if (SL_Screen[r1 - 1].old_hash == SL_Screen[r1].new_hash)
-	  num_down++;
-     }
-
-   if (num_up > num_down)
-     {
-	if (try_scroll_up (rmin, rmax))
-	  return;
-
-	(void) try_scroll_down (rmin, rmax);
-     }
-   else
-     {
-	if (try_scroll_down (rmin, rmax))
-	  return;
-
-	(void) try_scroll_up (rmin, rmax);
-     }
-}
-#endif   /* NOT IBMPC_SYSTEM */
-
-#ifdef REQUIRES_NON_BCE_SUPPORT
-static void adjust_colors (void)
-{
-   int bce;
-   unsigned int i;
-
-   bce = Bce_Color_Offset;
-   Bce_Color_Offset = _pSLtt_get_bce_color_offset ();
-   if (bce == Bce_Color_Offset)
-     return;
-
-   for (i = 0; i < Screen_Rows; i++)
-     {
-	SLsmg_Char_Type *s, *smax;
-
-	SL_Screen[i].flags |= TRASHED;
-	s = SL_Screen[i].neew;
-	smax = s + Screen_Cols;
-
-	while (s < smax)
-	  {
-	     SLsmg_Color_Type color = s->color;
-	     int acs = color & SLSMG_ACS_MASK;
-	     color = (color & SLSMG_COLOR_MASK) + (Bce_Color_Offset - bce);
-	     if (color < SLSMG_MAX_COLORS)
-	       s->color = color | acs;
-
-	     s++;
-	  }
-     }
-}
-#endif
-
-void SLsmg_refresh (void)
-{
-   unsigned int i;
-#ifndef IBMPC_SYSTEM
-   int trashed = 0;
-#endif
-   int r, c;
-
-   if (Smg_Inited == 0) return;
-   
-   if (Screen_Trashed)
-     {
-	Cls_Flag = 1;
-	for (i = 0; i < Screen_Rows; i++)
-	  SL_Screen[i].flags |= TRASHED;
-#ifdef REQUIRES_NON_BCE_SUPPORT
-	adjust_colors ();
-#endif
-     }
-
-#ifndef IBMPC_SYSTEM
-   for (i = 0; i < Screen_Rows; i++)
-     {
-	if (SL_Screen[i].flags == 0) continue;
-	SL_Screen[i].new_hash = compute_hash (SL_Screen[i].neew, Screen_Cols);
-	trashed = 1;
-     }
-#endif
-
-   if (Cls_Flag)
-     {
-	(*tt_normal_video) ();  (*tt_cls) ();
-     }
-#ifndef IBMPC_SYSTEM
-   else if (trashed && (*tt_Term_Cannot_Scroll == 0)) try_scroll ();
-#endif
-
-   for (i = 0; i < Screen_Rows; i++)
-     {
-	if (SL_Screen[i].flags == 0) continue;
-
-	if (Cls_Flag || SL_Screen[i].flags & TRASHED)
-	  {
-	     SLsmg_Color_Type color = This_Color;
-
-	     if (Cls_Flag == 0) 
-	       {
-		  (*tt_goto_rc) (i, 0);
-		  (*tt_del_eol) ();
-	       }
-	     This_Color = 0;
-	     blank_line (SL_Screen[i].old, Screen_Cols, 0x20);
-	     This_Color = color;
-	  }
-
-	(*tt_smart_puts) (SL_Screen[i].neew, SL_Screen[i].old, Screen_Cols, i);
-
-	memcpy ((char *) SL_Screen[i].old, (char *) SL_Screen[i].neew,
-		Screen_Cols * sizeof (SLsmg_Char_Type));
-
-	SL_Screen[i].flags = 0;
-#ifndef IBMPC_SYSTEM
-	SL_Screen[i].old_hash = SL_Screen[i].new_hash;
-#endif
-     }
-
-
-   r = This_Row - Start_Row;
-   c = This_Col - Start_Col;
-   if (r < 0) 
-     {
-	r = 0; 
-	c = 0;
-     }
-   else if (r >= (int)Screen_Rows)
-     {
-	r = (int)Screen_Rows;
-	c = (int)Screen_Cols-1;
-     }
-   if (c < 0) 
-     c = 0;
-   else if (c >= (int)Screen_Cols)
-     c = (int)Screen_Cols-1;
-
-   (*tt_goto_rc) (r,c);
-   (void) (*tt_flush_output) ();
-   Cls_Flag = 0;
-   Screen_Trashed = 0;
-}
-
-static int compute_clip (int row, int n, int box_start, int box_end,
-			 int *rmin, int *rmax)
-{
-   int row_max;
-
-   if (n < 0) return 0;
-   if (row >= box_end) return 0;
-   row_max = row + n;
-   if (row_max <= box_start) return 0;
-
-   if (row < box_start) row = box_start;
-   if (row_max >= box_end) row_max = box_end;
-   *rmin = row;
-   *rmax = row_max;
-   return 1;
-}
-
-void SLsmg_touch_lines (int row, unsigned int n)
-{
-   int i;
-   int r1, r2;
-
-   /* Allow this function to be called even when we are not initialied.
-    * Calling this function is useful after calling SLtt_set_color
-    * to force the display to be redrawn
-    */
-
-   if (Smg_Inited == 0)
-     return;
-
-   if (0 == compute_clip (row, (int) n, Start_Row, Start_Row + Screen_Rows, &r1, &r2))
-     return;
-
-   r1 -= Start_Row;
-   r2 -= Start_Row;
-   for (i = r1; i < r2; i++)
-     {
-	SL_Screen[i].flags |= TRASHED;
-     }
-}
-
-void SLsmg_touch_screen (void)
-{
-   Screen_Trashed = 1;
-}
-
-#ifndef IBMPC_SYSTEM
-# define BLOCK_SIGNALS SLsig_block_signals ()
-# define UNBLOCK_SIGNALS SLsig_unblock_signals ()
-#else
-# define BLOCK_SIGNALS (void)0
-# define UNBLOCK_SIGNALS (void)0
-#endif
-
-static int Smg_Suspended;
-int SLsmg_suspend_smg (void)
-{
-   BLOCK_SIGNALS;
-
-   if (Smg_Suspended == 0)
-     {
-	(*tt_reset_video) ();
-	Smg_Suspended = 1;
-     }
-
-   UNBLOCK_SIGNALS;
-   return 0;
-}
-
-int SLsmg_resume_smg (void)
-{
-   BLOCK_SIGNALS;
-
-   if (Smg_Suspended == 0)
-     {
-	UNBLOCK_SIGNALS;
-	return 0;
-     }
-
-   Smg_Suspended = 0;
-
-   if (-1 == (*tt_init_video) ())
-     {
-	UNBLOCK_SIGNALS;
-	return -1;
-     }
-
-   Cls_Flag = 1;
-   SLsmg_touch_screen ();
-   SLsmg_refresh ();
-
-   UNBLOCK_SIGNALS;
-   return 0;
-}
-
-   
-static void reset_smg (void)
-{
-   unsigned int i;
-   if (Smg_Inited == 0)
-     return;
-
-   for (i = 0; i < Screen_Rows; i++)
-     {
-	SLfree ((char *)SL_Screen[i].old);
-	SLfree ((char *)SL_Screen[i].neew);
-	SL_Screen[i].old = SL_Screen[i].neew = NULL;
-     }
-   This_Alt_Char = This_Color = 0;
-   Smg_Inited = 0;
-}
-
-
-static int init_smg (void)
-{
-   unsigned int i, len;
-   SLsmg_Char_Type *old, *neew;
-
-   Smg_Inited = 0;
-
-#ifdef REQUIRES_NON_BCE_SUPPORT
-   Bce_Color_Offset = _pSLtt_get_bce_color_offset ();
-#endif
-   
-   Screen_Rows = *tt_Screen_Rows;
-   if (Screen_Rows > SLTT_MAX_SCREEN_ROWS)
-     Screen_Rows = SLTT_MAX_SCREEN_ROWS;
-
-   Screen_Cols = *tt_Screen_Cols;
-
-   This_Col = This_Row = Start_Col = Start_Row = 0;
-
-   This_Alt_Char = 0;
-   SLsmg_set_color (0);
-   Cls_Flag = 1;
-   
-   init_acs (ACS_MODE_AUTO);
-
-   len = Screen_Cols + 3;
-   for (i = 0; i < Screen_Rows; i++)
-     {
-	if ((NULL == (old = (SLsmg_Char_Type *) SLmalloc (sizeof(SLsmg_Char_Type) * len)))
-	    || ((NULL == (neew = (SLsmg_Char_Type *) SLmalloc (sizeof(SLsmg_Char_Type) * len)))))
-	  {
-	     SLfree ((char *) old);
-	     return -1;
-	  }
-	blank_line (old, len, ' ');
-	blank_line (neew, len, ' ');
-	SL_Screen[i].old = old;
-	SL_Screen[i].neew = neew;
-	SL_Screen[i].flags = 0;
-#ifndef IBMPC_SYSTEM
-	Blank_Hash = compute_hash (old, Screen_Cols);
-	SL_Screen[i].new_hash = SL_Screen[i].old_hash =  Blank_Hash;
-#endif
-     }
-   
-   _pSLtt_color_changed_hook = SLsmg_touch_screen;
-   Screen_Trashed = 1;
-   Smg_Inited = 1;
-   return 0;
-}
-
-
-int SLsmg_init_smg (void)
-{
-   int ret;
-
-   BLOCK_SIGNALS;
-
-   if (tt_Screen_Rows == NULL)
-     init_tt_symbols ();
-
-   if (Smg_Inited)
-     SLsmg_reset_smg ();
-
-   if (UTF8_Mode == -1)
-     UTF8_Mode = _pSLutf8_mode;
-
-   if (-1 == (*tt_init_video) ())
-     {
-	UNBLOCK_SIGNALS;
-	return -1;
-     }
-   
-   if (-1 == (ret = init_smg ()))
-     (void) (*tt_reset_video)();
-
-   UNBLOCK_SIGNALS;
-   return ret;
-}
-
-int SLsmg_reinit_smg (void)
-{
-   int ret;
-
-   if (Smg_Inited == 0)
-     return SLsmg_init_smg ();
-
-   BLOCK_SIGNALS;
-   reset_smg ();
-   ret = init_smg ();
-   UNBLOCK_SIGNALS;
-   return ret;
-}
-
-void SLsmg_reset_smg (void)
-{   
-   if (Smg_Inited == 0)
-     return;
-   
-   BLOCK_SIGNALS;
-
-   reset_smg ();
-   (*tt_reset_video)();
-
-   UNBLOCK_SIGNALS;
-}
-
-void SLsmg_vprintf (char *fmt, va_list ap)
-{
-   char buf[1024];
-
-   if (Smg_Inited == 0) return;
-
-   (void) SLvsnprintf (buf, sizeof (buf), fmt, ap);
-   SLsmg_write_string (buf);
-}
-
-void SLsmg_printf (char *fmt, ...)
-{
-   va_list ap;
-   char *f;
-
-   if (Smg_Inited == 0) return;
-
-   va_start(ap, fmt);
-
-   f = fmt;
-   while (*f && (*f != '%'))
-     f++;
-   if (f != fmt)
-     SLsmg_write_chars ((SLuchar_Type *)fmt, (SLuchar_Type *)f);
-
-   if (*f != 0)
-     SLsmg_vprintf (f, ap);
-
-   va_end (ap);
-}
-
-void SLsmg_set_screen_start (int *r, int *c)
-{
-   int orow = Start_Row, oc = Start_Col;
-
-   if (Smg_Inited == 0) return;
-
-   if (c == NULL) Start_Col = 0;
-   else
-     {
-	Start_Col = *c;
-	*c = oc;
-     }
-   if (r == NULL) Start_Row = 0;
-   else
-     {
-	Start_Row = *r;
-	*r = orow;
-     }
-}
-
-void SLsmg_draw_object (int r, int c, SLwchar_Type object)
-{
-   This_Row = r;  This_Col = c;
-
-   if (Smg_Inited == 0) return;
-
-   if (point_visible (1))
-     {
-	int color = This_Color;
-	This_Color |= SLSMG_ACS_MASK;
-	SLsmg_write_char (object);
-	This_Color = color;
-     }
-
-   This_Col = c + 1;
-}
-
-void SLsmg_draw_hline (unsigned int n)
-{
-   static unsigned char hbuf[16];
-   int cmin, cmax;
-   int final_col = This_Col + (int) n;
-   int save_color;
-
-   if (Smg_Inited == 0) return;
-
-   if ((This_Row < Start_Row) || (This_Row >= Start_Row + (int)Screen_Rows)
-       || (0 == compute_clip (This_Col, n, Start_Col, Start_Col + (int)Screen_Cols,
-			      &cmin, &cmax)))
-     {
-	This_Col = final_col;
-	return;
-     }
-
-   n = (unsigned int)(cmax - cmin);
-
-   save_color = This_Color;
-   This_Color |= SLSMG_ACS_MASK;
-   This_Col = cmin;
-
-      
-   if (hbuf[0] == 0)
-     {
-	SLMEMSET ((char *) hbuf, SLSMG_HLINE_CHAR, 16);
-     }
-
-
-   while (n)
-     {
-	SLsmg_write_char (SLSMG_HLINE_CHAR);
-	n--;
-     }
-   This_Color = save_color;
-   This_Col = final_col;
-}
-
-void SLsmg_draw_vline (int n)
-{
-   int c = This_Col, rmin, rmax;
-   int final_row = This_Row + n;
-   int save_color;
-
-   if (Smg_Inited == 0) return;
-
-   if (((c < Start_Col) || (c >= Start_Col + (int)Screen_Cols)) 
-       || (0 == compute_clip (This_Row, n, Start_Row, 
-			      Start_Row + (int)Screen_Rows,
-			      &rmin, &rmax)))
-     {
-	This_Row = final_row;
-	return;
-     }
-
-   save_color = This_Color;
-   This_Color |= SLSMG_ACS_MASK;
-
-   for (This_Row = rmin; This_Row < rmax; This_Row++)
-     {
-	This_Col = c;
-	SLsmg_write_char (SLSMG_VLINE_CHAR);
-     }
-
-   This_Col = c;  This_Row = final_row;
-   This_Color = save_color;
-}
-
-void SLsmg_draw_box (int r, int c, unsigned int dr, unsigned int dc)
-{
-   if (Smg_Inited == 0) return;
-
-   if (!dr || !dc) return;
-   This_Row = r;  This_Col = c;
-   dr--; dc--;
-   SLsmg_draw_hline (dc);
-   SLsmg_draw_vline (dr);
-   This_Row = r;  This_Col = c;
-   SLsmg_draw_vline (dr);
-   SLsmg_draw_hline (dc);
-   SLsmg_draw_object (r, c, SLSMG_ULCORN_CHAR);
-   SLsmg_draw_object (r, c + (int) dc, SLSMG_URCORN_CHAR);
-   SLsmg_draw_object (r + (int) dr, c, SLSMG_LLCORN_CHAR);
-   SLsmg_draw_object (r + (int) dr, c + (int) dc, SLSMG_LRCORN_CHAR);
-   This_Row = r; This_Col = c;
-}
-
-void SLsmg_fill_region (int r, int c, unsigned int dr, unsigned int dc, SLwchar_Type wch)
-{
-   static unsigned char buf[16];
-   unsigned char ubuf[16*SLUTF8_MAX_MBLEN];
-   unsigned char *b, *bmax;
-   int count;
-   int dcmax, rmax;
-   unsigned int wchlen;
-
-   if (Smg_Inited == 0) return;
-
-   SLsmg_gotorc (r, c);
-   r = This_Row; c = This_Col;
-
-   dcmax = Screen_Cols - This_Col;
-   if (dcmax < 0)
-     return;
-
-   if (dc > (unsigned int) dcmax) dc = (unsigned int) dcmax;
-
-   rmax = This_Row + (int)dr;
-   if (rmax > (int)Screen_Rows) rmax = (int)Screen_Rows;
-
-   if ((wch < 0x80) 
-       || (UTF8_Mode == 0))
-     {
-	if (buf[0] != (unsigned char) wch)
-	  memset ((char *) buf, (unsigned char) wch, sizeof(buf));
-	b = buf;
-	bmax = buf + sizeof (buf);
-	wchlen = 1;
-     }
-   else
-     {
-	unsigned int i;
-
-	b = ubuf;
-	bmax = SLutf8_encode (wch, b, SLUTF8_MAX_MBLEN);
-	if (bmax == NULL)
-	  {
-	     bmax = ubuf;
-	     *bmax++ = '?';
-	  }
-	wchlen = (unsigned int) (bmax - b);
-	for (i = 1; i < 16; i++)
-	  {
-	     memcpy (bmax, b, wchlen);
-	     bmax += wchlen;
-	  }
-     }
-
-   for (This_Row = r; This_Row < rmax; This_Row++)
-     {
-	This_Col = c;
-	count = dc / 16;
-	SLsmg_write_chars (b, b + wchlen * (dc % 16));
-	while (count-- > 0)
-	  {
-	     SLsmg_write_chars (b, bmax);
-	  }
-     }
-
-   This_Row = r;
-}
-
-void SLsmg_forward (int n)
-{
-   This_Col += n;
-}
-
-void
-SLsmg_set_color_in_region (int color, int r, int c, unsigned int dr, unsigned int dc)
-{
-   int cmax, rmax;
-
-   if (Smg_Inited == 0) return;
-
-   c -= Start_Col;
-   r -= Start_Row;
-
-   cmax = c + (int) dc;
-   rmax = r + (int) dr;
-
-   if (cmax > (int)Screen_Cols) cmax = (int)Screen_Cols;
-   if (rmax > (int)Screen_Rows) rmax = (int)Screen_Rows;
-
-   if (c < 0) c = 0;
-   if (r < 0) r = 0;
-
-#ifdef REQUIRES_NON_BCE_SUPPORT
-   if (Bce_Color_Offset)
-     color += Bce_Color_Offset;
-#endif
-
-   while (r < rmax)
-     {
-	SLsmg_Char_Type *cell, *cell_max;
-
-	SL_Screen[r].flags |= TOUCHED;
-	cell = SL_Screen[r].neew;
-	cell_max = cell + cmax;
-	cell += c;
-
-	while (cell < cell_max)
-	  {
-	     int acs = cell->color & SLSMG_ACS_MASK;
-	     cell->color = color | acs;
-	     cell++;
-	  }
-	r++;
-     }
-}
-
-void SLsmg_set_terminal_info (SLsmg_Term_Type *tt)
-{
-   if (tt == NULL)		       /* use default */
-     return;
-
-   if ((tt->tt_normal_video == NULL)
-       || (tt->tt_goto_rc == NULL)
-       || (tt->tt_cls == NULL)
-       || (tt->tt_del_eol == NULL)
-       || (tt->tt_smart_puts == NULL)
-       || (tt->tt_flush_output == NULL)
-       || (tt->tt_reset_video == NULL)
-       || (tt->tt_init_video == NULL)
-#ifndef IBMPC_SYSTEM
-       || (tt->tt_set_scroll_region == NULL)
-       || (tt->tt_reverse_index == NULL)
-       || (tt->tt_reset_scroll_region == NULL)
-       || (tt->tt_delete_nlines == NULL)
-       /* Variables */
-       || (tt->tt_term_cannot_scroll == NULL)
-       || (tt->tt_has_alt_charset == NULL)
-#if 0 /* These can be NULL */
-       || (tt->tt_use_blink_for_acs == NULL)
-       || (tt->tt_graphic_char_pairs == NULL)
-#endif
-       || (tt->tt_screen_cols == NULL)
-       || (tt->tt_screen_rows == NULL)
-#endif
-       )
-     SLang_exit_error ("The Terminal not powerful enough for S-Lang's SLsmg interface");
-
-   tt_normal_video = tt->tt_normal_video;
-   tt_goto_rc = tt->tt_goto_rc;
-   tt_cls = tt->tt_cls;
-   tt_del_eol = tt->tt_del_eol;
-   tt_smart_puts = tt->tt_smart_puts;
-   tt_flush_output = tt->tt_flush_output;
-   tt_reset_video = tt->tt_reset_video;
-   tt_init_video = tt->tt_init_video;
-
-#ifndef IBMPC_SYSTEM
-   tt_set_scroll_region = tt->tt_set_scroll_region;
-   tt_reverse_index = tt->tt_reverse_index;
-   tt_reset_scroll_region = tt->tt_reset_scroll_region;
-   tt_delete_nlines = tt->tt_delete_nlines;
-
-   tt_Term_Cannot_Scroll = tt->tt_term_cannot_scroll;
-#endif
-
-   tt_Has_Alt_Charset = tt->tt_has_alt_charset;
-   tt_Screen_Cols = tt->tt_screen_cols;
-   tt_Screen_Rows = tt->tt_screen_rows;
-   tt_unicode_ok = tt->unicode_ok;
-}
-
-/* The following routines are partially supported. */
-void SLsmg_write_color_chars (SLsmg_Char_Type *s, unsigned int len)
-{
-#if 1
-   SLsmg_write_raw (s, len);
-#else
-   SLsmg_Char_Type *smax, sh;
-   char buf[32], *b, *bmax;
-   int color, save_color;
-
-   if (Smg_Inited == 0) return;
-
-   smax = s + len;
-   b = buf;
-   bmax = b + sizeof (buf);
-
-   save_color = This_Color;
-
-   while (s < smax)
-     {
-	sh = *s++;
-
-	color = SLSMG_EXTRACT_COLOR(sh);
-
-#ifdef REQUIRES_NON_BCE_SUPPORT
-	if (Bce_Color_Offset)
-	  {
-	     if (color & 0x80)
-	       color = ((color & 0x7F) + Bce_Color_Offset) | 0x80;
-	     else
-	       color = ((color & 0x7F) + Bce_Color_Offset) & 0x7F;
-	  }
-#endif
-
-	if ((color != This_Color) || (b == bmax))
-	  {
-	     if (b != buf)
-	       {
-		  SLsmg_write_nchars (buf, (int) (b - buf));
-		  b = buf;
-	       }
-	     This_Color = color;
-	  }
-	*b++ = (char) SLSMG_EXTRACT_CHAR(sh);
-     }
-
-   if (b != buf)
-     SLsmg_write_nchars (buf, (unsigned int) (b - buf));
-
-   This_Color = save_color;
-#endif
-}
-
-unsigned int SLsmg_strwidth (SLuchar_Type *u, SLuchar_Type *umax)
-{
-   unsigned char display_8bit;
-   int utf8_mode = UTF8_Mode;
-   int col;
-
-   if (u == NULL)
-     return 0;
-
-   display_8bit = (unsigned char) SLsmg_Display_Eight_Bit;
-   if (utf8_mode)
-     display_8bit = 0xA0;
-
-   col = This_Col;
-
-   while (u < umax)
-     {
-	SLuchar_Type ch;
-	unsigned int nconsumed;
-	SLwchar_Type wc;
-
-	ch = *u;
-	if (ch < 0x80)
-	  {
-	     u++;
-
-	     if ((ch >= 0x20) && (ch != 0x7F))
-	       {
-		  col++;
-		  continue;
-	       }
-	     
-	     if ((ch == '\t') && (SLsmg_Tab_Width > 0))
-	       {
-		  if (col >= 0)
-		    col = (1 + col/SLsmg_Tab_Width) * SLsmg_Tab_Width;
-		  else
-		    col = ((col + 1)/SLsmg_Tab_Width) * SLsmg_Tab_Width;
-		  
-		  continue;
-	       }
-
-	     if ((ch == '\n')
-		 && (SLsmg_Newline_Behavior != SLSMG_NEWLINE_PRINTABLE))
-	       break;
-	     
-	     if ((ch == 0x8) && SLsmg_Backspace_Moves)
-	       {
-		  col--;
-		  continue;
-	       }
-#if SLSMG_HAS_EMBEDDED_ESCAPE
-	     if ((ch == 033) && Embedded_Escape_Mode)
-	       {
-		  SLsmg_Color_Type color;
-		  if (0 == parse_embedded_escape (u, umax, 0, &u, &color))
-		    continue;
-	       }
-#endif
-	     col += 2;
-	     continue;
-	  }
-	
-	nconsumed = 1;
-	if ((utf8_mode == 0)
-	    || (NULL == SLutf8_decode (u, umax, &wc, &nconsumed)))
-	  {	     
-	     if ((utf8_mode == 0)
-		 && (display_8bit && (*u >= display_8bit)))
-	       col++;
-	     else
-	       col += 4*nconsumed;
-	     u += nconsumed;
-	     continue;
-	  }
-
-	u += nconsumed;
-	if (wc < (SLwchar_Type)display_8bit)
-	  {
-	     col += 4;
-	     continue;
-	  }
-	col += SLwchar_wcwidth (wc);
-     }
-   
-   if (col < This_Col)
-     return 0;
-
-   return (unsigned int) (col - This_Col);
-}
-
-/* If the string u were written at the current positition, this function 
- * returns the number of bytes necessary to reach the specified width.
- */
-unsigned int SLsmg_strbytes (SLuchar_Type *u, SLuchar_Type *umax, unsigned int width)
-{
-   SLuchar_Type *ustart;
-   unsigned char display_8bit;
-   int utf8_mode = UTF8_Mode;
-   int col, col_max;
-
-   if (u == NULL)
-     return 0;
-
-   display_8bit = (unsigned char) SLsmg_Display_Eight_Bit;
-   if (utf8_mode)
-     display_8bit = 0xA0;
-
-   col = This_Col;
-   col_max = col + width;
-   ustart = u;
-
-   while (u < umax)
-     {
-	SLuchar_Type ch;
-	SLwchar_Type wc;
-	unsigned int nconsumed = 1;
-
-	ch = *u;
-	if (ch < 0x80)
-	  {
-	     if ((ch >= 0x20) && (ch != 0x7F))
-	       col++;
-	     else if ((ch == '\t') && (SLsmg_Tab_Width > 0))
-	       {
-		  if (col >= 0)
-		    col = (1 + col/SLsmg_Tab_Width) * SLsmg_Tab_Width;
-		  else
-		    col = ((col + 1)/SLsmg_Tab_Width) * SLsmg_Tab_Width;
-	       }
-	     else if ((ch == '\n')
-		      && (SLsmg_Newline_Behavior != SLSMG_NEWLINE_PRINTABLE))
-	       break;
-	     else if ((ch == 0x8) && SLsmg_Backspace_Moves)
-	       col--;
-#if SLSMG_HAS_EMBEDDED_ESCAPE
-	     else if ((ch == 033) && Embedded_Escape_Mode)
-	       {
-		  SLsmg_Color_Type color;
-		  SLuchar_Type *u1 = u+1;
-		  if (-1 == parse_embedded_escape (u1, umax, 0, &u1, &color))
-		    col += 2;
-		  nconsumed = (u1 - u);
-	       }
-#endif
-	     else col += 2;
-	  }
-	else if ((utf8_mode == 0)
-		 || (NULL == SLutf8_decode (u, umax, &wc, &nconsumed)))
-	  {
-	     if ((utf8_mode == 0)
-		 && (display_8bit && (*u >= display_8bit)))
-	       col++;
-	     else
-	       col += 4*nconsumed;     /* <XX> */
-	  }
-	else if (wc < (SLwchar_Type)display_8bit)
-	  col += 4;
-	else col += SLwchar_wcwidth (wc);
-	
-	if (col >= col_max)
-	  break;
-	
-	u += nconsumed;
-     }
-
-   return (unsigned int) (u - ustart);
-}
-
-unsigned int SLsmg_read_raw (SLsmg_Char_Type *buf, unsigned int len)
-{
-   unsigned int r, c;
-
-   if (Smg_Inited == 0) return 0;
-
-   if (0 == point_visible (1)) return 0;
-
-   r = (unsigned int) (This_Row - Start_Row);
-   c = (unsigned int) (This_Col - Start_Col);
-
-   if (c + len > (unsigned int) Screen_Cols)
-     len = (unsigned int) Screen_Cols - c;
-
-   memcpy ((char *) buf, (char *) (SL_Screen[r].neew + c), len * sizeof (SLsmg_Char_Type));
-   return len;
-}
-
-unsigned int SLsmg_write_raw (SLsmg_Char_Type *buf, unsigned int len)
-{
-   unsigned int r, c;
-   SLsmg_Char_Type *dest;
-
-   if (Smg_Inited == 0) return 0;
-
-   if (0 == point_visible (1)) return 0;
-
-   r = (unsigned int) (This_Row - Start_Row);
-   c = (unsigned int) (This_Col - Start_Col);
-
-   if (c + len > (unsigned int) Screen_Cols)
-     len = (unsigned int) Screen_Cols - c;
-
-   dest = SL_Screen[r].neew + c;
-
-   if (0 != memcmp ((char *) dest, (char *) buf, len * sizeof (SLsmg_Char_Type)))
-     {
-	memcpy ((char *) dest, (char *) buf, len * sizeof (SLsmg_Char_Type));
-	SL_Screen[r].flags |= TOUCHED;
-     }
-   return len;
-}
-
-int SLsmg_char_at (SLsmg_Char_Type *cp)
-{
-   if (Smg_Inited == 0) return -1;
-
-   if (point_visible (1))
-     {
-	SLsmg_Char_Type *c = &SL_Screen[This_Row - Start_Row].neew[This_Col - Start_Col];
-	if (c->nchars == 0)
-	  return -1;
-	*cp = *c;
-	return 0;
-     }
-   return -1;
-}
-
-int SLsmg_utf8_enable (int mode)
-{
-   if (mode == -1)
-     mode = _pSLutf8_mode;
-   
-   return UTF8_Mode = mode;
-}
-
-int SLsmg_is_utf8_mode (void)
-{
-   int mode = UTF8_Mode;
-   if (mode == -1)
-     mode = _pSLutf8_mode;
-
-   return mode;
-}
diff --git a/slang/slstring.c b/slang/slstring.c
deleted file mode 100644
index 67b5752..0000000
--- a/slang/slstring.c
+++ /dev/null
@@ -1,692 +0,0 @@
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-#include "slinclud.h"
-
-#include "slang.h"
-#include "_slang.h"
-
-typedef struct _pSLstring_Type
-{
-   struct _pSLstring_Type *next;
-   unsigned int ref_count;
-   unsigned long hash;
-   unsigned int len;
-   char bytes [1];
-}
-SLstring_Type;
-
-#define MAP_HASH_TO_INDEX(hash) ((hash) % SLSTRING_HASH_TABLE_SIZE)
-
-static SLstring_Type *String_Hash_Table [SLSTRING_HASH_TABLE_SIZE];
-static char Single_Char_Strings [256 * 2];
-
-#if SLANG_OPTIMIZE_FOR_SPEED
-#define MAX_FREE_STORE_LEN 32
-static SLstring_Type *SLS_Free_Store [MAX_FREE_STORE_LEN];
-
-# define NUM_CACHED_STRINGS 601
-typedef struct 
-{
-   SLstring_Type *sls;
-   char *str;
-}
-Cached_String_Type;
-static char *Deleted_String = "*deleted*";
-static Cached_String_Type Cached_Strings [NUM_CACHED_STRINGS];
-
-#define GET_CACHED_STRING(s) \
-   (Cached_Strings + (unsigned int)(((unsigned long) (s)) % NUM_CACHED_STRINGS))
-
-
-_INLINE_
-static void cache_string (SLstring_Type *sls)
-{
-   Cached_String_Type *cs;
-
-   cs = GET_CACHED_STRING(sls->bytes);
-   cs->str = sls->bytes;
-   cs->sls = sls;
-}
-
-_INLINE_
-static void uncache_string (char *s)
-{
-   Cached_String_Type *cs;
-   
-   cs = GET_CACHED_STRING(s);
-   if (cs->str == s)
-     {
-	cs->sls = NULL;
-	cs->str = Deleted_String;
-     }
-}
-#endif
-
-#if USE_NEW_HASH_CODE
-/* This hash algorithm comes from:
- *
- *   Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net. 
- *   You may use this code any way you wish, private, educational, or commercial.  It's free.
- *   See http://burtleburtle.net/bob/hash/evahash.html
- */
-
-typedef  unsigned long uint32;
-
-#define mix(a,b,c) \
-{ \
-  a -= b; a -= c; a ^= (c>>13); \
-  b -= c; b -= a; b ^= (a<<8); \
-  c -= a; c -= b; c ^= (b>>13); \
-  a -= b; a -= c; a ^= (c>>12);  \
-  b -= c; b -= a; b ^= (a<<16); \
-  c -= a; c -= b; c ^= (b>>5); \
-  a -= b; a -= c; a ^= (c>>3);  \
-  b -= c; b -= a; b ^= (a<<10); \
-  c -= a; c -= b; c ^= (b>>15); \
-}
-
-_INLINE_
-unsigned long _pSLstring_hash (unsigned char *s, unsigned char *smax)
-{
-   register uint32 a,b,c;
-   unsigned int length = (unsigned int)(smax - s);
-   unsigned int len = length;
-   
-   a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
-   c = 0;
-
-   /*---------------------------------------- handle most of the key */
-   while (len >= 12)
-     {
-	a += (s[0] +((uint32)s[1]<<8) +((uint32)s[2]<<16) +((uint32)s[3]<<24));
-	b += (s[4] +((uint32)s[5]<<8) +((uint32)s[6]<<16) +((uint32)s[7]<<24));
-	c += (s[8] +((uint32)s[9]<<8) +((uint32)s[10]<<16)+((uint32)s[11]<<24));
-	mix(a,b,c);
-	s += 12; len -= 12;
-     }
-
-   /*------------------------------------- handle the last 11 bytes */
-   c += length;
-   switch(len)              /* all the case statements fall through */
-   {
-   case 11: c+=((uint32)s[10]<<24);
-   case 10: c+=((uint32)s[9]<<16);
-   case 9 : c+=((uint32)s[8]<<8);
-      /* the first byte of c is reserved for the length */
-   case 8 : b+=((uint32)s[7]<<24);
-   case 7 : b+=((uint32)s[6]<<16);
-   case 6 : b+=((uint32)s[5]<<8);
-   case 5 : b+=s[4];
-   case 4 : a+=((uint32)s[3]<<24);
-   case 3 : a+=((uint32)s[2]<<16);
-   case 2 : a+=((uint32)s[1]<<8);
-   case 1 : a+=s[0];
-     /* case 0: nothing left to add */
-   }
-   mix(a,b,c);
-   /*-------------------------------------------- report the result */
-   return (unsigned long) c;
-}
-#else
-_INLINE_
-unsigned long _pSLstring_hash (unsigned char *s, unsigned char *smax)
-{
-   register unsigned long h = 0;
-   register unsigned long sum = 0;
-   unsigned char *smax4;
-
-   smax4 = smax - 4;
-
-   while (s < smax4)
-     {
-	sum += s[0];
-	h = sum + (h << 1);
-	sum += s[1];
-	h = sum + (h << 1);
-	sum += s[2];
-	h = sum + (h << 1);
-	sum += s[3];
-	h = sum + (h << 1);
-	
-	s += 4;
-     }
-
-   while (s < smax)
-     {
-	sum += *s++;
-	h ^= sum + (h << 3);	       /* slightly different */
-     }
-
-   return h;
-}
-#endif
-unsigned long _pSLcompute_string_hash (char *s)
-{
-#if SLANG_OPTIMIZE_FOR_SPEED
-   Cached_String_Type *cs;
-
-   cs = GET_CACHED_STRING(s);
-   if (cs->str == s)
-     return cs->sls->hash;
-#endif
-   return _pSLstring_hash ((unsigned char *) s, (unsigned char *) s + strlen (s));
-}
-
-_INLINE_
-/* This routine works with any (long) string */
-static SLstring_Type *find_string (char *s, unsigned int len, unsigned long hash)
-{
-   SLstring_Type *sls;
-
-   sls = String_Hash_Table [(unsigned int) MAP_HASH_TO_INDEX(hash)];
-
-   if (sls == NULL)
-     return NULL;
-
-   do
-     {
-	/* Note that we need to actually make sure that bytes[len] == 0. 
-	 * In this case, it is not enough to just compare pointers.  In fact,
-	 * this is called from create_nstring, etc...  It is unlikely that the
-	 * pointer is a slstring
-	 */
-	if ((sls->hash == hash)
-	    && (sls->len == len)
-	    && (0 == strncmp (s, sls->bytes, len)))
-	  break;
-
-	sls = sls->next;
-     }
-   while (sls != NULL);
-
-   return sls;
-}
-
-_INLINE_
-static SLstring_Type *find_slstring (char *s, unsigned long hash)
-{
-   SLstring_Type *sls;
-
-   sls = String_Hash_Table [MAP_HASH_TO_INDEX(hash)];
-   while (sls != NULL)
-     {
-	if (s == sls->bytes)
-	  return sls;
-
-	sls = sls->next;
-     }
-   return sls;
-}
-
-_INLINE_
-static SLstring_Type *allocate_sls (unsigned int len)
-{
-   SLstring_Type *sls;
-#if SLANG_OPTIMIZE_FOR_SPEED
-   
-   if ((len < MAX_FREE_STORE_LEN)
-       && (NULL != (sls = SLS_Free_Store [len])))
-     {
-	SLS_Free_Store[len] = NULL;
-	return sls;
-     }
-#endif
-   /* FIXME: use structure padding */
-   sls = (SLstring_Type *) SLmalloc (len + sizeof (SLstring_Type));
-   if (sls != NULL)
-     sls->len = len;
-   return sls;
-}
-
-_INLINE_
-static void free_sls (SLstring_Type *sls)
-{
-#if SLANG_OPTIMIZE_FOR_SPEED
-   unsigned int len = sls->len;
-   if ((len < MAX_FREE_STORE_LEN)
-       && (SLS_Free_Store[len] == NULL))
-     {
-	SLS_Free_Store [len] = sls;
-	return;
-     }
-#endif
-   SLfree ((char *)sls);
-}
-
-_INLINE_
-static char *create_long_string (char *s, unsigned int len, unsigned long hash)
-{
-   SLstring_Type *sls;
-
-   sls = find_string (s, len, hash);
-
-   if (sls != NULL)
-     {
-	sls->ref_count++;
-#if SLANG_OPTIMIZE_FOR_SPEED
-	cache_string (sls);
-#endif
-	return sls->bytes;
-     }
-
-   sls = allocate_sls (len);
-   if (sls == NULL)
-     return NULL;
-
-   strncpy (sls->bytes, s, len);
-   sls->bytes[len] = 0;
-   sls->ref_count = 1;
-   sls->hash = hash;
-#if SLANG_OPTIMIZE_FOR_SPEED
-   cache_string (sls);
-#endif
-
-   hash = MAP_HASH_TO_INDEX(hash);
-   sls->next = String_Hash_Table [(unsigned int)hash];
-   String_Hash_Table [(unsigned int)hash] = sls;
-
-   return sls->bytes;
-}
-
-_INLINE_
-static char *create_short_string (char *s, unsigned int len)
-{
-   char ch;
-
-   /* Note: if len is 0, then it does not matter what *s is.  This is
-    * important for SLang_create_nslstring.
-    */
-   if (len) ch = *s; else ch = 0;
-
-   len = 2 * (unsigned int) ((unsigned char) ch);
-   Single_Char_Strings [len] = ch;
-   Single_Char_Strings [len + 1] = 0;
-   return Single_Char_Strings + len;
-}
-
-/* s cannot be NULL */
-_INLINE_
-static SLstr_Type *create_nstring (char *s, unsigned int len, unsigned long *hash_ptr)
-{
-   unsigned long hash;
-
-   if (len < 2)
-     return create_short_string (s, len);
-
-   hash = _pSLstring_hash ((unsigned char *) s, (unsigned char *) (s + len));
-   *hash_ptr = hash;
-
-   return create_long_string (s, len, hash);
-}
-
-SLstr_Type *SLang_create_nslstring (char *s, unsigned int len)
-{
-   unsigned long hash;
-   if (s == NULL)
-     return NULL;
-   return create_nstring (s, len, &hash);
-}
-
-char *_pSLstring_make_hashed_string (char *s, unsigned int len, unsigned long *hashptr)
-{
-   unsigned long hash;
-
-   if (s == NULL) return NULL;
-
-   hash = _pSLstring_hash ((unsigned char *) s, (unsigned char *) s + len);
-   *hashptr = hash;
-
-   if (len < 2)
-     return create_short_string (s, len);
-
-   return create_long_string (s, len, hash);
-}
-
-char *_pSLstring_dup_hashed_string (char *s, unsigned long hash)
-{
-   unsigned int len;
-#if SLANG_OPTIMIZE_FOR_SPEED
-   Cached_String_Type *cs;
-   
-   if (s == NULL) return NULL;
-   if (s[0] == 0)
-     return create_short_string (s, 0);
-   if (s[1] == 0)
-     return create_short_string (s, 1);
-     
-   cs = GET_CACHED_STRING(s);
-   if (cs->str == s)
-     {
-	cs->sls->ref_count += 1;
-	return s;
-     }
-#else
-   if (s == NULL) return NULL;
-#endif
-
-   len = strlen (s);
-#if !SLANG_OPTIMIZE_FOR_SPEED
-   if (len < 2) return create_short_string (s, len);
-#endif
-
-   return create_long_string (s, len, hash);
-}
-
-/* This function requires an slstring!!! */
-char *_pSLstring_dup_slstring (char *s)
-{
-   SLstring_Type *sls;
-#if SLANG_OPTIMIZE_FOR_SPEED
-   Cached_String_Type *cs;
-#endif
-   
-   if (s == NULL)
-     return s;
-#if SLANG_OPTIMIZE_FOR_SPEED
-   cs = GET_CACHED_STRING(s);
-   if (cs->str == s)
-     {
-	cs->sls->ref_count += 1;
-	return s;
-     }
-#endif
-   if ((s[0] == 0) || (s[1] == 0))
-     return s;
-   
-   sls = (SLstring_Type *) (s - offsetof(SLstring_Type,bytes[0]));
-   sls->ref_count++;
-#if SLANG_OPTIMIZE_FOR_SPEED
-   cache_string (sls);
-#endif
-   return s;
-}
-
-static void free_sls_string (SLstring_Type *sls)
-{
-   SLstring_Type *sls1, *prev;
-   unsigned long hash = sls->hash;
-
-   hash = MAP_HASH_TO_INDEX(hash);
-
-   sls1 = String_Hash_Table [(unsigned int) hash];
-
-   prev = NULL;
-
-   /* This should not fail. */
-   while (sls1 != sls)
-     {
-	prev = sls1;
-	sls1 = sls1->next;
-     }
-
-   if (prev != NULL)
-     prev->next = sls->next;
-   else
-     String_Hash_Table [(unsigned int) hash] = sls->next;
-
-   free_sls (sls);
-}
-
-_INLINE_
-static void free_long_string (char *s, unsigned long hash)
-{
-   SLstring_Type *sls;
-
-   if (NULL == (sls = find_slstring (s, hash)))
-     {
-	SLang_verror (SL_APPLICATION_ERROR, "invalid attempt to free string:%s", s);
-	return;
-     }
-
-   sls->ref_count--;
-   if (sls->ref_count != 0)
-     {
-#if SLANG_OPTIMIZE_FOR_SPEED
-	/* cache_string (sls, len, hash); */
-#endif
-	return;
-     }
-#if SLANG_OPTIMIZE_FOR_SPEED
-   uncache_string (s);
-#endif
-   free_sls_string (sls);
-}
-
-/* This routine may be passed NULL-- it is not an error. */
-void SLang_free_slstring (char *s)
-{
-   unsigned long hash;
-   unsigned int len;
-#if SLANG_OPTIMIZE_FOR_SPEED
-   Cached_String_Type *cs;
-#endif
-
-   if (s == NULL) return;
-
-#if SLANG_OPTIMIZE_FOR_SPEED
-   cs = GET_CACHED_STRING(s);
-   if (cs->str == s)
-     {
-	SLstring_Type *sls = cs->sls;
-	if (sls->ref_count <= 1)
-	  {
-#if SLANG_OPTIMIZE_FOR_SPEED
-	     cs->sls = NULL;
-	     cs->str = Deleted_String;
-#endif
-	     free_sls_string (sls);
-	  }
-	else
-	  sls->ref_count -= 1;
-	return;
-     }
-#endif
-
-   if ((len = strlen (s)) < 2)
-     return;
-
-   hash = _pSLstring_hash ((unsigned char *)s, (unsigned char *) s + len);
-   free_long_string (s, hash);
-}
-
-char *SLang_create_slstring (char *s)
-{
-   unsigned long hash;
-#if SLANG_OPTIMIZE_FOR_SPEED
-   Cached_String_Type *cs;
-#endif
-
-   if (s == NULL) return NULL;
-#if SLANG_OPTIMIZE_FOR_SPEED
-   cs = GET_CACHED_STRING(s);
-   if (cs->str == s)
-     {
-	cs->sls->ref_count += 1;
-	return s;
-     }
-#endif
-
-   return create_nstring (s, strlen (s), &hash);
-}
-
-void _pSLfree_hashed_string (char *s, unsigned int len, unsigned long hash)
-{
-   if ((s == NULL) || (len < 2)) return;
-   free_long_string (s, hash);
-}
-
-
-char *_pSLallocate_slstring (unsigned int len)
-{
-   SLstring_Type *sls = allocate_sls (len);
-   if (sls == NULL)
-     return NULL;
-
-   sls->hash = 0;
-   return sls->bytes;
-}
-
-void _pSLunallocate_slstring (char *s, unsigned int len)
-{
-   SLstring_Type *sls;
-   
-   (void) len;
-   if (s == NULL)
-     return;
-   
-   sls = (SLstring_Type *) (s - offsetof(SLstring_Type,bytes[0]));
-   free_sls (sls);
-}
-
-char *_pSLcreate_via_alloced_slstring (char *s, unsigned int len)
-{   
-   unsigned long hash;
-   SLstring_Type *sls;
-
-   if (s == NULL)
-     return NULL;
-   
-   if (len < 2)
-     {
-	char *s1 = create_short_string (s, len);
-	_pSLunallocate_slstring (s, len);
-	return s1;
-     }
-
-   /* s is not going to be in the cache because when it was malloced, its
-    * value was unknown.  This simplifies the coding.
-    */
-   hash = _pSLstring_hash ((unsigned char *)s, (unsigned char *)s + len);
-   sls = find_string (s, len, hash);
-   if (sls != NULL)
-     {
-	sls->ref_count++;
-	_pSLunallocate_slstring (s, len);
-	s = sls->bytes;
-
-#if SLANG_OPTIMIZE_FOR_SPEED
-	cache_string (sls);
-#endif
-	return s;
-     }
-	
-   sls = (SLstring_Type *) (s - offsetof(SLstring_Type,bytes[0]));
-   sls->ref_count = 1;
-   sls->hash = hash;
-
-#if SLANG_OPTIMIZE_FOR_SPEED
-   cache_string (sls);
-#endif
-
-   hash = MAP_HASH_TO_INDEX(hash);
-   sls->next = String_Hash_Table [(unsigned int)hash];
-   String_Hash_Table [(unsigned int)hash] = sls;
-
-   return s;
-}
-
-/* Note, a and b may be ordinary strings.  The result is an slstring */
-char *SLang_concat_slstrings (char *a, char *b)
-{
-   unsigned int lena, len;
-   char *c;
-
-   lena = strlen (a);
-   len = lena + strlen (b);
-
-   c = _pSLallocate_slstring (len);
-   if (c == NULL)
-     return NULL;
-
-   strcpy (c, a);
-   strcpy (c + lena, b);
-
-   return _pSLcreate_via_alloced_slstring (c, len);
-}
-
-/* This routine is assumed to work even if s is not an slstring */
-unsigned int _pSLstring_bytelen (SLstr_Type *s)
-{
-#if SLANG_OPTIMIZE_FOR_SPEED
-   Cached_String_Type *cs;
-
-   cs = GET_CACHED_STRING(s);
-   if (cs->str == s)
-     return cs->sls->len;
-#endif
-   return strlen (s);
-}
-
-/* The caller must ensure that this is an slstring */
-void _pSLang_free_slstring (SLstr_Type *s)
-{
-#if SLANG_OPTIMIZE_FOR_SPEED
-   Cached_String_Type *cs;
-#endif
-   SLstring_Type *sls;
-
-   if (s == NULL) return;
-
-#if SLANG_OPTIMIZE_FOR_SPEED
-   cs = GET_CACHED_STRING(s);
-   if (cs->str == s)
-     {
-	sls = cs->sls;
-	if (sls->ref_count <= 1)
-	  {
-#if SLANG_OPTIMIZE_FOR_SPEED
-	     cs->sls = NULL;
-	     cs->str = Deleted_String;
-#endif
-	     free_sls_string (sls);
-	  }
-	else
-	  sls->ref_count -= 1;
-	return;
-     }
-#endif
-   
-   if ((s[0] == 0) || (s[1] == 0))
-     return;
-
-   sls = (SLstring_Type *) (s - offsetof(SLstring_Type,bytes[0]));
-   if (sls->ref_count > 1)
-     {
-	sls->ref_count--;
-	return;
-     }
-   free_long_string (s, sls->hash);
-}
-
-/* An SLstring is required */
-unsigned long _pSLstring_get_hash (SLstr_Type *s)
-{
-   SLstring_Type *sls;
-
-   if (s[0] == 0)
-     return _pSLstring_hash ((unsigned char*)s, (unsigned char *)s);
-   if (s[1] == 0)
-     return _pSLstring_hash ((unsigned char *)s, (unsigned char *)s+1);
-   
-   sls = (SLstring_Type *) (s - offsetof(SLstring_Type,bytes[0]));
-   return sls->hash;
-}
diff --git a/slang/sltermin.c b/slang/sltermin.c
deleted file mode 100644
index 4ecf7ba..0000000
--- a/slang/sltermin.c
+++ /dev/null
@@ -1,1204 +0,0 @@
-/* This file contains enough terminfo reading capabilities sufficient for
- * the slang SLtt interface.
- */
-
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-#include "slinclud.h"
-
-#include "slang.h"
-#include "_slang.h"
-
-/*
- * The majority of the comments found in the file were taken from the
- * term(4) man page on an SGI.
- */
-
-/* Short integers are stored in two 8-bit bytes.  The first byte contains
- * the least significant 8 bits of the value, and the second byte contains
- * the most significant 8 bits.  (Thus, the value represented is
- * 256*second+first.)  The value -1 is represented by 0377,0377, and the
- * value -2 is represented by 0376,0377; other negative values are illegal.
- * The -1 generally means that a capability is missing from this terminal.
- * The -2 means that the capability has been cancelled in the terminfo
- * source and also is to be considered missing.
- */
-
-static int make_integer (unsigned char *buf)
-{
-   register int lo, hi;
-   lo = (int) *buf++; hi = (int) *buf;
-   if (hi == 0377)
-     {
-	if (lo == 0377) return -1;
-	if (lo == 0376) return -2;
-     }
-   return lo + 256 * hi;
-}
-
-/*
- * The compiled file is created from the source file descriptions of the
- * terminals (see the -I option of infocmp) by using the terminfo compiler,
- * tic, and read by the routine setupterm [see curses(3X).]  The file is
- * divided into six parts in the following order:  the header, terminal
- * names, boolean flags, numbers, strings, and string table.
- *
- * The header section begins the file.  This section contains six short
- * integers in the format described below.  These integers are (1) the magic
- * number (octal 0432); (2) the size, in bytes, of the names section; (3)
- * the number of bytes in the boolean section; (4) the number of short
- * integers in the numbers section; (5) the number of offsets (short
- * integers) in the strings section; (6) the size, in bytes, of the string
- * table.
- */
-
-#define MAGIC 0432
-
-/* In this structure, all char * fields are malloced EXCEPT if the
- * structure is SLTERMCAP.  In that case, only terminal_names is malloced
- * and the other fields are pointers into it.
- */
-struct _pSLterminfo_Type
-{
-#define SLTERMINFO 1
-#define SLTERMCAP  2
-   unsigned int flags;
-
-   unsigned int name_section_size;
-   char *terminal_names;
-
-   unsigned int boolean_section_size;
-   unsigned char *boolean_flags;
-
-   unsigned int num_numbers;
-   unsigned char *numbers;
-
-   unsigned int num_string_offsets;
-   unsigned char *string_offsets;
-
-   unsigned int string_table_size;
-   char *string_table;
-
-};
-
-static char *tcap_getstr (char *, SLterminfo_Type *);
-static int tcap_getnum (char *, SLterminfo_Type *);
-static int tcap_getflag (char *, SLterminfo_Type *);
-static int tcap_getent (char *, SLterminfo_Type *);
-
-static FILE *open_terminfo (char *file, SLterminfo_Type *h)
-{
-   FILE *fp;
-   unsigned char buf[12];
-
-   /* Alan Cox reported a security problem here if the application using the
-    * library is setuid.  So, I need to make sure open the file as a normal
-    * user.  Unfortunately, there does not appear to be a portable way of
-    * doing this, so I am going to use 'setfsgid' and 'setfsuid', which
-    * are not portable.
-    *
-    * I will also look into the use of setreuid, seteuid and setregid, setegid.
-    * FIXME: Priority=medium
-    */
-   fp = fopen (file, "rb");
-   if (fp == NULL) return NULL;
-
-   if ((12 == fread ((char *) buf, 1, 12, fp) && (MAGIC == make_integer (buf))))
-     {
-	h->name_section_size = make_integer (buf + 2);
-	h->boolean_section_size = make_integer (buf + 4);
-	h->num_numbers = make_integer (buf + 6);
-	h->num_string_offsets = make_integer (buf + 8);
-	h->string_table_size = make_integer (buf + 10);
-     }
-   else
-     {
-	fclose (fp);
-	fp = NULL;
-     }
-   return fp;
-}
-
-/*
- * The terminal names section comes next.  It contains the first line of the
- * terminfo description, listing the various names for the terminal,
- * separated by the bar ( | ) character (see term(5)).  The section is
- * terminated with an ASCII NUL character.
- */
-
-/* returns pointer to malloced space */
-static unsigned char *read_terminfo_section (FILE *fp, unsigned int size)
-{
-   char *s;
-
-   if (NULL == (s = (char *) SLmalloc (size))) return NULL;
-   if (size != fread (s, 1, size, fp))
-     {
-	SLfree (s);
-	return NULL;
-     }
-   return (unsigned char *) s;
-}
-
-static char *read_terminal_names (FILE *fp, SLterminfo_Type *t)
-{
-   return t->terminal_names = (char *) read_terminfo_section (fp, t->name_section_size);
-}
-
-/*
- * The boolean flags have one byte for each flag.  This byte is either 0 or
- * 1 as the flag is present or absent.  The value of 2 means that the flag
- * has been cancelled.  The capabilities are in the same order as the file
- * <term.h>.
- */
-
-static unsigned char *read_boolean_flags (FILE *fp, SLterminfo_Type *t)
-{
-   /* Between the boolean section and the number section, a null byte is
-    * inserted, if necessary, to ensure that the number section begins on an
-    * even byte offset. All short integers are aligned on a short word
-    * boundary.
-    */
-
-   unsigned int size = (t->name_section_size + t->boolean_section_size) % 2;
-   size += t->boolean_section_size;
-
-   return t->boolean_flags = read_terminfo_section (fp, size);
-}
-
-/*
- * The numbers section is similar to the boolean flags section.  Each
- * capability takes up two bytes, and is stored as a short integer.  If the
- * value represented is -1 or -2, the capability is taken to be missing.
- */
-
-static unsigned char *read_numbers (FILE *fp, SLterminfo_Type *t)
-{
-   return t->numbers = read_terminfo_section (fp, 2 * t->num_numbers);
-}
-
-/* The strings section is also similar.  Each capability is stored as a
- * short integer, in the format above.  A value of -1 or -2 means the
- * capability is missing.  Otherwise, the value is taken as an offset from
- * the beginning of the string table.  Special characters in ^X or \c
- * notation are stored in their interpreted form, not the printing
- * representation.  Padding information ($<nn>) and parameter information
- * (%x) are stored intact in uninterpreted form.
- */
-
-static unsigned char *read_string_offsets (FILE *fp, SLterminfo_Type *t)
-{
-   return t->string_offsets = (unsigned char *) read_terminfo_section (fp, 2 * t->num_string_offsets);
-}
-
-/* The final section is the string table.  It contains all the values of
- * string capabilities referenced in the string section.  Each string is
- * null terminated.
- */
-
-static char *read_string_table (FILE *fp, SLterminfo_Type *t)
-{
-   return t->string_table = (char *) read_terminfo_section (fp, t->string_table_size);
-}
-
-/*
- * Compiled terminfo(4) descriptions are placed under the directory
- * /usr/share/lib/terminfo.  In order to avoid a linear search of a huge
- * UNIX system directory, a two-level scheme is used:
- * /usr/share/lib/terminfo/c/name where name is the name of the terminal,
- * and c is the first character of name.  Thus, att4425 can be found in the
- * file /usr/share/lib/terminfo/a/att4425.  Synonyms for the same terminal
- * are implemented by multiple links to the same compiled file.
- */
-
-static char *Terminfo_Dirs [] =
-{
-   NULL, /* $HOME/.terminfo */
-   NULL, /* $TERMINFO */
-   "/usr/share/terminfo",
-   "/usr/lib/terminfo",
-   "/usr/share/lib/terminfo",
-   "/etc/terminfo",
-   "/usr/local/lib/terminfo",
-#ifdef MISC_TERMINFO_DIRS
-   MISC_TERMINFO_DIRS,
-#endif
-   ""
-};
-
-SLterminfo_Type *_pSLtt_tigetent (char *term)
-{
-   char *tidir;
-   int i;
-   FILE *fp = NULL;
-   char file[1024];
-   static char home_ti [1024];
-   char *home;
-   SLterminfo_Type *ti;
-
-   if (
-       (term == NULL)
-#ifdef SLANG_UNTIC
-       && (SLang_Untic_Terminfo_File == NULL)
-#endif
-       )
-     return NULL;
-
-   if (_pSLsecure_issetugid ()
-       && ((term[0] == '.') || (NULL != strchr (term, '/'))))
-     return NULL;
-
-   if (NULL == (ti = (SLterminfo_Type *) SLmalloc (sizeof (SLterminfo_Type))))
-     {
-	return NULL;
-     }
-
-#ifdef SLANG_UNTIC
-   if (SLang_Untic_Terminfo_File != NULL)
-     {
-	fp = open_terminfo (SLang_Untic_Terminfo_File, ti);
-	goto fp_open_label;
-     }
-   else
-#endif
-   /* If we are on a termcap based system, use termcap */
-   if (0 == tcap_getent (term, ti)) return ti;
-
-   if (NULL != (home = _pSLsecure_getenv ("HOME")))
-     {
-	size_t len = strlen (home);
-    
-	if (len > sizeof (home_ti) - sizeof ("/.terminfo"))
-	    len = sizeof (home_ti) - sizeof ("/.terminfo");
-	memcpy (home_ti, home, len);
-	memcpy (home_ti + len, "/.terminfo", sizeof ("/.terminfo"));
-	Terminfo_Dirs [0] = home_ti;
-     }
-
-   Terminfo_Dirs[1] = _pSLsecure_getenv ("TERMINFO");
-   i = 0;
-   while (1)
-     {
-	tidir = Terminfo_Dirs[i];
-	if (tidir != NULL)
-	  {
-	     if (*tidir == 0)
-	       break;		       /* last one */
-
-	     if (sizeof (file) >= strlen (tidir) + 4 + strlen (term))
-	       {
-		  sprintf (file, "%s/%c/%s", tidir, *term, term);
-		  if (NULL != (fp = open_terminfo (file, ti)))
-		    break;
-	       }
-	  }
-	i++;
-     }
-
-#ifdef SLANG_UNTIC
-   fp_open_label:
-#endif
-
-   if (fp != NULL)
-     {
-	if (NULL != read_terminal_names (fp, ti))
-	  {
-	     if (NULL != read_boolean_flags (fp, ti))
-	       {
-		  if (NULL != read_numbers (fp, ti))
-		    {
-		       if (NULL != read_string_offsets (fp, ti))
-			 {
-			    if (NULL != read_string_table (fp, ti))
-			      {
-				 /* success */
-				 fclose (fp);
-				 ti->flags = SLTERMINFO;
-				 return ti;
-			      }
-			    SLfree ((char *)ti->string_offsets);
-			 }
-		       SLfree ((char *)ti->numbers);
-		    }
-		  SLfree ((char *)ti->boolean_flags);
-	       }
-	     SLfree ((char *)ti->terminal_names);
-	  }
-	fclose (fp);
-     }
-
-   SLfree ((char *)ti);
-   return NULL;
-}
-
-#ifdef SLANG_UNTIC
-# define UNTIC_COMMENT(x) ,x
-#else
-# define UNTIC_COMMENT(x)
-#endif
-
-typedef SLCONST struct
-{
-   char name[3];
-   int offset;
-#ifdef SLANG_UNTIC
-   char *comment;
-#endif
-}
-Tgetstr_Map_Type;
-
-/* I need to add: K1-5, %0-5(not important), @8, &8... */
-static Tgetstr_Map_Type Tgetstr_Map [] =
-{
-   {"!1", 212		UNTIC_COMMENT("shifted key")},
-   {"!2", 213		UNTIC_COMMENT("shifted key")},
-   {"!3", 214		UNTIC_COMMENT("shifted key")},
-   {"#1", 198		UNTIC_COMMENT("shifted key")},
-   {"#2", 199		UNTIC_COMMENT("Key S-Home")},
-   {"#3", 200		UNTIC_COMMENT("Key S-Insert")},
-   {"#4", 201		UNTIC_COMMENT("Key S-Left")},
-   {"%0", 177		UNTIC_COMMENT("redo key")},
-   {"%1", 168		UNTIC_COMMENT("help key")},
-   {"%2", 169		UNTIC_COMMENT("mark key")},
-   {"%3", 170		UNTIC_COMMENT("message key")},
-   {"%4", 171		UNTIC_COMMENT("move key")},
-   {"%5", 172		UNTIC_COMMENT("next key")},
-   {"%6", 173		UNTIC_COMMENT("open key")},
-   {"%7", 174		UNTIC_COMMENT("options key")},
-   {"%8", 175		UNTIC_COMMENT("previous key")},
-   {"%9", 176		UNTIC_COMMENT("print key")},
-   {"%a", 202		UNTIC_COMMENT("shifted key")},
-   {"%b", 203		UNTIC_COMMENT("shifted key")},
-   {"%c", 204		UNTIC_COMMENT("Key S-Next")},
-   {"%d", 205		UNTIC_COMMENT("shifted key")},
-   {"%e", 206		UNTIC_COMMENT("Key S-Previous")},
-   {"%f", 207		UNTIC_COMMENT("shifted key")},
-   {"%g", 208		UNTIC_COMMENT("shifted key")},
-   {"%h", 209		UNTIC_COMMENT("shifted key")},
-   {"%i", 210		UNTIC_COMMENT("Key S-Right")},
-   {"%j", 211		UNTIC_COMMENT("shifted key")},
-   {"&0", 187		UNTIC_COMMENT("shifted key")},
-   {"&1", 178		UNTIC_COMMENT("reference key")},
-   {"&2", 179		UNTIC_COMMENT("refresh key")},
-   {"&3", 180		UNTIC_COMMENT("replace key")},
-   {"&4", 181		UNTIC_COMMENT("restart key")},
-   {"&5", 182		UNTIC_COMMENT("resume key")},
-   {"&6", 183		UNTIC_COMMENT("save key")},
-   {"&7", 184		UNTIC_COMMENT("suspend key")},
-   {"&8", 185		UNTIC_COMMENT("undo key")},
-   {"&9", 186		UNTIC_COMMENT("shifted key")},
-   {"*0", 197		UNTIC_COMMENT("shifted key")},
-   {"*1", 188		UNTIC_COMMENT("shifted key")},
-   {"*2", 189		UNTIC_COMMENT("shifted key")},
-   {"*3", 190		UNTIC_COMMENT("shifted key")},
-   {"*4", 191		UNTIC_COMMENT("Key S-Delete")},
-   {"*5", 192		UNTIC_COMMENT("shifted key")},
-   {"*6", 193		UNTIC_COMMENT("select key")},
-   {"*7", 194		UNTIC_COMMENT("Key S-End")},
-   {"*8", 195		UNTIC_COMMENT("shifted key")},
-   {"*9", 196		UNTIC_COMMENT("shifted key")},
-   {"@0", 167		UNTIC_COMMENT("find key")},
-   {"@1", 158		UNTIC_COMMENT("begin key")},
-   {"@2", 159		UNTIC_COMMENT("cancel key")},
-   {"@3", 160		UNTIC_COMMENT("close key")},
-   {"@4", 161		UNTIC_COMMENT("command key")},
-   {"@5", 162		UNTIC_COMMENT("copy key")},
-   {"@6", 163		UNTIC_COMMENT("create key")},
-   {"@7", 164 		UNTIC_COMMENT("Key End")},
-   {"@8", 165		UNTIC_COMMENT("enter/send key")},
-   {"@9", 166		UNTIC_COMMENT("exit key")},
-   {"AB", 360 		UNTIC_COMMENT("set ANSI color background")},
-   {"AF", 359 		UNTIC_COMMENT("set ANSI color foreground")},
-   {"AL", 110 		UNTIC_COMMENT("parm_insert_line")},
-   {"CC", 9		UNTIC_COMMENT("terminal settable cmd character in prototype !?")},
-   {"CM", 15		UNTIC_COMMENT("memory relative cursor addressing")},
-   {"CW", 277		UNTIC_COMMENT("define a window #1 from #2, #3 to #4, #5")},
-   {"DC", 105		UNTIC_COMMENT("delete #1 chars")},
-   {"DI", 280		UNTIC_COMMENT("dial number #1")},
-   {"DK", 275		UNTIC_COMMENT("display clock at (#1,#2)")},
-   {"DL", 106 		UNTIC_COMMENT("parm_delete_line")},
-   {"DO", 107		UNTIC_COMMENT("down #1 lines")},
-   {"F1", 216		UNTIC_COMMENT("key_f11")},
-   {"F2", 217		UNTIC_COMMENT("key_f12")},
-   {"F3", 218		UNTIC_COMMENT("key_f13")},
-   {"F4", 219		UNTIC_COMMENT("key_f14")},
-   {"F5", 220		UNTIC_COMMENT("key_f15")},
-   {"F6", 221		UNTIC_COMMENT("key_f16")},
-   {"F7", 222		UNTIC_COMMENT("key_f17")},
-   {"F8", 223		UNTIC_COMMENT("key_f18")},
-   {"F9", 224		UNTIC_COMMENT("key_f19")},
-   {"FA", 225		UNTIC_COMMENT("key_f20")},
-   {"FB", 226		UNTIC_COMMENT("F21 function key")},
-   {"FC", 227		UNTIC_COMMENT("F22 function key")},
-   {"FD", 228		UNTIC_COMMENT("F23 function key")},
-   {"FE", 229		UNTIC_COMMENT("F24 function key")},
-   {"FF", 230		UNTIC_COMMENT("F25 function key")},
-   {"FG", 231		UNTIC_COMMENT("F26 function key")},
-   {"FH", 232		UNTIC_COMMENT("F27 function key")},
-   {"FI", 233		UNTIC_COMMENT("F28 function key")},
-   {"FJ", 234		UNTIC_COMMENT("F29 function key")},
-   {"FK", 235		UNTIC_COMMENT("F30 function key")},
-   {"FL", 236		UNTIC_COMMENT("F31 function key")},
-   {"FM", 237		UNTIC_COMMENT("F32 function key")},
-   {"FN", 238		UNTIC_COMMENT("F33 function key")},
-   {"FO", 239		UNTIC_COMMENT("F34 function key")},
-   {"FP", 240		UNTIC_COMMENT("F35 function key")},
-   {"FQ", 241		UNTIC_COMMENT("F36 function key")},
-   {"FR", 242		UNTIC_COMMENT("F37 function key")},
-   {"FS", 243		UNTIC_COMMENT("F38 function key")},
-   {"FT", 244		UNTIC_COMMENT("F39 function key")},
-   {"FU", 245		UNTIC_COMMENT("F40 function key")},
-   {"FV", 246		UNTIC_COMMENT("F41 function key")},
-   {"FW", 247		UNTIC_COMMENT("F42 function key")},
-   {"FX", 248		UNTIC_COMMENT("F43 function key")},
-   {"FY", 249		UNTIC_COMMENT("F44 function key")},
-   {"FZ", 250		UNTIC_COMMENT("F45 function key")},
-   {"Fa", 251		UNTIC_COMMENT("F46 function key")},
-   {"Fb", 252		UNTIC_COMMENT("F47 function key")},
-   {"Fc", 253		UNTIC_COMMENT("F48 function key")},
-   {"Fd", 254		UNTIC_COMMENT("F49 function key")},
-   {"Fe", 255		UNTIC_COMMENT("F50 function key")},
-   {"Ff", 256		UNTIC_COMMENT("F51 function key")},
-   {"Fg", 257		UNTIC_COMMENT("F52 function key")},
-   {"Fh", 258		UNTIC_COMMENT("F53 function key")},
-   {"Fi", 259		UNTIC_COMMENT("F54 function key")},
-   {"Fj", 260		UNTIC_COMMENT("F55 function key")},
-   {"Fk", 261		UNTIC_COMMENT("F56 function key")},
-   {"Fl", 262		UNTIC_COMMENT("F57 function key")},
-   {"Fm", 263		UNTIC_COMMENT("F58 function key")},
-   {"Fn", 264		UNTIC_COMMENT("F59 function key")},
-   {"Fo", 265		UNTIC_COMMENT("F60 function key")},
-   {"Fp", 266		UNTIC_COMMENT("F61 function key")},
-   {"Fq", 267		UNTIC_COMMENT("F62 function key")},
-   {"Fr", 268		UNTIC_COMMENT("F63 function key")},
-   {"G1", 400		UNTIC_COMMENT("single upper right")},
-   {"G2", 398		UNTIC_COMMENT("single upper left")},
-   {"G3", 399		UNTIC_COMMENT("single lower left")},
-   {"G4", 401		UNTIC_COMMENT("single lower right")},
-   {"GC", 408		UNTIC_COMMENT("single intersection")},
-   {"GD", 405		UNTIC_COMMENT("tee pointing down")},
-   {"GH", 406		UNTIC_COMMENT("single horizontal line")},
-   {"GL", 403		UNTIC_COMMENT("tee pointing left")},
-   {"GR", 402		UNTIC_COMMENT("tee pointing right")},
-   {"GU", 404		UNTIC_COMMENT("tee pointing up")},
-   {"GV", 407		UNTIC_COMMENT("single vertical line")},
-   {"Gm", 358		UNTIC_COMMENT("Curses should get button events")},
-   {"HU", 279		UNTIC_COMMENT("hang-up phone")},
-   {"IC", 108		UNTIC_COMMENT("insert #1 chars")},
-   {"Ic", 299		UNTIC_COMMENT("initialize color #1 to (#2,#3,#4)")},
-   {"Ip", 300		UNTIC_COMMENT("Initialize color pair #1 to fg=(#2,#3,#4), bg=(#5,#6,#7)")},
-   {"K1", 139		UNTIC_COMMENT("upper left of keypad")},
-   {"K2", 141		UNTIC_COMMENT("center of keypad")},
-   {"K3", 140		UNTIC_COMMENT("upper right of keypad")},
-   {"K4", 142		UNTIC_COMMENT("lower left of keypad")},
-   {"K5", 143		UNTIC_COMMENT("lower right of keypad")},
-   {"Km", 355		UNTIC_COMMENT("Mouse event has occurred")},
-   {"LE", 111		UNTIC_COMMENT("move #1 chars to the left")},
-   {"LF", 157		UNTIC_COMMENT("turn off soft labels")},
-   {"LO", 156		UNTIC_COMMENT("turn on soft labels")},
-   {"Lf", 273		UNTIC_COMMENT("label format")},
-   {"MC", 270		UNTIC_COMMENT("clear right and left soft margins")},
-   {"ML", 271		UNTIC_COMMENT("set left soft margin")},
-   {"ML", 368		UNTIC_COMMENT("Set both left and right margins to #1, #2")},
-   {"MR", 272		UNTIC_COMMENT("set right soft margin")},
-   {"MT", 369		UNTIC_COMMENT("Sets both top and bottom margins to #1, #2")},
-   {"Mi", 356		UNTIC_COMMENT("Mouse status information")},
-   {"PA", 285		UNTIC_COMMENT("pause for 2-3 seconds")},
-   {"PU", 283		UNTIC_COMMENT("select pulse dialling")},
-   {"QD", 281		UNTIC_COMMENT("dial number #1 without checking")},
-   {"RA", 152		UNTIC_COMMENT("turn off automatic margins")},
-   {"RC", 276		UNTIC_COMMENT("remove clock")},
-   {"RF", 215		UNTIC_COMMENT("send next input char (for ptys)")},
-   {"RI", 112 		UNTIC_COMMENT("parm_right_cursor")},
-   {"RQ", 357		UNTIC_COMMENT("Request mouse position")},
-   {"RX", 150		UNTIC_COMMENT("turn off xon/xoff handshaking")},
-   {"S1", 378		UNTIC_COMMENT("Display PC character")},
-   {"S2", 379		UNTIC_COMMENT("Enter PC character display mode")},
-   {"S3", 380		UNTIC_COMMENT("Exit PC character display mode")},
-   {"S4", 381		UNTIC_COMMENT("Enter PC scancode mode")},
-   {"S5", 382		UNTIC_COMMENT("Exit PC scancode mode")},
-   {"S6", 383		UNTIC_COMMENT("PC terminal options")},
-   {"S7", 384		UNTIC_COMMENT("Escape for scancode emulation")},
-   {"S8", 385		UNTIC_COMMENT("Alternate escape for scancode emulation")},
-   {"SA", 151		UNTIC_COMMENT("turn on automatic margins")},
-   {"SC", 274		UNTIC_COMMENT("set clock, #1 hrs #2 mins #3 secs")},
-   {"SF", 109		UNTIC_COMMENT("scroll forward #1 lines")},
-   {"SR", 113		UNTIC_COMMENT("scroll back #1 lines")},
-   {"SX", 149		UNTIC_COMMENT("turn on xon/xoff handshaking")},
-   {"Sb", 303 		UNTIC_COMMENT("set background (color)")},
-   {"Sf", 302 		UNTIC_COMMENT("set foreground (color)")},
-   {"TO", 282		UNTIC_COMMENT("select touch tone dialing")},
-   {"UP", 114		UNTIC_COMMENT("up #1 lines")},
-   {"WA", 286		UNTIC_COMMENT("wait for dial-tone")},
-   {"WG", 278		UNTIC_COMMENT("go to window #1")},
-   {"XF", 154		UNTIC_COMMENT("XOFF character")},
-   {"XN", 153		UNTIC_COMMENT("XON character")},
-   {"Xh", 386		UNTIC_COMMENT("Enter horizontal highlight mode")},
-   {"Xl", 387		UNTIC_COMMENT("Enter left highlight mode")},
-   {"Xo", 388		UNTIC_COMMENT("Enter low highlight mode")},
-   {"Xr", 389		UNTIC_COMMENT("Enter right highlight mode")},
-   {"Xt", 390		UNTIC_COMMENT("Enter top highlight mode")},
-   {"Xv", 391		UNTIC_COMMENT("Enter vertical highlight mode")},
-   {"Xy", 370		UNTIC_COMMENT("Repeat bit image cell #1 #2 times")},
-   {"YZ", 377		UNTIC_COMMENT("Set page length to #1 lines")},
-   {"Yv", 372		UNTIC_COMMENT("Move to beginning of same row")},
-   {"Yw", 373		UNTIC_COMMENT("Give name for color #1")},
-   {"Yx", 374		UNTIC_COMMENT("Define rectangualar bit image region")},
-   {"Yy", 375		UNTIC_COMMENT("End a bit-image region")},
-   {"Yz", 376		UNTIC_COMMENT("Change to ribbon color #1")},
-   {"ZA", 304		UNTIC_COMMENT("Change number of characters per inch")},
-   {"ZB", 305		UNTIC_COMMENT("Change number of lines per inch")},
-   {"ZC", 306		UNTIC_COMMENT("Change horizontal resolution")},
-   {"ZD", 307		UNTIC_COMMENT("Change vertical resolution")},
-   {"ZE", 308		UNTIC_COMMENT("Define a character")},
-   {"ZF", 309		UNTIC_COMMENT("Enter double-wide mode")},
-   {"ZG", 310		UNTIC_COMMENT("Enter draft-quality mode")},
-   {"ZH", 311		UNTIC_COMMENT("Enter italic mode")},
-   {"ZI", 312		UNTIC_COMMENT("Start leftward carriage motion")},
-   {"ZJ", 313		UNTIC_COMMENT("Start micro-motion mode")},
-   {"ZK", 314		UNTIC_COMMENT("Enter NLQ mode")},
-   {"ZL", 315		UNTIC_COMMENT("Wnter normal-quality mode")},
-   {"ZM", 316		UNTIC_COMMENT("Enter shadow-print mode")},
-   {"ZN", 317		UNTIC_COMMENT("Enter subscript mode")},
-   {"ZO", 318		UNTIC_COMMENT("Enter superscript mode")},
-   {"ZP", 319		UNTIC_COMMENT("Start upward carriage motion")},
-   {"ZQ", 320		UNTIC_COMMENT("End double-wide mode")},
-   {"ZR", 321		UNTIC_COMMENT("End italic mode")},
-   {"ZS", 322		UNTIC_COMMENT("End left-motion mode")},
-   {"ZT", 323		UNTIC_COMMENT("End micro-motion mode")},
-   {"ZU", 324		UNTIC_COMMENT("End shadow-print mode")},
-   {"ZV", 325		UNTIC_COMMENT("End subscript mode")},
-   {"ZW", 326		UNTIC_COMMENT("End superscript mode")},
-   {"ZX", 327		UNTIC_COMMENT("End reverse character motion")},
-   {"ZY", 328		UNTIC_COMMENT("Like column_address in micro mode")},
-   {"ZZ", 329		UNTIC_COMMENT("Like cursor_down in micro mode")},
-   {"Za", 330		UNTIC_COMMENT("Like cursor_left in micro mode")},
-   {"Zb", 331		UNTIC_COMMENT("Like cursor_right in micro mode")},
-   {"Zc", 332		UNTIC_COMMENT("Like row_address in micro mode")},
-   {"Zd", 333		UNTIC_COMMENT("Like cursor_up in micro mode")},
-   {"Ze", 334		UNTIC_COMMENT("Match software bits to print-head pins")},
-   {"Zf", 335		UNTIC_COMMENT("Like parm_down_cursor in micro mode")},
-   {"Zg", 336		UNTIC_COMMENT("Like parm_left_cursor in micro mode")},
-   {"Zh", 337		UNTIC_COMMENT("Like parm_right_cursor in micro mode")},
-   {"Zi", 338		UNTIC_COMMENT("Like parm_up_cursor in micro mode")},
-   {"Zj", 339		UNTIC_COMMENT("Select character set")},
-   {"Zk", 340		UNTIC_COMMENT("Set bottom margin at current line")},
-   {"Zl", 341		UNTIC_COMMENT("Set bottom margin at line #1 or #2 lines from bottom")},
-   {"Zm", 342		UNTIC_COMMENT("Set left (right) margin at column #1 (#2)")},
-   {"Zn", 343		UNTIC_COMMENT("Set right margin at column #1")},
-   {"Zo", 344		UNTIC_COMMENT("Set top margin at current line")},
-   {"Zp", 345		UNTIC_COMMENT("Set top (bottom) margin at row #1 (#2)")},
-   {"Zq", 346		UNTIC_COMMENT("Start printing bit image braphics")},
-   {"Zr", 347		UNTIC_COMMENT("Start character set definition")},
-   {"Zs", 348		UNTIC_COMMENT("Stop printing bit image graphics")},
-   {"Zt", 349		UNTIC_COMMENT("End definition of character aet")},
-   {"Zu", 350		UNTIC_COMMENT("List of subscriptable characters")},
-   {"Zv", 351		UNTIC_COMMENT("List of superscriptable characters")},
-   {"Zw", 352		UNTIC_COMMENT("Printing any of these chars causes CR")},
-   {"Zx", 353		UNTIC_COMMENT("No motion for subsequent character")},
-   {"Zy", 354		UNTIC_COMMENT("List of character set names")},
-   {"Zz", 371		UNTIC_COMMENT("Move to next row of the bit image")},
-   {"ac", 146 		UNTIC_COMMENT("acs_chars")},
-   {"ae", 38 		UNTIC_COMMENT("exit_alt_charset_mode")},
-   {"al", 53		UNTIC_COMMENT("insert line")},
-   {"as", 25 		UNTIC_COMMENT("enter_alt_charset_mode")},
-   {"bc", 395		UNTIC_COMMENT("move left, if not ^H")},
-   {"bl", 1		UNTIC_COMMENT("audible signal (bell)")},
-   {"bt", 0		UNTIC_COMMENT("back tab")},
-   {"bx", 411		UNTIC_COMMENT("box chars primary set")},
-   {"cb", 269		UNTIC_COMMENT("Clear to beginning of line")},
-   {"cd", 7		UNTIC_COMMENT("clear to end of screen")},
-   {"ce", 6 		UNTIC_COMMENT("clr_eol")},
-   {"ch", 8		UNTIC_COMMENT("horizontal position #1, absolute")},
-   {"ci", 363		UNTIC_COMMENT("Init sequence for multiple codesets")},
-   {"cl", 5		UNTIC_COMMENT("clear screen and home cursor")},
-   {"cm", 10		UNTIC_COMMENT("move to row #1 columns #2")},
-   {"cr", 2		UNTIC_COMMENT("carriage return")},
-   {"cs", 3		UNTIC_COMMENT("change region to line #1 to line #2")},
-   {"ct", 4		UNTIC_COMMENT("clear all tab stops")},
-   {"cv", 127		UNTIC_COMMENT("vertical position #1 absolute")},
-   {"dc", 21		UNTIC_COMMENT("delete character")},
-   {"dl", 22		UNTIC_COMMENT("delete line")},
-   {"dm", 29		UNTIC_COMMENT("enter delete mode")},
-   {"do", 11		UNTIC_COMMENT("down one line")},
-   {"ds", 23		UNTIC_COMMENT("disable status line")},
-   {"dv", 362		UNTIC_COMMENT("Indicate language/codeset support")},
-   {"eA", 155		UNTIC_COMMENT("enable alternate char set")},
-   {"ec", 37		UNTIC_COMMENT("erase #1 characters")},
-   {"ed", 41		UNTIC_COMMENT("end delete mode")},
-   {"ei", 42		UNTIC_COMMENT("exit insert mode")},
-   {"ff", 46		UNTIC_COMMENT("hardcopy terminal page eject")},
-   {"fh", 284		UNTIC_COMMENT("flash switch hook")},
-   {"fs", 47		UNTIC_COMMENT("return from status line")},
-   {"hd", 24		UNTIC_COMMENT("half a line down")},
-   {"ho", 12		UNTIC_COMMENT("home cursor (if no cup)")},
-   {"hu", 137		UNTIC_COMMENT("half a line up")},
-   {"i1", 48		UNTIC_COMMENT("initialization string")},
-   {"i2", 392		UNTIC_COMMENT("secondary initialization string")},
-   {"i3", 50		UNTIC_COMMENT("initialization string")},
-   {"iP", 138		UNTIC_COMMENT("path name of program for initialization")},
-   {"ic", 52		UNTIC_COMMENT("insert character")},
-   {"if", 51		UNTIC_COMMENT("name of initialization file")},
-   {"im", 31		UNTIC_COMMENT("enter insert mode")},
-   {"ip", 54		UNTIC_COMMENT("insert padding after inserted character")},
-   {"is", 49		UNTIC_COMMENT("initialization string")},
-   {"k0", 65		UNTIC_COMMENT("F0 function key")},
-   {"k1", 66		UNTIC_COMMENT("F1 function key")},
-   {"k2", 68		UNTIC_COMMENT("F2 function key")},
-   {"k3", 69		UNTIC_COMMENT("F3 function key")},
-   {"k4", 70		UNTIC_COMMENT("F4 function key")},
-   {"k5", 71		UNTIC_COMMENT("F5 function key")},
-   {"k6", 72		UNTIC_COMMENT("F6 function key")},
-   {"k7", 73		UNTIC_COMMENT("F7 function key")},
-   {"k8", 74		UNTIC_COMMENT("F8 fucntion key")},
-   {"k9", 75		UNTIC_COMMENT("F9 function key")},
-   {"k;", 67		UNTIC_COMMENT("F10 function key")},
-   {"kA", 78		UNTIC_COMMENT("insert-line key")},
-   {"kB", 148		UNTIC_COMMENT("back-tab key")},
-   {"kC", 57		UNTIC_COMMENT("clear-screen or erase key")},
-   {"kD", 59		UNTIC_COMMENT("delete-character key")},
-   {"kE", 63		UNTIC_COMMENT("clear-to-end-of-line key")},
-   {"kF", 84		UNTIC_COMMENT("scroll-forward key")},
-   {"kH", 80		UNTIC_COMMENT("last-line key")},
-   {"kI", 77		UNTIC_COMMENT("insert-character key")},
-   {"kL", 60		UNTIC_COMMENT("delete-line key")},
-   {"kM", 62		UNTIC_COMMENT("sent by rmir or smir in insert mode")},
-   {"kN", 81		UNTIC_COMMENT("next-page key")},
-   {"kP", 82		UNTIC_COMMENT("prev-page key")},
-   {"kR", 85		UNTIC_COMMENT("scroll-backward key")},
-   {"kS", 64		UNTIC_COMMENT("clear-to-end-of-screen key")},
-   {"kT", 86		UNTIC_COMMENT("set-tab key")},
-   {"ka", 56		UNTIC_COMMENT("clear-all-tabs key")},
-   {"kb", 55		UNTIC_COMMENT("backspace key")},
-   {"kd", 61		UNTIC_COMMENT("down-arrow key")},
-   {"ke", 88		UNTIC_COMMENT("leave 'keyboard_transmit' mode")},
-   {"kh", 76		UNTIC_COMMENT("home key")},
-   {"kl", 79		UNTIC_COMMENT("left-arrow key")},
-   {"ko", 396		UNTIC_COMMENT("list of self-mapped keycaps")},
-   {"kr", 83		UNTIC_COMMENT("right-arrow key")},
-   {"ks", 89		UNTIC_COMMENT("enter 'keyboard_transmit' mode")},
-   {"kt", 58		UNTIC_COMMENT("clear-tab key")},
-   {"ku", 87		UNTIC_COMMENT("up-arrow key")},
-   {"l0", 90		UNTIC_COMMENT("label on function key f0 if not f0")},
-   {"l1", 91		UNTIC_COMMENT("label on function key f1 if not f1")},
-   {"l2", 93		UNTIC_COMMENT("label on function key f2 if not f2")},
-   {"l3", 94		UNTIC_COMMENT("label on function key f3 if not f3")},
-   {"l4", 95		UNTIC_COMMENT("label on function key f4 if not f4")},
-   {"l5", 96		UNTIC_COMMENT("lable on function key f5 if not f5")},
-   {"l6", 97		UNTIC_COMMENT("label on function key f6 if not f6")},
-   {"l7", 98		UNTIC_COMMENT("label on function key f7 if not f7")},
-   {"l8", 99		UNTIC_COMMENT("label on function key f8 if not f8")},
-   {"l9", 100		UNTIC_COMMENT("label on function key f9 if not f9")},
-   {"la", 92		UNTIC_COMMENT("label on function key f10 if not f10")},
-   {"le", 14		UNTIC_COMMENT("move left one space")},
-   {"ll", 18		UNTIC_COMMENT("last line, first column (if no cup)")},
-   {"ma", 397		UNTIC_COMMENT("map arrow keys rogue(1) motion keys")},
-   {"mb", 26		UNTIC_COMMENT("turn on blinking")},
-   {"md", 27		UNTIC_COMMENT("turn on bold (extra bright) mode")},
-   {"me", 39		UNTIC_COMMENT("turn off all attributes")},
-   {"mh", 30		UNTIC_COMMENT("turn on half-bright mode")},
-   {"mk", 32		UNTIC_COMMENT("turn on blank mode (characters invisible)")},
-   {"ml", 409		UNTIC_COMMENT("memory lock above")},
-   {"mm", 102		UNTIC_COMMENT("turn on meta mode (8th-bit on)")},
-   {"mo", 101		UNTIC_COMMENT("turn off meta mode")},
-   {"mp", 33		UNTIC_COMMENT("turn on protected mode")},
-   {"mr", 34		UNTIC_COMMENT("turn on reverse video mode")},
-   {"mu", 410		UNTIC_COMMENT("memory unlock")},
-   {"nd", 17		UNTIC_COMMENT("move right one space")},
-   {"nl", 394		UNTIC_COMMENT("use to move down")},
-   {"nw", 103		UNTIC_COMMENT("newline (behave like cr followed by lf)")},
-   {"oc", 298		UNTIC_COMMENT("Set all color pairs to the original ones")},
-   {"op", 297		UNTIC_COMMENT("Set default pair to its original value")},
-   {"pO", 144		UNTIC_COMMENT("turn on printer for #1 bytes")},
-   {"pc", 104		UNTIC_COMMENT("padding char (instead of null)")},
-   {"pf", 119		UNTIC_COMMENT("turn off printer")},
-   {"pk", 115		UNTIC_COMMENT("program function key #1 to type string #2")},
-   {"pl", 116		UNTIC_COMMENT("program function key #1 to execute string #2")},
-   {"pn", 147		UNTIC_COMMENT("program label #1 to show string #2")},
-   {"po", 120		UNTIC_COMMENT("turn on printer")},
-   {"ps", 118		UNTIC_COMMENT("print contents of screen")},
-   {"px", 117		UNTIC_COMMENT("program function key #1 to transmit string #2")},
-   {"r1", 122		UNTIC_COMMENT("reset string")},
-   {"r2", 123		UNTIC_COMMENT("reset string")},
-   {"r3", 124		UNTIC_COMMENT("reset string")},
-   {"rP", 145		UNTIC_COMMENT("like ip but when in insert mode")},
-   {"rc", 126		UNTIC_COMMENT("restore cursor to last position of sc")},
-   {"rf", 125		UNTIC_COMMENT("name of reset file")},
-   {"rp", 121		UNTIC_COMMENT("repeat char #1 #2 times")},
-   {"rs", 393		UNTIC_COMMENT("terminal reset string")},
-   {"s0", 364		UNTIC_COMMENT("Shift to code set 0 (EUC set 0, ASCII)")},
-   {"s1", 365		UNTIC_COMMENT("Shift to code set 1")},
-   {"s2", 366		UNTIC_COMMENT("Shift to code set 2")},
-   {"s3", 367		UNTIC_COMMENT("Shift to code set 3")},
-   {"sa", 131		UNTIC_COMMENT("define video attributes #1-#9 (PG9)")},
-   {"sc", 128		UNTIC_COMMENT("save current cursor position")},
-   {"se", 43		UNTIC_COMMENT("exit standout mode")},
-   {"sf", 129		UNTIC_COMMENT("scroll text up")},
-   {"so", 35		UNTIC_COMMENT("begin standout mode")},
-   {"sp", 301		UNTIC_COMMENT("Set current color pair to #1")},
-   {"sr", 130		UNTIC_COMMENT("scroll text down")},
-   {"st", 132		UNTIC_COMMENT("set a tab in every row, current columns")},
-   {"ta", 134		UNTIC_COMMENT("tab to next 8-space hardware tab stop")},
-   {"te", 40		UNTIC_COMMENT("strings to end programs using cup")},
-   {"ti", 28		UNTIC_COMMENT("string to start programs using cup")},
-   {"ts", 135		UNTIC_COMMENT("move to status line")},
-   {"u0", 287		UNTIC_COMMENT("User string #0")},
-   {"u1", 288		UNTIC_COMMENT("User string #1")},
-   {"u2", 289		UNTIC_COMMENT("User string #2")},
-   {"u3", 290		UNTIC_COMMENT("User string #3")},
-   {"u4", 291		UNTIC_COMMENT("User string #4")},
-   {"u5", 292		UNTIC_COMMENT("User string #5")},
-   {"u6", 293		UNTIC_COMMENT("User string #6")},
-   {"u7", 294		UNTIC_COMMENT("User string #7")},
-   {"u8", 295		UNTIC_COMMENT("User string #8")},
-   {"u9", 296		UNTIC_COMMENT("User string #9")},
-   {"uc", 136		UNTIC_COMMENT("underline char and move past it")},
-   {"ue", 44		UNTIC_COMMENT("exit underline mode")},
-   {"up", 19		UNTIC_COMMENT("up one line")},
-   {"us", 36		UNTIC_COMMENT("begin underline mode")},
-   {"vb", 45		UNTIC_COMMENT("visible bell (may not move cursor)")},
-   {"ve", 16		UNTIC_COMMENT("make cursor appear normal (undo civis/cvvis)")},
-   {"vi", 13		UNTIC_COMMENT("make cursor invisible")},
-   {"vs", 20		UNTIC_COMMENT("make cursor very visible")},
-   {"wi", 133		UNTIC_COMMENT("current window is lines #1-#2 cols #3-#4")},
-   {"xl", 361		UNTIC_COMMENT("Program function key #1 to type string #2 and show string #3")},
-   {"", -1		UNTIC_COMMENT(NULL)}
-};
-
-static int compute_cap_offset (char *cap, SLterminfo_Type *t, Tgetstr_Map_Type *map, unsigned int max_ofs)
-{
-   char cha, chb;
-
-   (void) t;
-   cha = *cap++; chb = *cap;
-
-   while (*map->name != 0)
-     {
-	if ((cha == *map->name) && (chb == *(map->name + 1)))
-	  {
-	     if (map->offset >= (int) max_ofs) return -1;
-	     return map->offset;
-	  }
-	map++;
-     }
-   return -1;
-}
-
-char *_pSLtt_tigetstr (SLterminfo_Type *t, char *cap)
-{
-   int offset;
-
-   if (t == NULL)
-     return NULL;
-
-   if (t->flags == SLTERMCAP) return tcap_getstr (cap, t);
-
-   offset = compute_cap_offset (cap, t, Tgetstr_Map, t->num_string_offsets);
-   if (offset < 0) return NULL;
-   offset = make_integer (t->string_offsets + 2 * offset);
-   if (offset < 0) return NULL;
-   return t->string_table + offset;
-}
-
-static Tgetstr_Map_Type Tgetnum_Map[] =
-{
-   {"BT", 30		UNTIC_COMMENT("number of buttons on mouse")},
-   {"Co", 13		UNTIC_COMMENT("maximum numbers of colors on screen")},
-   {"MW", 12		UNTIC_COMMENT("maxumum number of defineable windows")},
-   {"NC", 15		UNTIC_COMMENT("video attributes that can't be used with colors")},
-   {"Nl", 8		UNTIC_COMMENT("number of labels on screen")},
-   {"Ya", 16		UNTIC_COMMENT("numbers of bytes buffered before printing")},
-   {"Yb", 17		UNTIC_COMMENT("spacing of pins vertically in pins per inch")},
-   {"Yc", 18		UNTIC_COMMENT("spacing of dots horizontally in dots per inch")},
-   {"Yd", 19		UNTIC_COMMENT("maximum value in micro_..._address")},
-   {"Ye", 20		UNTIC_COMMENT("maximum value in parm_..._micro")},
-   {"Yf", 21		UNTIC_COMMENT("character size when in micro mode")},
-   {"Yg", 22		UNTIC_COMMENT("line size when in micro mode")},
-   {"Yh", 23		UNTIC_COMMENT("numbers of pins in print-head")},
-   {"Yi", 24		UNTIC_COMMENT("horizontal resolution in units per line")},
-   {"Yj", 25		UNTIC_COMMENT("vertical resolution in units per line")},
-   {"Yk", 26		UNTIC_COMMENT("horizontal resolution in units per inch")},
-   {"Yl", 27		UNTIC_COMMENT("vertical resolution in units per inch")},
-   {"Ym", 28		UNTIC_COMMENT("print rate in chars per second")},
-   {"Yn", 29		UNTIC_COMMENT("character step size when in double wide mode")},
-   {"Yo", 31		UNTIC_COMMENT("number of passed for each bit-image row")},
-   {"Yp", 32		UNTIC_COMMENT("type of bit-image device")},
-   {"co", 0		UNTIC_COMMENT("number of columns in aline")},
-   {"dB", 36		UNTIC_COMMENT("padding required for ^H")},
-   {"dC", 34		UNTIC_COMMENT("pad needed for CR")},
-   {"dN", 35		UNTIC_COMMENT("pad needed for LF")},
-   {"dT", 37		UNTIC_COMMENT("padding required for ^I")},
-   {"it", 1		UNTIC_COMMENT("tabs initially every # spaces")},
-   {"kn", 38		UNTIC_COMMENT("count of function keys")},
-   {"lh", 9		UNTIC_COMMENT("rows in each label")},
-   {"li", 2		UNTIC_COMMENT("number of lines on screen or page")},
-   {"lm", 3		UNTIC_COMMENT("lines of memory if > line. 0 => varies")},
-   {"lw", 10		UNTIC_COMMENT("columns in each label")},
-   {"ma", 11		UNTIC_COMMENT("maximum combined attributes terminal can handle")},
-   {"pa", 14		UNTIC_COMMENT("maximum number of color-pairs on the screen")},
-   {"pb", 5		UNTIC_COMMENT("lowest baud rate where padding needed")},
-   {"sg", 4		UNTIC_COMMENT("number of blank chars left by smso or rmso")},
-   {"ug", 33		UNTIC_COMMENT("number of blanks left by ul")},
-   {"vt", 6		UNTIC_COMMENT("virtual terminal number (CB/unix)")},
-   {"ws", 7		UNTIC_COMMENT("columns in status line")},
-   {"", -1		UNTIC_COMMENT(NULL)}
-};
-
-int _pSLtt_tigetnum (SLterminfo_Type *t, char *cap)
-{
-   int offset;
-
-   if (t == NULL)
-     return -1;
-
-   if (t->flags == SLTERMCAP) return tcap_getnum (cap, t);
-
-   offset = compute_cap_offset (cap, t, Tgetnum_Map, t->num_numbers);
-   if (offset < 0) return -1;
-   return make_integer (t->numbers + 2 * offset);
-}
-
-static Tgetstr_Map_Type Tgetflag_Map[] =
-{
-   {"5i", 22		UNTIC_COMMENT("printer won't echo on screen")},
-   {"HC", 23		UNTIC_COMMENT("cursor is hard to see")},
-   {"MT", 40		UNTIC_COMMENT("has meta key")},
-   {"ND", 26		UNTIC_COMMENT("scrolling region is non-destructive")},
-   {"NL", 41		UNTIC_COMMENT("move down with \n")},
-   {"NP", 25		UNTIC_COMMENT("pad character does not exist")},
-   {"NR", 24		UNTIC_COMMENT("smcup does not reverse rmcup")},
-   {"YA", 30		UNTIC_COMMENT("only positive motion for hpa/mhpa caps")},
-   {"YB", 31		UNTIC_COMMENT("using cr turns off micro mode")},
-   {"YC", 32		UNTIC_COMMENT("printer needs operator to change character set")},
-   {"YD", 33		UNTIC_COMMENT("only positive motion for vpa/mvpa caps")},
-   {"YE", 34		UNTIC_COMMENT("printing in last column causes cr")},
-   {"YF", 35		UNTIC_COMMENT("changing character pitch changes resolution")},
-   {"YG", 36		UNTIC_COMMENT("changing line pitch changes resolution")},
-   {"am", 1		UNTIC_COMMENT("terminal has automatic margins")},
-   {"bs", 37		UNTIC_COMMENT("uses ^H to move left")},
-   {"bw", 0		UNTIC_COMMENT("cub1 wraps from column 0 to last column")},
-   {"cc", 27		UNTIC_COMMENT("terminal can re-define existing colors")},
-   {"da", 11		UNTIC_COMMENT("display may be retained above the screen")},
-   {"db", 12		UNTIC_COMMENT("display may be retained below the screen")},
-   {"eo", 5		UNTIC_COMMENT("can erase overstrikes with a blank")},
-   {"es", 16		UNTIC_COMMENT("escape can be used on the status line")},
-   {"gn", 6		UNTIC_COMMENT("generic line type")},
-   {"hc", 7		UNTIC_COMMENT("hardcopy terminal")},
-   {"hl", 29		UNTIC_COMMENT("terminal uses only HLS color notation (tektronix)")},
-   {"hs", 9		UNTIC_COMMENT("has extra status line")},
-   {"hz", 18		UNTIC_COMMENT("can't print ~'s (hazeltine)")},
-   {"in", 10		UNTIC_COMMENT("insert mode distinguishes nulls")},
-   {"km", 8		UNTIC_COMMENT("Has a meta key, sets msb high")},
-   {"mi", 13		UNTIC_COMMENT("safe to move while in insert mode")},
-   {"ms", 14		UNTIC_COMMENT("safe to move while in standout mode")},
-   {"nc", 39		UNTIC_COMMENT("no way to go to start of line")},
-   {"ns", 38		UNTIC_COMMENT("crt cannot scroll")},
-   {"nx", 21		UNTIC_COMMENT("padding won't work, xon/xoff required")},
-   {"os", 15		UNTIC_COMMENT("terminal can overstrike")},
-   {"pt", 42		UNTIC_COMMENT("has 8-char tabs invoked with ^I")},
-   {"ul", 19		UNTIC_COMMENT("underline character overstrikes")},
-   {"ut", 28		UNTIC_COMMENT("screen erased with background color")},
-   {"xb", 2		UNTIC_COMMENT("beehive (f1=escape, f2=ctrl C)")},
-   {"xn", 4		UNTIC_COMMENT("newline ignored after 80 cols (concept)")},
-   {"xo", 20		UNTIC_COMMENT("terminal uses xon/xoff handshaking")},
-   {"xr", 43		UNTIC_COMMENT("return clears the line")},
-   {"xs", 3		UNTIC_COMMENT("standout not erased by overwriting (hp)")},
-   {"xt", 17		UNTIC_COMMENT("tabs destructive, magic so char (t1061)")},
-   {"", -1		UNTIC_COMMENT(NULL)}
-};
-
-int _pSLtt_tigetflag (SLterminfo_Type *t, char *cap)
-{
-   int offset;
-
-   if (t == NULL) return -1;
-
-   if (t->flags == SLTERMCAP) return tcap_getflag (cap, t);
-
-   offset = compute_cap_offset (cap, t, Tgetflag_Map, t->boolean_section_size);
-
-   if (offset < 0) return -1;
-   return (int) *(t->boolean_flags + offset);
-}
-
-/* These are my termcap routines.  They only work with the TERMCAP environment
- * variable.  This variable must contain the termcap entry and NOT the file.
- */
-
-static int tcap_getflag (char *cap, SLterminfo_Type *t)
-{
-   char a, b;
-   char *f = (char *) t->boolean_flags;
-   char *fmax;
-
-   if (f == NULL) return 0;
-   fmax = f + t->boolean_section_size;
-
-   a = *cap;
-   b = *(cap + 1);
-   while (f < fmax)
-     {
-	if ((a == f[0]) && (b == f[1]))
-	  return 1;
-	f += 2;
-     }
-   return 0;
-}
-
-static char *tcap_get_cap (unsigned char *cap, unsigned char *caps, unsigned int len)
-{
-   unsigned char c0, c1;
-   unsigned char *caps_max;
-
-   c0 = cap[0];
-   c1 = cap[1];
-
-   if (caps == NULL) return NULL;
-   caps_max = caps + len;
-   while (caps < caps_max)
-     {
-	if ((c0 == caps[0]) && (c1 == caps[1]))
-	  {
-	     return (char *) caps + 3;
-	  }
-	caps += (int) caps[2];
-     }
-   return NULL;
-}
-
-static int tcap_getnum (char *cap, SLterminfo_Type *t)
-{
-   cap = tcap_get_cap ((unsigned char *) cap, t->numbers, t->num_numbers);
-   if (cap == NULL) return -1;
-   return atoi (cap);
-}
-
-static char *tcap_getstr (char *cap, SLterminfo_Type *t)
-{
-   return tcap_get_cap ((unsigned char *) cap, (unsigned char *) t->string_table, t->string_table_size);
-}
-
-static int tcap_extract_field (unsigned char *t0)
-{
-   register unsigned char ch, *t = t0;
-   while (((ch = *t) != 0) && (ch != ':')) t++;
-   if (ch == ':') return (int) (t - t0);
-   return -1;
-}
-
-int SLtt_Try_Termcap = 1;
-static int tcap_getent (char *term, SLterminfo_Type *ti)
-{
-   unsigned char *termcap, ch;
-   unsigned char *buf, *b;
-   unsigned char *t;
-   int len;
-
-   if (SLtt_Try_Termcap == 0) return -1;
-#if 1
-   /* XFREE86 xterm sets the TERMCAP environment variable to an invalid
-    * value.  Specifically, it lacks the tc= string.
-    */
-   if (!strncmp (term, "xterm", 5))
-     return -1;
-#endif
-   termcap = (unsigned char *) getenv ("TERMCAP");
-   if ((termcap == NULL) || (*termcap == '/')) return -1;
-
-   /* SUN Solaris 7&8 have bug in tset program under tcsh,
-    * eval `tset -s -A -Q` sets value of TERMCAP to ":",
-    *  under other shells it works fine.
-    *  SUN was informed, they marked it as duplicate of bug 4086585
-    *  but didn't care to fix it... <mikkopa@cs.tut.fi> 
-    */
-   if ((termcap[0] == ':') && (termcap[1] == 0))
-     return -1;
-   
-   
-   /* We have a termcap so lets use it provided it does not have a reference
-    * to another terminal via tc=.  In that case, use terminfo.  The alternative
-    * would be to parse the termcap file which I do not want to do right now.
-    * Besides, this is a terminfo based system and if the termcap were parsed
-    * terminfo would almost never get a chance to run.  In addition, the tc=
-    * thing should not occur if tset is used to set the termcap entry.
-    */
-   t = termcap;
-   while ((len = tcap_extract_field (t)) != -1)
-     {
-	if ((len > 3) && (t[0] == 't') && (t[1] == 'c') && (t[2] == '='))
-	  return -1;
-	t += (len + 1);
-     }
-
-   /* malloc some extra space just in case it is needed. */
-   len = strlen ((char *) termcap) + 256;
-   if (NULL == (buf = (unsigned char *) SLmalloc ((unsigned int) len))) 
-     return -1;
-
-   b = buf;
-
-   /* The beginning of the termcap entry contains the names of the entry.
-    * It is terminated by a colon.
-    */
-
-   ti->terminal_names = (char *) b;
-   t = termcap;
-   len = tcap_extract_field (t);
-   if (len < 0)
-     {
-	SLfree ((char *)buf);
-	return -1;
-     }
-   strncpy ((char *) b, (char *) t, (unsigned int) len);
-   b[len] = 0;
-   b += len + 1;
-   ti->name_section_size = len;
-
-   /* Now, we are really at the start of the termcap entries.  Point the
-    * termcap variable here since we want to refer to this a number of times.
-    */
-   termcap = t + (len + 1);
-
-   /* Process strings first. */
-   ti->string_table = (char *) b;
-   t = termcap;
-   while (-1 != (len = tcap_extract_field (t)))
-     {
-	unsigned char *b1;
-	unsigned char *tmax;
-
-	/* We are looking for: XX=something */
-	if ((len < 4) || (t[2] != '=') || (*t == '.'))
-	  {
-	     t += len + 1;
-	     continue;
-	  }
-	tmax = t + len;
-	b1 = b;
-
-	while (t < tmax)
-	  {
-	     ch = *t++;
-	     if ((ch == '\\') && (t < tmax))
-	       {
-		  SLwchar_Type wch;
-
-		  t = (unsigned char *) _pSLexpand_escaped_char ((char *) t, &wch, NULL);
-		  if (t == NULL)
-		    {
-		       SLfree ((char *)buf);
-		       return -1;
-		    }
-		  ch = (char) wch;
-	       }
-	     else if ((ch == '^') && (t < tmax))
-	       {
-		  ch = *t++;
-		  if (ch == '?') ch = 127;
-		  else ch = (ch | 0x20) - ('a' - 1);
-	       }
-	     *b++ = ch;
-	  }
-	/* Null terminate it. */
-	*b++ = 0;
-	len = (int) (b - b1);
-	b1[2] = (unsigned char) len;    /* replace the = by the length */
-	/* skip colon to next field. */
-	t++;
-     }
-   ti->string_table_size = (int) (b - (unsigned char *) ti->string_table);
-
-   /* Now process the numbers. */
-
-   t = termcap;
-   ti->numbers = b;
-   while (-1 != (len = tcap_extract_field (t)))
-     {
-	unsigned char *b1;
-	unsigned char *tmax;
-
-	/* We are looking for: XX#NUMBER */
-	if ((len < 4) || (t[2] != '#') || (*t == '.'))
-	  {
-	     t += len + 1;
-	     continue;
-	  }
-	tmax = t + len;
-	b1 = b;
-
-	while (t < tmax)
-	  {
-	     *b++ = *t++;
-	  }
-	/* Null terminate it. */
-	*b++ = 0;
-	len = (int) (b - b1);
-	b1[2] = (unsigned char) len;    /* replace the # by the length */
-	t++;
-     }
-   ti->num_numbers = (int) (b - ti->numbers);
-
-   /* Now process the flags. */
-   t = termcap;
-   ti->boolean_flags = b;
-   while (-1 != (len = tcap_extract_field (t)))
-     {
-	/* We are looking for: XX#NUMBER */
-	if ((len != 2) || (*t == '.') || (*t <= ' '))
-	  {
-	     t += len + 1;
-	     continue;
-	  }
-	b[0] = t[0];
-	b[1] = t[1];
-	t += 3;
-	b += 2;
-     }
-   ti->boolean_section_size = (int) (b - ti->boolean_flags);
-   ti->flags = SLTERMCAP;
-   return 0;
-}
-
-
-/* These routines are provided only for backward binary compatability.
- * They will vanish in V2.x
- */
-char *SLtt_tigetent (char *s)
-{
-   return (char *) _pSLtt_tigetent (s);
-}
-
-extern char *SLtt_tigetstr (char *s, char **p)
-{
-   if (p == NULL)
-     return NULL;
-   return _pSLtt_tigetstr ((SLterminfo_Type *) *p, s);
-}
-
-extern int SLtt_tigetnum (char *s, char **p)
-{
-   if (p == NULL)
-     return -1;
-   return _pSLtt_tigetnum ((SLterminfo_Type *) *p, s);
-}
-
-
diff --git a/slang/slupper.c b/slang/slupper.c
deleted file mode 100644
index c493d72..0000000
--- a/slang/slupper.c
+++ /dev/null
@@ -1,18 +0,0 @@
-#include "slinclud.h"
-#include <ctype.h>
-
-#include "slang.h"
-#include "_slang.h"
-
-#define DEFINE_PSLWC_TOUPPER_TABLE
-#include "slupper.h"
-
-
-#define MODE_VARIABLE _pSLinterp_UTF8_Mode
-SLwchar_Type SLwchar_toupper (SLwchar_Type ch)
-{
-   if (MODE_VARIABLE)
-     return ch + SL_TOUPPER_LOOKUP(ch);
-
-   return toupper (ch);
-}
diff --git a/slang/slutf8.c b/slang/slutf8.c
deleted file mode 100644
index d932339..0000000
--- a/slang/slutf8.c
+++ /dev/null
@@ -1,841 +0,0 @@
-#include "slinclud.h"
-#include <string.h>
-
-#include "slang.h"
-#include "_slang.h"
-
-static unsigned char Len_Map[256] =
-{
-  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,  /* - 31 */
-  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,  /* - 63 */
-  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,  /* - 95 */
-  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,  /* - 127 */
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* - 159 */
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  /* - 191 */
-  2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,  /* - 223 */
-  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1   /* - 255 */
-};
-
-/*
- * Also note that the code positions U+D800 to U+DFFF (UTF-16 surrogates)
- * as well as U+FFFE and U+FFFF must not occur in normal UTF-8 or UCS-4
- * data. UTF-8 decoders should treat them like malformed or overlong
- * sequences for safety reasons.
- */
-#define IS_ILLEGAL_UNICODE(w) \
-   (((w >= 0xD800) && (w <= 0xDFFF)) || (w == 0xFFFE) || (w == 0xFFFF))
-
-_INLINE_ 
-static int is_invalid_or_overlong_utf8 (SLuchar_Type *u, unsigned int len)
-{
-   unsigned int i;
-   unsigned char ch, ch1;
-
-   /* Check for invalid sequences */
-   for (i = 1; i < len; i++)
-     {
-	if ((u[i] & 0xC0) != 0x80)
-	  return 1;
-     }
-
-   /* Illegal (overlong) sequences */  
-   /*           1100000x (10xxxxxx) */
-   /*           11100000 100xxxxx (10xxxxxx) */
-   /*           11110000 1000xxxx (10xxxxxx 10xxxxxx) */
-   /*           11111000 10000xxx (10xxxxxx 10xxxxxx 10xxxxxx) */
-   /*           11111100 100000xx (10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx) */
-   ch = *u;
-   if ((ch == 0xC0) || (ch == 0xC1))
-     return 1;
-
-   ch1 = u[1];
-   if (((ch1 & ch) == 0x80)
-       && ((ch == 0xE0)
-	   || (ch == 0xF0)
-	   || (ch == 0xF8)
-	   || (ch == 0xFC)))
-     return 1;
-
-   if (len == 3)
-     {
-	/* D800 is encoded as 0xED 0xA0 0x80 and DFFF as 0xED 0xBF 0xBF */
-	if ((ch == 0xED)
-	    && ((ch1 >= 0xA0) && (ch1 <= 0xBF))
-	    && (u[2] >= 0x80) && (u[2] <= 0xBF))
-	  return 1;
-	/* Now FFFE and FFFF */
-	if ((ch == 0xEF)
-	    && (ch1 == 0xBF)
-	    && ((u[2] == 0xBE) || (u[2] == 0xBF)))
-	  return 1;
-     }
-   return 0;
-}
-
-/* This function assumes that the necessary checks have been made to ensure
- * a valid UTF-8 encoded character is present. 
- */
-_INLINE_
-static SLwchar_Type fast_utf8_decode (SLuchar_Type *u, unsigned int len)
-{
-   static unsigned char masks[7] =
-     {
-	0, 0, 0x1F, 0xF, 0x7, 0x3, 0x1
-     };
-   SLuchar_Type *umax;
-   SLwchar_Type w;
-
-   w = (*u & masks[len]);
-   umax = u + len;
-   u++;
-   while (u < umax)
-     {
-	w = (w << 6)| (u[0] & 0x3F);
-	u++;
-     }
-   return w;
-}
-
-unsigned char *SLutf8_skip_char (unsigned char *s, unsigned char *smax)
-{
-   unsigned int len;
-   
-   if (s >= smax)
-     return s;
-
-   len = Len_Map[*s];
-   if (len <= 1)
-     return s+1;
-
-   if (s + len > smax)
-     return s+1;
-   
-   if (is_invalid_or_overlong_utf8 (s, len))
-     return s + 1;
-   
-   return s + len;
-}
-
-SLuchar_Type *SLutf8_skip_chars (SLuchar_Type *s, SLuchar_Type *smax,
-				  unsigned int num, unsigned int *dnum,
-				  int ignore_combining)
-{
-   unsigned int n;
-
-   n = 0;
-   while ((n < num) && (s < smax))
-     {
-	unsigned int len = Len_Map[*s];
-
-	if (len <= 1)
-	  {
-	     n++;
-	     s++;
-	     continue;
-	  }
-
-	if (s + len > smax)
-	  {
-	     s++;
-	     n++;
-	     continue;
-	  }
-
-	if (is_invalid_or_overlong_utf8 (s, len))
-	  {
-	     s++;
-	     n++;
-	     continue;
-	  }
-	
-	if (ignore_combining)
-	  {
-	     SLwchar_Type w = fast_utf8_decode (s, len);
-	     if (0 != SLwchar_wcwidth (w))
-	       n++;
-	     s += len;
-	     continue;
-	  }
-
-	n++;
-	s += len;
-     }
-
-   if (ignore_combining)
-     {
-	while (s < smax)
-	  {
-	     SLwchar_Type w;
-	     unsigned int nconsumed;
-	     if (NULL == SLutf8_decode (s, smax, &w, &nconsumed))
-	       break;
-	     
-	     if (0 != SLwchar_wcwidth (w))
-	       break;
-	     
-	     s += nconsumed;
-	  }
-     }
-
-   if (dnum != NULL)
-     *dnum = n;
-   return s;
-}
-
-
-SLuchar_Type *SLutf8_bskip_chars (SLuchar_Type *smin, SLuchar_Type *s,
-				   unsigned int num, unsigned int *dnum,
-				   int ignore_combining)
-{
-   unsigned int n;
-   SLuchar_Type *smax = s;
-
-   n = 0;
-   while ((n < num) && (s > smin))
-     {
-	unsigned char ch;
-	unsigned int dn;
-
-	s--;
-	ch = *s;
-	if (ch < 0x80)
-	  {
-	     n++;
-	     smax = s;
-	     continue;
-	  }
-	
-	dn = 0;
-	while ((s != smin) 
-	       && (Len_Map[ch] == 0)
-	       && (dn < SLUTF8_MAX_MBLEN))
-	  {
-	     s--;
-	     ch = *s;
-	     dn++;
-	  }
-
-	if (ch <= 0xBF)
-	  {
-	     /* Invalid sequence */
-	     n++;
-	     smax--;
-	     s = smax;
-	     continue;
-	  }
-
-	if (ch > 0xBF)
-	  {
-	     SLwchar_Type w;
-	     SLuchar_Type *s1;
-
-	     if ((NULL == (s1 = SLutf8_decode (s, smax, &w, NULL)))
-		 || (s1 != smax))
-	       {
-		  /* This means we backed up over an invalid sequence */
-		  dn = (unsigned int) (smax - s);
-		  n++;
-		  smax--;
-		  s = smax;
-		  continue;
-	       }
-	     
-	     if ((ignore_combining == 0) 
-		 || (0 != SLwchar_wcwidth (w)))
-	       n++;
-
-	     smax = s;
-	  }
-     }
-
-   if (dnum != NULL)
-     *dnum = n;
-   return s;
-}
-
-SLuchar_Type *SLutf8_bskip_char (SLuchar_Type *smin, SLuchar_Type *s)
-{
-   if (s > smin)
-     {
-	unsigned int dn;
-
-	s--;
-	if (*s >= 0x80)
-	  s = SLutf8_bskip_chars (smin, s+1, 1, &dn, 0);
-     }
-   return s;
-}
-
-
-/* This function counts the number of wide characters in a UTF-8 encoded
- * string.  Each byte in an invalid sequence is counted as a single character.
- * If the string contains illegal values, the bytes making up the character is
- * counted as 1 character.
- */
-unsigned int SLutf8_strlen (SLuchar_Type *s, int ignore_combining)
-{
-   unsigned int count, len;
-   
-   if (s == NULL)
-     return 0;
-
-   len = strlen ((char *)s);
-   (void) SLutf8_skip_chars (s, s + len, len, &count, ignore_combining);
-   return count;
-}
-
-
-/*
- * This function returns NULL if the input does not correspond to a valid
- * UTF-8 sequence, otherwise, it returns the position of the next character
- * in the sequence.
- */
-unsigned char *SLutf8_decode (unsigned char *u, unsigned char *umax,
-			      SLwchar_Type *wp, unsigned int *nconsumedp)
-{
-   unsigned int len;
-   unsigned char ch;
-   SLwchar_Type w;
-
-   if (u >= umax)
-     {
-	*wp = 0;
-	if (nconsumedp != NULL)
-	  *nconsumedp = 0;
-	return NULL;
-     }
-
-   *wp = ch = *u;
-   if (ch < 0x80)
-     {
-	if (nconsumedp != NULL) *nconsumedp = 1;
-	return u+1;
-     }
-   
-   len = Len_Map[ch];
-   if (len < 2)
-     {
-	/* should not happen--- code here for completeness */
-	if (nconsumedp != NULL) *nconsumedp = 1;
-	return NULL;
-     }
-   if (u + len > umax)
-     {
-	if (nconsumedp != NULL) *nconsumedp = 1; /* (unsigned int) (umax - u); */
-	return NULL;
-     }
-
-   if (is_invalid_or_overlong_utf8 (u, len))
-     {
-	if (nconsumedp != NULL)
-	  *nconsumedp = 1;
-	
-	return NULL;
-     }
-
-   if (nconsumedp != NULL) 
-     *nconsumedp = len;
-
-   *wp = w = fast_utf8_decode (u, len);
-
-   if (IS_ILLEGAL_UNICODE(w))
-     return NULL;
-
-   return u + len;
-}
-
-
-/* Encode the wide character returning a pointer to the end of the 
- * utf8 of the encoded multi-byte character.  This function will also encode
- * illegal unicode values.  It returns NULL if buflen is too small. 
- * Otherwise, it returns a pointer at the end of the last encoded byte.
- * It does not null terminate the encoded string.
- */
-SLuchar_Type *SLutf8_encode (SLwchar_Type w, SLuchar_Type *u, unsigned int ulen)
-{
-   SLuchar_Type *umax = u + ulen;
-   
-   /*   U-00000000 - U-0000007F: 0xxxxxxx */
-   if (w <= 0x7F)
-     {
-	if (u >= umax)
-	  return NULL;
-
-	*u++ = (unsigned char) w;
-	return u;
-     }
-
-   /*   U-00000080 - U-000007FF: 110xxxxx 10xxxxxx */
-   if (w <= 0x7FF)
-     {
-	if ((u + 1) >= umax)
-	  return NULL;
-
-	*u++ = (w >> 6) | 0xC0;
-	*u++ = (w & 0x3F) | 0x80;
-	return u;
-     }
-
-   /* First bad character starts at 0xD800 */
-
-   /* Allow illegal values to be encoded */
-
-   /*
-    *if (IS_ILLEGAL_UNICODE(w))
-    * return NULL;
-    */
-
-   /*   U-00000800 - U-0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx */
-   if (w <= 0xFFFF)
-     {
-	if (u+2 >= umax) 
-	  return NULL;
-	*u++ = (w >> 12 ) | 0xE0;
-	goto finish_2;
-     }
-   
-   /*   U-00010000 - U-001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
-   if (w <= 0x1FFFFF)
-     {
-	if (u+3 >= umax)
-	  return NULL;
-	*u++ = (w >> 18) | 0xF0;
-	goto finish_3;
-     }
-
-   /*   U-00200000 - U-03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx */
-   if (w <= 0x3FFFFFF)
-     {
-	if (u+4 >= umax)
-	  return NULL;
-	*u++ = (w >> 24) | 0xF8;
-	goto finish_4;
-     }
-   
-   /*   U-04000000 - U-7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx */
-   if (w <= 0x7FFFFFFF)
-     {
-	if (u+5 >= umax)
-	  return NULL;
-	*u++ = (w >> 30) | 0xFC;
-	goto finish_5;
-     }
-
-   /* unreached?? */
-   return NULL;
-
-   finish_5: *u++ = ((w >> 24) & 0x3F)|0x80;
-   finish_4: *u++ = ((w >> 18) & 0x3F)|0x80;
-   finish_3: *u++ = ((w >> 12) & 0x3F)|0x80;
-   finish_2: *u++ = ((w >> 6) & 0x3F)|0x80;
-             *u++ = (w & 0x3F)|0x80;
-   
-   return u;
-}
-
-/* Like SLutf8_encode, but null terminates the result.  
- * At least SLUTF8_MAX_MBLEN+1 bytes assumed.
- */
-SLuchar_Type *SLutf8_encode_null_terminate (SLwchar_Type w, SLuchar_Type *u)
-{
-   SLuchar_Type *p;
-   
-   p = SLutf8_encode (w, u, SLUTF8_MAX_MBLEN);
-   if (p != NULL)
-     *p = 0;
-   return p;
-}
-
-#if 0
-int SLutf8_decode_bytes (SLuchar_Type *u, SLuchar_Type *umax,
-			 unsigned char *b, unsigned int *np)
-{
-   unsigned char *bmax;
-
-   bmax = b;
-   while (u < umax)
-     {
-	SLwchar_Type w;
-
-	if (0 == (*u & 0x80))
-	  {
-	     *bmax++ = *u++;
-	     continue;
-	  }
-	
-	if (NULL == (u = SLutf8_decode (u, umax, &w, NULL)))
-	  return -1;		       /* FIXME: HANDLE ERROR */
-	
-	if (w > 0xFF)
-	  { 
-#if 0
-	     sprintf (bmax, "<U+%04X>", w);
-	     bmax += strlen (bmax);
-	     continue;
-#endif
-	     /* FIXME: HANDLE ERROR */
-	     w = w & 0xFF;
-	  }
-	
-	*bmax++ = w;
-     }
-   *np = bmax - b;
-   *bmax = 0;
-   return 0;
-}
-
-/* UTF-8 Encode the bytes between b and bmax storing the results in the
- * buffer defined by u and umax, returning the position following the 
- * last encoded character.  Upon return, *np is set to the number of bytes
- * sucessfully encoded.
- */
-SLuchar_Type *SLutf8_encode_bytes (unsigned char *b, unsigned char *bmax,
-				   SLuchar_Type *u, unsigned int ulen, 
-				   unsigned int *np)
-{
-   unsigned char *bstart = b;
-   SLuchar_Type *umax = u + ulen;
-
-   while (b < bmax)
-     {
-	SLuchar_Type *u1;
-
-	if (0 == (*b & 0x80))
-	  {
-	     if (u >= umax)
-	       break;
-	     
-	     *u++ = *b++;
-	     continue;
-	  }
-
-	if (NULL == (u1 = SLutf8_encode (*b, u, umax - u)))
-	  break;
-	u = u1;
-	b++;
-     }
-
-   *np = b - bstart;
-   if (u < umax)
-     *u = 0;
-
-   return u;
-}
-#endif
-
-static SLuchar_Type *xform_utf8 (SLuchar_Type *u, SLuchar_Type *umax,
-                                 SLwchar_Type (*fun)(SLwchar_Type))
-{
-   SLuchar_Type *buf, *p;
-   unsigned int malloced_len, len;
-
-   if (umax < u)
-     return NULL;
-   
-   len = 0;
-   p = buf = NULL;
-   malloced_len = 0;
-
-   while (1)
-     {
-        SLwchar_Type w;
-        SLuchar_Type *u1;
-        unsigned int nconsumed;
-
-        if (malloced_len <= len + SLUTF8_MAX_MBLEN)
-          {
-             SLuchar_Type *newbuf;
-             malloced_len += 1 + (umax - u) + SLUTF8_MAX_MBLEN;
-             
-             newbuf = (SLuchar_Type *)SLrealloc ((char *)buf, malloced_len);
-             if (newbuf == NULL)
-               {
-                  SLfree ((char *)buf);
-                  return NULL;
-               }
-             buf = newbuf;
-             p = buf + len;
-          }
-
-        if (u >= umax)
-          {
-             *p = 0;
-             p = (SLuchar_Type *) SLang_create_nslstring ((char *)buf, len);
-             SLfree ((char *)buf);
-             return p;
-          }
-
-        if (NULL == (u1 = SLutf8_decode (u, umax, &w, &nconsumed)))
-          {
-             /* Invalid sequence */
-             memcpy ((char *) p, u, nconsumed);
-             p += nconsumed;
-             len += nconsumed;
-             u1 = u + nconsumed;
-          }
-        else
-          {
-             SLuchar_Type *p1;
-
-             p1 = SLutf8_encode ((*fun)(w), p, malloced_len);
-             if (p1 == NULL)
-               {
-                  SLfree ((char *)buf);
-                  SLang_verror (SL_INTERNAL_ERROR, "SLutf8_encode returned NULL");
-                  return NULL;
-               }
-             len += p1 - p;
-             p = p1;
-          }
-        
-        u = u1;
-     }
-}
-
-/* Returned an uppercased version of an UTF-8 encoded string.  Illegal or
- * invalid sequences will be returned as-is.  This function returns 
- * an SLstring.
- */
-SLuchar_Type *SLutf8_strup (SLuchar_Type *u, SLuchar_Type *umax)
-{
-   return xform_utf8 (u, umax, SLwchar_toupper);
-}
-
-/* Returned an lowercased version of an UTF-8 encoded string.  Illegal or
- * invalid sequences will be returned as-is.  This function returns 
- * an SLstring.
- */
-SLuchar_Type *SLutf8_strlo (SLuchar_Type *u, SLuchar_Type *umax)
-{
-   return xform_utf8 (u, umax, SLwchar_tolower);
-}
-
-int SLutf8_compare (SLuchar_Type *a, SLuchar_Type *amax, 
-                    SLuchar_Type *b, SLuchar_Type *bmax,
-                    unsigned int nchars,
-                    int cs)
-{
-   while (nchars && (a < amax) && (b < bmax))
-     {
-        SLwchar_Type cha, chb;
-        unsigned int na, nb;
-        int aok, bok;
-
-        if (*a < 0x80)
-          {
-             cha = (SLwchar_Type) *a++;
-             aok = 1;
-          }
-        else
-          {
-             aok = (NULL != SLutf8_decode (a, amax, &cha, &na));
-             a += na;
-          }
-
-        if (*b < 0x80)
-          {
-             chb = (SLwchar_Type) *b++;
-             bok = 1;
-          }
-        else
-          {
-             bok = (NULL != SLutf8_decode (b, bmax, &chb, &nb));
-             b += nb;
-          }
-
-        nchars--;
-
-        if (aok && bok)
-          {
-             if (cs == 0)
-               {
-                  cha = SLwchar_toupper (cha);
-                  chb = SLwchar_toupper (chb);
-               }
-          }
-        else if (aok)
-          return 1;
-        else if (bok)
-          return -1;
-        
-        if (cha == chb)
-          continue;
-        
-        if (cha > chb)
-          return 1;
-
-        return -1;
-     }
-
-   if (nchars == 0)
-     return 0;
-
-   if ((a >= amax) && (b >= bmax))
-     return 0;
-   
-   if (b >= bmax)
-     return 1;
-   
-   return -1;
-}
-
-
-/* Returns an SLstring */
-SLstr_Type *SLutf8_subst_wchar (SLuchar_Type *u, SLuchar_Type *umax,
-				SLwchar_Type wch, unsigned int pos,
-				int ignore_combining)
-{
-   SLuchar_Type *a, *a1, *b;
-   unsigned int dpos;
-   SLuchar_Type buf[SLUTF8_MAX_MBLEN+1];
-   SLstr_Type *c;
-   unsigned int n1, n2, n3, len;
-
-   a = SLutf8_skip_chars (u, umax, pos, &dpos, ignore_combining);
-
-   if ((dpos != pos) || (a == umax))
-     {
-	SLang_verror (SL_INDEX_ERROR, "Specified character position is invalid for string");
-	return NULL;
-     }
-
-   a1 = SLutf8_skip_chars (a, umax, 1, NULL, ignore_combining);
-   
-   b = SLutf8_encode (wch, buf, SLUTF8_MAX_MBLEN);
-   if (b == NULL)
-     {
-	SLang_verror (SL_UNICODE_ERROR, "Unable to encode wchar 0x%lX", (unsigned long)wch);
-	return NULL;
-     }
-   
-   n1 = (a-u);
-   n2 = (b-buf);
-   n3 = (umax-a1);
-   len = n1 + n2 + n3;
-   c = _pSLallocate_slstring (len);
-   if (c == NULL)
-     return NULL;
-   
-   memcpy (c, (char *)u, n1);
-   memcpy (c+n1, (char *)buf, n2);
-   memcpy (c+n1+n2, (char *)a1, n3);
-   c[len] = 0;
-
-   /* No need to worry about this failing-- it frees its argument */
-   return _pSLcreate_via_alloced_slstring (c, len);
-}
-
-   
-/* utf8 buffer assumed to be at least SLUTF8_MAX_MBLEN+1 bytes.  Result will be
- * null terminated.   Returns position of NEXT character.
- * Analogous to: *p++
- */
-SLuchar_Type *SLutf8_extract_utf8_char (SLuchar_Type *u,
-					SLuchar_Type *umax, 
-					SLuchar_Type *utf8)
-{
-   SLuchar_Type *u1;
-   
-   u1 = SLutf8_skip_char (u, umax);
-   memcpy ((char *)utf8, u, u1-u);
-   utf8[u1-u] = 0;
-   
-   return u1;
-}
-   
-   
-
-/* These routines depend upon the value of the _pSLinterp_UTF8_Mode variable.
- * They also generate slang errors upon error.
- */
-SLuchar_Type *_pSLinterp_decode_wchar (SLuchar_Type *u, 
-				      SLuchar_Type *umax, 
-				      SLwchar_Type *chp)
-{
-   if (_pSLinterp_UTF8_Mode == 0)
-     {
-	if (u < umax)
-	  *chp = (SLwchar_Type) *u++;
-	return u;
-     }
-
-   if (NULL == (u = SLutf8_decode (u, umax, chp, NULL)))
-     SLang_verror (SL_INVALID_UTF8, "Invalid UTF-8 encoded string");
-   
-   return u;
-}
-
-/* At least SLUTF8_MAX_MBLEN+1 bytes assumed-- null terminates result.
- * Upon success, it returns a pointer to the _end_ of the encoded character
- */
-SLuchar_Type *_pSLinterp_encode_wchar (SLwchar_Type wch, SLuchar_Type *u, unsigned int *encoded_len)
-{
-   SLuchar_Type *u1;
-
-   if (_pSLinterp_UTF8_Mode == 0)
-     {
-	*encoded_len = 1;
-	*u++ = (SLuchar_Type) wch;
-	*u++ = 0;
-	return u;
-     }
-
-   if (NULL == (u1 = SLutf8_encode_null_terminate (wch, u)))
-     {
-	SLang_verror (SL_UNICODE_ERROR, "Unable to encode character 0x%lX", (unsigned long)wch);
-	return NULL;
-     }
-
-   *encoded_len = (unsigned int) (u1 - u);
-   return u1;
-}
-
-#ifdef REGRESSION
-int main (int argc, char **argv)
-{
-   unsigned char *s, *smax;
-   char **t;
-   char *ok_tests [] = 
-     {
-	"",
-	  "",
-	  "",
-	  "",
-	  "",
-	  NULL
-     };
-   char *long_tests [] = 
-     {
-	"",
-	  "",
-	  "",
-	  "",
-	  "",
-	  NULL
-     };
-
-   t = long_tests;
-   while ((s = (unsigned char *) *t++) != NULL)
-     {
-	smax = s + strlen ((char *)s);
-
-	while (s < smax)
-	  {
-	     SLwchar_Type w;
-	     
-	     if (NULL == (s = SLutf8_to_wc (s, smax, &w)))
-	       {
-		  fprintf (stderr, "SLutf8_to_wc failed\n");
-		  break;
-	       }
-	     if (w == 0)
-	       break;
-	     fprintf (stdout, " 0x%X", w);
-	  }
-   
-	fprintf (stdout, "\n");
-     }
-   return 0;
-}
-#endif
-
diff --git a/slang/slutty.c b/slang/slutty.c
deleted file mode 100644
index da07d98..0000000
--- a/slang/slutty.c
+++ /dev/null
@@ -1,618 +0,0 @@
-/* slutty.c --- Unix Low level terminal (tty) functions for S-Lang */
-/*
-Copyright (C) 2004, 2005, 2006 John E. Davis
-
-This file is part of the S-Lang Library.
-
-The S-Lang Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The S-Lang Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this library; if not, write to the Free Software
-Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-USA.  
-*/
-
-#include "slinclud.h"
-
-#include <signal.h>
-/* sequent support thanks to Kenneth Lorber <keni@oasys.dt.navy.mil> */
-/* SYSV (SYSV ISC R3.2 v3.0) provided by iain.lea@erlm.siemens.de */
-
-#if defined (_AIX) && !defined (_ALL_SOURCE)
-# define _ALL_SOURCE	/* so NBBY is defined in <sys/types.h> */
-#endif
-
-#include <sys/time.h>
-#include <sys/types.h>
-
-#ifdef SYSV
-# include <fcntl.h>
-# ifndef CRAY
-#  include <sys/termio.h>
-#  include <sys/stream.h>
-#  include <sys/ptem.h>
-#  include <sys/tty.h>
-# endif
-#endif
-
-#ifdef __BEOS__
-/* Prototype for select */
-# include <net/socket.h>
-#endif
-
-#include <sys/file.h>
-
-#ifndef sun
-# include <sys/ioctl.h>
-#endif
-
-#ifdef __QNX__
-# include <sys/select.h>
-#endif
-
-#include <sys/stat.h>
-#include <errno.h>
-
-#if defined (_AIX) && !defined (FD_SET)
-# include <sys/select.h>	/* for FD_ISSET, FD_SET, FD_ZERO */
-#endif
-
-#ifndef O_RDWR
-# include <fcntl.h>
-#endif
-
-#include "slang.h"
-#include "_slang.h"
-
-int SLang_TT_Read_FD = -1;
-int SLang_TT_Baud_Rate;
-
-#ifdef HAVE_TERMIOS_H
-# if !defined(HAVE_TCGETATTR) || !defined(HAVE_TCSETATTR)
-#   undef HAVE_TERMIOS_H
-# endif
-#endif
-
-#ifndef HAVE_TERMIOS_H
-
-# if !defined(CBREAK) && defined(sun)
-#  ifndef BSD_COMP
-#   define BSD_COMP 1
-#  endif
-#  include <sys/ioctl.h>
-# endif
-
-typedef struct
-  {
-      struct tchars t;
-      struct ltchars lt;
-      struct sgttyb s;
-  }
-TTY_Termio_Type;
-#else
-# include <termios.h>
-typedef struct termios TTY_Termio_Type;
-#endif
-
-static TTY_Termio_Type Old_TTY;
-
-#ifdef HAVE_TERMIOS_H
-typedef SLCONST struct
-{
-   unsigned int key;
-   unsigned int value;
-} Baud_Rate_Type;
-
-static Baud_Rate_Type Baud_Rates [] =
-{
-#ifdef B0
-     {B0, 0},
-#endif
-#ifdef B50
-     {B50, 50},
-#endif
-#ifdef B75
-     {B75, 75},
-#endif
-#ifdef B110
-     {B110, 110},
-#endif
-#ifdef B134
-     {B134, 134},
-#endif
-#ifdef B150
-     {B150, 150},
-#endif
-#ifdef B200
-     {B200, 200},
-#endif
-#ifdef B300
-     {B300, 300},
-#endif
-#ifdef B600
-     {B600, 600},
-#endif
-#ifdef B1200
-     {B1200, 1200},
-#endif
-#ifdef B1800
-     {B1800, 1800},
-#endif
-#ifdef B2400
-     {B2400, 2400},
-#endif
-#ifdef B4800
-     {B4800, 4800},
-#endif
-#ifdef B9600
-     {B9600, 9600},
-#endif
-#ifdef B19200
-     {B19200, 19200},
-#endif
-#ifdef B38400
-     {B38400, 38400},
-#endif
-#ifdef B57600
-     {B57600, 57600},
-#endif
-#ifdef B115200
-     {B115200, 115200},
-#endif
-#ifdef B230400
-     {B230400, 230400},
-#endif
-     {0, 0}
-};
-
-static void
-set_baud_rate (TTY_Termio_Type *tty)
-{
-#ifdef HAVE_CFGETOSPEED
-   unsigned int speed;
-   Baud_Rate_Type *b, *bmax;
-
-   if (SLang_TT_Baud_Rate)
-     return;			       /* already set */
-
-   speed = (unsigned int) cfgetospeed (tty);
-
-   b = Baud_Rates;
-   bmax = b + (sizeof (Baud_Rates)/sizeof(Baud_Rates[0]));
-   while (b < bmax)
-     {
-	if (b->key == speed)
-	  {
-	     SLang_TT_Baud_Rate = b->value;
-	     return;
-	  }
-	b++;
-     }
-#else
-   (void) tty;
-#endif
-}
-
-#endif				       /* HAVE_TERMIOS_H */
-
-#ifdef HAVE_TERMIOS_H
-# define GET_TERMIOS(fd, x) tcgetattr(fd, x)
-# define SET_TERMIOS(fd, x) tcsetattr(fd, TCSADRAIN, x)
-#else
-# ifdef TCGETS
-#  define GET_TERMIOS(fd, x) ioctl(fd, TCGETS, x)
-#  define SET_TERMIOS(fd, x) ioctl(fd, TCSETS, x)
-# else
-#  define X(x,m)  &(((TTY_Termio_Type *)(x))->m)
-#  define GET_TERMIOS(fd, x)	\
-    ((ioctl(fd, TIOCGETC, X(x,t)) || \
-      ioctl(fd, TIOCGLTC, X(x,lt)) || \
-      ioctl(fd, TIOCGETP, X(x,s))) ? -1 : 0)
-#  define SET_TERMIOS(fd, x)	\
-    ((ioctl(fd, TIOCSETC, X(x,t)) ||\
-      ioctl(fd, TIOCSLTC, X(x,lt)) || \
-      ioctl(fd, TIOCSETP, X(x,s))) ? -1 : 0)
-# endif
-#endif
-
-static int TTY_Inited = 0;
-static int TTY_Open = 0;
-
-#ifdef ultrix   /* Ultrix gets _POSIX_VDISABLE wrong! */
-# define NULL_VALUE -1
-#else
-# ifdef _POSIX_VDISABLE
-#  define NULL_VALUE _POSIX_VDISABLE
-# else
-#  define NULL_VALUE 255
-# endif
-#endif
-
-int SLang_init_tty (int abort_char, int no_flow_control, int opost)
-{
-   TTY_Termio_Type newtty;
-
-   SLsig_block_signals ();
-
-   if (TTY_Inited)
-     {
-	SLsig_unblock_signals ();
-	return 0;
-     }
-
-   TTY_Open = 0;
-
-   if ((SLang_TT_Read_FD == -1)
-       || (1 != isatty (SLang_TT_Read_FD)))
-     {
-#ifdef O_RDWR
-# if !defined(__BEOS__) && !defined(__APPLE__)
-	/* I have been told that BEOS will HANG if passed /dev/tty */
-	if ((SLang_TT_Read_FD = open("/dev/tty", O_RDWR)) >= 0)
-	  {
-	     TTY_Open = 1;
-	  }
-# endif
-#endif
-	if (TTY_Open == 0)
-	  {
-	     SLang_TT_Read_FD = fileno (stderr);
-	     if (1 != isatty (SLang_TT_Read_FD))
-	       {
-		  SLang_TT_Read_FD = fileno (stdin);
-		  if (1 != isatty (SLang_TT_Read_FD))
-		    {
-		       fprintf (stderr, "Failed to open terminal.");
-		       return -1;
-		    }
-	       }
-	  }
-     }
-
-   SLang_Abort_Char = abort_char;
-
-   /* Some systems may not permit signals to be blocked.  As a result, the
-    * return code must be checked.
-    */
-   while (-1 == GET_TERMIOS(SLang_TT_Read_FD, &Old_TTY))
-     {
-	if (errno != EINTR)
-	  {
-	     SLsig_unblock_signals ();
-	     return -1;
-	  }
-     }
-
-   while (-1 == GET_TERMIOS(SLang_TT_Read_FD, &newtty))
-     {
-	if (errno != EINTR)
-	  {
-	     SLsig_unblock_signals ();
-	     return -1;
-	  }
-     }
-
-#ifndef HAVE_TERMIOS_H
-   (void) opost;
-   (void) no_flow_control;
-   newtty.s.sg_flags &= ~(ECHO);
-   newtty.s.sg_flags &= ~(CRMOD);
-   /*   if (Flow_Control == 0) newtty.s.sg_flags &= ~IXON; */
-   newtty.t.t_eofc = 1;
-   if (abort_char == -1) SLang_Abort_Char = newtty.t.t_intrc;
-   newtty.t.t_intrc = SLang_Abort_Char;	/* ^G */
-   newtty.t.t_quitc = 255;
-   newtty.lt.t_suspc = 255;   /* to ignore ^Z */
-   newtty.lt.t_dsuspc = 255;    /* to ignore ^Y */
-   newtty.lt.t_lnextc = 255;
-   newtty.s.sg_flags |= CBREAK;		/* do I want cbreak or raw????? */
-#else
-
-   /* get baud rate */
-
-   newtty.c_iflag &= ~(ECHO | INLCR | ICRNL);
-#ifdef ISTRIP
-   /* newtty.c_iflag &= ~ISTRIP; */
-#endif
-   if (opost == 0) newtty.c_oflag &= ~OPOST;
-
-   set_baud_rate (&newtty);
-
-   if (no_flow_control) newtty.c_iflag &= ~IXON; else newtty.c_iflag |= IXON;
-
-   newtty.c_cc[VEOF] = 1;
-   newtty.c_cc[VMIN] = 1;
-   newtty.c_cc[VTIME] = 0;
-   newtty.c_lflag = ISIG | NOFLSH;
-   if (abort_char == -1) SLang_Abort_Char = newtty.c_cc[VINTR];
-   newtty.c_cc[VINTR] = SLang_Abort_Char;   /* ^G */
-   newtty.c_cc[VQUIT] = NULL_VALUE;
-   newtty.c_cc[VSUSP] = NULL_VALUE;   /* to ignore ^Z */
-#ifdef VDSUSP
-   newtty.c_cc[VDSUSP] = NULL_VALUE;   /* to ignore ^Y */
-#endif
-#ifdef VLNEXT
-   newtty.c_cc[VLNEXT] = NULL_VALUE;   /* to ignore ^V ? */
-#endif
-#ifdef VSWTCH
-   newtty.c_cc[VSWTCH] = NULL_VALUE;   /* to ignore who knows what */
-#endif
-#endif /* NOT HAVE_TERMIOS_H */
-
-   while (-1 == SET_TERMIOS(SLang_TT_Read_FD, &newtty))
-     {
-	if (errno != EINTR)
-	  {
-	     SLsig_unblock_signals ();
-	     return -1;
-	  }
-     }
-
-   TTY_Inited = 1;
-   SLsig_unblock_signals ();
-   return 0;
-}
-
-void SLtty_set_suspend_state (int mode)
-{
-   TTY_Termio_Type newtty;
-
-   SLsig_block_signals ();
-
-   if (TTY_Inited == 0)
-     {
-	SLsig_unblock_signals ();
-	return;
-     }
-
-   while ((-1 == GET_TERMIOS (SLang_TT_Read_FD, &newtty))
-	  && (errno == EINTR))
-     ;
-
-#ifndef HAVE_TERMIOS_H
-   /* I do not know if all systems define the t_dsuspc field */
-   if (mode == 0)
-     {
-	newtty.lt.t_suspc = 255;
-	newtty.lt.t_dsuspc = 255;
-     }
-   else
-     {
-	newtty.lt.t_suspc = Old_TTY.lt.t_suspc;
-	newtty.lt.t_dsuspc = Old_TTY.lt.t_dsuspc;
-     }
-#else
-   if (mode == 0)
-     {
-	newtty.c_cc[VSUSP] = NULL_VALUE;
-#ifdef VDSUSP
-	newtty.c_cc[VDSUSP] = NULL_VALUE;
-#endif
-     }
-   else
-     {
-	newtty.c_cc[VSUSP] = Old_TTY.c_cc[VSUSP];
-#ifdef VDSUSP
-	newtty.c_cc[VDSUSP] = Old_TTY.c_cc[VDSUSP];
-#endif
-     }
-#endif
-
-   while ((-1 == SET_TERMIOS (SLang_TT_Read_FD, &newtty))
-	  && (errno == EINTR))
-     ;
-
-   SLsig_unblock_signals ();
-}
-
-void SLang_reset_tty (void)
-{
-   SLsig_block_signals ();
-
-   if (TTY_Inited == 0)
-     {
-	SLsig_unblock_signals ();
-	return;
-     }
-
-   while ((-1 == SET_TERMIOS(SLang_TT_Read_FD, &Old_TTY))
-	  && (errno == EINTR))
-     ;
-
-   if (TTY_Open)
-     {
-	while ((-1 == close (SLang_TT_Read_FD))
-	       && (errno == EINTR))
-	  ;
-
-	TTY_Open = 0;
-	SLang_TT_Read_FD = -1;
-     }
-
-   TTY_Inited = 0;
-   SLsig_unblock_signals ();
-}
-
-static void default_sigint (int sig)
-{
-   sig = errno;			       /* use parameter */
-
-   SLKeyBoard_Quit = 1;
-   if (SLang_Ignore_User_Abort == 0) SLang_set_error (SL_USER_BREAK);
-   SLsignal_intr (SIGINT, default_sigint);
-   errno = sig;
-}
-
-int SLang_set_abort_signal (void (*hand)(int))
-{
-   int save_errno = errno;
-   SLSig_Fun_Type *f;
-
-   if (hand == NULL) hand = default_sigint;
-   f = SLsignal_intr (SIGINT, hand);
-
-   errno = save_errno;
-
-   if (f == (SLSig_Fun_Type *) SIG_ERR)
-     return -1;
-
-   return 0;
-}
-
-#ifndef FD_SET
-#define FD_SET(fd, tthis) *(tthis) = 1 << (fd)
-#define FD_ZERO(tthis)    *(tthis) = 0
-#define FD_ISSET(fd, tthis) (*(tthis) & (1 << fd))
-typedef int fd_set;
-#endif
-
-static fd_set Read_FD_Set;
-
-/* HACK: If > 0, use 1/10 seconds.  If < 0, use 1/1000 seconds */
-
-int _pSLsys_input_pending(int tsecs)
-{
-   struct timeval wait;
-   long usecs, secs;
-
-   if ((TTY_Inited == 0)
-       || (SLang_TT_Read_FD < 0))
-     {
-	errno = EBADF;
-	return -1;
-     }
-
-   if (tsecs >= 0)
-     {
-	secs = tsecs / 10;
-	usecs = (tsecs % 10) * 100000;
-     }
-   else
-     {
-	tsecs = -tsecs;
-	secs = tsecs / 1000;
-	usecs = (tsecs % 1000) * 1000;
-     }
-
-   wait.tv_sec = secs;
-   wait.tv_usec = usecs;
-
-   FD_ZERO(&Read_FD_Set);
-   FD_SET(SLang_TT_Read_FD, &Read_FD_Set);
-
-   return select(SLang_TT_Read_FD + 1, &Read_FD_Set, NULL, NULL, &wait);
-}
-
-int (*SLang_getkey_intr_hook) (void);
-
-static int handle_interrupt (void)
-{
-   if (SLang_getkey_intr_hook != NULL)
-     {
-	int save_tty_fd = SLang_TT_Read_FD;
-
-	if (-1 == (*SLang_getkey_intr_hook) ())
-	  return -1;
-
-	if (save_tty_fd != SLang_TT_Read_FD)
-	  return -1;
-     }
-
-   return 0;
-}
-
-unsigned int _pSLsys_getkey (void)
-{
-   unsigned char c;
-
-   if (TTY_Inited == 0)
-     {
-	int ic = fgetc (stdin);
-	if (ic == EOF) return SLANG_GETKEY_ERROR;
-	return (unsigned int) ic;
-     }
-
-   while (1)
-     {
-	int ret;
-
-	if (SLKeyBoard_Quit)
-	  return SLang_Abort_Char;
-
-	if (0 == (ret = _pSLsys_input_pending (100)))
-	  continue;
-
-	if (ret != -1)
-	  break;
-
-	if (SLKeyBoard_Quit)
-	  return SLang_Abort_Char;
-
-	if (errno == EINTR)
-	  {
-	     if (-1 == handle_interrupt ())
-	       return SLANG_GETKEY_ERROR;
-
-	     continue;
-	  }
-
-	break;			       /* let read handle it */
-     }
-
-   while (1)
-     {
-	int status = read(SLang_TT_Read_FD, (char *) &c, 1);
-
-	if (status > 0)
-	  break;
-
-	if (status == 0)
-	  {
-	     /* We are at the end of a file.  Let application handle it. */
-	     return SLANG_GETKEY_ERROR;
-	  }
-
-	if (errno == EINTR)
-	  {
-	     if (-1 == handle_interrupt ())
-	       return SLANG_GETKEY_ERROR;
-
-	     if (SLKeyBoard_Quit)
-	       return SLang_Abort_Char;
-
-	     continue;
-	  }
-#ifdef EAGAIN
-	if (errno == EAGAIN)
-	  {
-	     sleep (1);
-	     continue;
-	  }
-#endif
-#ifdef EWOULDBLOCK
-	if (errno == EWOULDBLOCK)
-	  {
-	     sleep (1);
-	     continue;
-	  }
-#endif
-#ifdef EIO
-	if (errno == EIO)
-	  {
-	     SLang_verror (SL_Read_Error, "_pSLsys_getkey: EIO error");
-	  }
-#endif
-	return SLANG_GETKEY_ERROR;
-     }
-
-   return((unsigned int) c);
-}
-
diff --git a/slang/slwcwidth.c b/slang/slwcwidth.c
deleted file mode 100644
index 4837d5d..0000000
--- a/slang/slwcwidth.c
+++ /dev/null
@@ -1,15 +0,0 @@
-#include "slinclud.h"
-#include <ctype.h>
-
-#include "slang.h"
-#include "_slang.h"
-
-#define DEFINE_PSLWC_WIDTH_TABLE
-#include "slwcwidth.h"
-int SLwchar_wcwidth (SLwchar_Type ch)
-{
-   int w;
-   
-   SL_WIDTH_ALOOKUP(w,ch);
-   return w;
-}
diff --git a/src/Makefile.am b/src/Makefile.am
index ccf0f8b..cd7939a 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -22,10 +22,6 @@ cons_saver_SOURCES = cons.saver.c
 
 man2hlp_SOURCES = man2hlp.c glibcompat.c
 
-if INCLUDED_SLANG
-SLANGLIB = ../slang/libmcslang.a
-endif
-
 if USE_EDIT
 EDITLIB = ../edit/libedit.a
 endif
diff --git a/src/main.c b/src/main.c
index 949dcf9..ca9854a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -2028,10 +2028,6 @@ handle_args (int argc, char *argv[])
 	poptGetContext ("mc", argc, argv, argument_table,
 			POPT_CONTEXT_NO_EXEC);
 
-#ifdef USE_TERMCAP
-    SLtt_Try_Termcap = 1;
-#endif
-
     while ((c = poptGetNextOpt (ctx)) > 0) {
 	process_args (ctx, c, poptGetOptArg (ctx));
     }
diff --git a/src/myslang.h b/src/myslang.h
index 17057e7..a8c8b42 100644
--- a/src/myslang.h
+++ b/src/myslang.h
@@ -1,15 +1,11 @@
 #ifndef MC_MYSLANG_H
 #define MC_MYSLANG_H
 
-#ifndef HAVE_SYSTEM_SLANG
-#    include "../slang/include/slang.h"
-#else
 #ifdef HAVE_SLANG_SLANG_H
 #    include <slang/slang.h>
 #else
 #    include <slang.h>
 #endif	/* HAVE_SLANG_SLANG_H */
-#endif
 
 enum {
     KEY_BACKSPACE = 400,
diff --git a/src/slint.c b/src/slint.c
index c30fac1..5945b42 100644
--- a/src/slint.c
+++ b/src/slint.c
@@ -56,13 +56,6 @@
 # endif
 #endif
 
-/* Taken from S-Lang's sldisply.c file */
-#ifndef USE_TERMCAP
-#   define tgetstr(a,b) SLtt_tgetstr (a)
-#else
-    extern char *tgetstr(char *, char **);
-#endif
-
 #ifndef SA_RESTART
 #    define SA_RESTART 0
 #endif
diff --git a/src/textconf.c b/src/textconf.c
index e51ed6d..fa7cb0e 100644
--- a/src/textconf.c
+++ b/src/textconf.c
@@ -58,19 +58,11 @@ static const char *const features[] = {
 
 #ifdef HAVE_SLANG
 
-#   ifdef HAVE_SYSTEM_SLANG
     N_("Using system-installed S-Lang library"),
-#   else
-    N_("Using included S-Lang library"),
-#   endif
 
     " ",
 
-#ifdef USE_TERMCAP
-    N_("with termcap database"),
-#else
     N_("with terminfo database"),
-#endif
 
 #elif defined(USE_NCURSES)
     N_("Using the ncurses library"),
